var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var Widget = (function () {
            function Widget() {
            }
            return Widget;
        }());
        Services.Widget = Widget;
        var WidgetStyle = (function () {
            function WidgetStyle() {
                this.shadow = true;
            }
            return WidgetStyle;
        }());
        Services.WidgetStyle = WidgetStyle;
        var BaseWidget = (function () {
            //public static deserialize(input: IWidget): IWidget {
            //    var loader = new InstanceLoader(window);
            //    var w = <IWidget>loader.getInstance(widget.widgetType);
            //    var res = $.extend(new BaseWidget(), input);
            //    return res;
            //}
            function BaseWidget(title, type) {
                this.enabled = true;
                this.opacity = 1;
                this.background = "white";
                this.renderer = function ($compile, $scope) { };
                this.resize = function (status, width, height) { };
                if (title)
                    this.title = title;
                this.properties = {};
                this.dataSets = [];
            }
            BaseWidget.serializeableData = function (w) {
                var r = {
                    id: w.id,
                    directive: w.directive,
                    template: w.template,
                    title: w.title,
                    name: w.name,
                    timeDependent: w.timeDependent,
                    url: w.url,
                    enabled: w.enabled,
                    customStyle: w.customStyle,
                    style: w.style,
                    left: w.left,
                    right: w.right,
                    top: w.top,
                    bottom: w.bottom,
                    width: w.width,
                    height: w.height,
                    allowFullscreen: w.allowFullscreen,
                    properties: w.properties,
                    hover: w.hover,
                    //dataSets:      {},// w.dataSets,
                    range: w.range,
                    collapse: w.collapse,
                    canCollapse: w.canCollapse,
                    data: BaseWidget.cloneWithout0(w.data)
                };
                return r;
            };
            BaseWidget.cloneWithout0 = function (v) {
                var _this = this;
                if (typeof v !== "object")
                    return v;
                if (v instanceof Array) {
                    var a = [];
                    v.forEach(function (i) {
                        a.push(_this.cloneWithout0(i));
                    });
                    return a;
                }
                else {
                    var c = {};
                    for (var k in v) {
                        if (k[0] !== '_')
                            c[k] = this.cloneWithout0(v[k]);
                    }
                    return c;
                }
                // if (v['0']) {
                //   for (var k in v['0']) {
                //     if (k !== '0') c[k] = this.cloneWithout0(v['0'][k]);
                //   }
                // }
            };
            BaseWidget.prototype.start = function () { };
            BaseWidget.prototype.init = function () {
                //if (!sizeX)
                //this.sizeX = sX;
                //this.sizeY = sY;
                //this.col = c;
                //this.row = r;
                this.background = "red";
                if (!this.id)
                    this.id = "widget" + csComp.Helpers.getGuid().replace('-', '');
                //this.width = (width) ? width : 300;
                //this.height = (height) ? height : 150;
                //this.id = id;
                this.elementId = this.id;
                this.start();
            };
            BaseWidget.prototype.updateDateRange = function (r) {
                this.range = r;
            };
            return BaseWidget;
        }());
        Services.BaseWidget = BaseWidget;
        var Dashboard = (function () {
            function Dashboard() {
                this.mapWidth = '100%';
                this.alignMapRight = false;
                this.mobile = true;
                this.showTimeline = true;
                this.draggable = true;
                this.resizable = true;
                this.showLeftmenu = true;
                this.showRightmenu = false;
                this.showLegend = false;
                this.showBackgroundImage = false;
                this.widgets = [];
            }
            /**
             * Returns an object which contains all the data that must be serialized.
             */
            Dashboard.serializeableData = function (d) {
                return {
                    id: d.id,
                    name: d.name,
                    editMode: d.editMode,
                    showMap: d.showMap,
                    mapWidth: d.mapWidth,
                    alignMapRight: d.alignMapRight,
                    showTimeline: d.showTimeline,
                    showLeftmenu: d.showLeftmenu,
                    showLegend: d.showLegend,
                    showRightmenu: d.showRightmenu,
                    showBackgroundImage: d.showBackgroundImage,
                    background: d.background,
                    backgroundimage: d.backgroundimage,
                    visiblelayers: d.visiblelayers,
                    baselayer: d.baselayer,
                    viewBounds: d.viewBounds,
                    widgets: csComp.Helpers.serialize(d.widgets, BaseWidget.serializeableData),
                    visibleLeftMenuItems: d.visibleLeftMenuItems,
                    mobile: d.mobile,
                    isLive: d.isLive
                };
            };
            Dashboard.deserialize = function (input, solution) {
                var _this = this;
                var res = $.extend(new Dashboard(), input);
                res.widgets = [];
                if (typeof input.isLive === 'undefined')
                    input.isLive = false;
                if (input.widgets)
                    input.widgets.forEach(function (w) {
                        _this.addNewWidget(w, res, solution);
                    });
                if (input.timeline)
                    res.timeline = $.extend(new Services.DateRange(), input.timeline);
                return res;
            };
            Dashboard.addNewWidget = function (widget, dashboard, solution) {
                //var loader = new InstanceLoader(window);
                //var w = <IWidget>loader.getInstance(widget.widgetType);
                //w.messageBusService = this.$messageBusService;
                //w.layerService = this.$layerService;
                //w.init();
                //var w = BaseWidget();
                if (!widget.id)
                    widget.id = csComp.Helpers.getGuid();
                //alert(widget.id);
                widget.elementId = "widget-" + widget.id;
                widget.parentDashboard = dashboard;
                if (widget.style && widget.style !== "custom") {
                    if (!solution.hasOwnProperty('widgetStyles') || !solution.widgetStyles.hasOwnProperty(widget.style))
                        widget.style = "default";
                    widget.effectiveStyle = solution.widgetStyles[widget.style];
                }
                else {
                    widget.effectiveStyle = widget.customStyle;
                }
                dashboard.widgets.push(widget);
                /*if (this.$rootScope.$root.$$phase != '$apply' && this.$rootScope.$root.$$phase != '$digest') { this.$rootScope.$apply(); }
                setTimeout(() => {
                    //if (w != null) w.renderer(this.$compile, this.$rootScope);
                    this.updateWidget(widget);
    
                }, 50);*/
                //this.editWidget(w);
                return widget;
            };
            return Dashboard;
        }());
        Services.Dashboard = Dashboard;
        var Timeline = (function () {
            function Timeline() {
            }
            return Timeline;
        }());
        Services.Timeline = Timeline;
        var TimedDataSet = (function () {
            function TimedDataSet() {
            }
            return TimedDataSet;
        }());
        Services.TimedDataSet = TimedDataSet;
        var DataSet = (function () {
            function DataSet(id, title) {
                this.id = id;
                this.title = title;
                this.data = [];
            }
            return DataSet;
        }());
        Services.DataSet = DataSet;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=dashboard.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var SensorSet = (function () {
            function SensorSet() {
                this.max = 100;
                this.min = 0;
            }
            SensorSet.prototype.activeValueText = function () {
                return csComp.Helpers.convertPropertyInfo(this.propertyType, this.activeValue);
            };
            SensorSet.prototype.addValue = function (date, value) {
                this.timestamps.push(date);
                this.values.push(value);
                this.activeValue = value;
            };
            /**
             * Serialize the project to a JSON string.
             */
            SensorSet.prototype.serialize = function () {
                return JSON.stringify(SensorSet.serializeableData(this), function (key, value) {
                    // Skip serializing certain keys
                    return value;
                }, 2);
            };
            /**
             * Returns an object which contains all the data that must be serialized.
             */
            SensorSet.serializeableData = function (d) {
                return {
                    id: d.id,
                    title: d.title,
                    type: d.type,
                    propertyTypeKey: d.propertyTypeKey
                };
            };
            return SensorSet;
        }());
        Services.SensorSet = SensorSet;
        var DataSource = (function () {
            function DataSource() {
                this.sensors = {};
            }
            DataSource.merge_sensor = function (s1, s2) {
                var obj3 = new SensorSet();
                for (var attrname in s1) {
                    obj3[attrname] = s1[attrname];
                }
                for (var attrname in s2) {
                    obj3[attrname] = s2[attrname];
                }
                return obj3;
            };
            /**
             * Returns an object which contains all the data that must be serialized.
             */
            DataSource.serializeableData = function (d) {
                var res = {
                    id: d.id,
                    url: d.url,
                    type: d.type,
                    title: d.title,
                    sensors: {}
                };
                //for (var ss in d.sensors) res.sensors[ss] = d.sensors[ss].serialize();
                return res;
            };
            /**
             * Load JSON data.
             * @type {DataSource}
             *
             * @param $http {ng.IHttpService}
             * @param ds {DataSource}
             * @param callback {Function}
             */
            DataSource.LoadData = function ($http, ds, callback) {
                var _this = this;
                if (ds.url != null) {
                    $http.get(ds.url)
                        .success(function (temp) {
                        if (temp != null) {
                            ds.id = temp.id;
                            if (!ds.hasOwnProperty('sensors')) {
                                ds.sensors = temp.sensors;
                            }
                            else {
                                for (var s in temp.sensors) {
                                    if (temp.sensors.hasOwnProperty(s)) {
                                        ds.sensors[s] = _this.merge_sensor(ds.sensors[s], temp.sensors[s]);
                                    }
                                }
                            }
                            ds.title = temp.title;
                            callback();
                        }
                    })
                        .error(function () { console.log('Error on Data source -- do something ?'); });
                }
            };
            return DataSource;
        }());
        Services.DataSource = DataSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=datasource.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var Section = (function () {
            function Section() {
                this.properties = {};
            }
            return Section;
        }());
        Services.Section = Section;
        var Log = (function () {
            function Log() {
            }
            return Log;
        }());
        Services.Log = Log;
        /**
         * A feature is a single object that is show on a map (e.g. point, polyline, etc)
         * Features are part of a layer and filtered and styled using group filters and styles
         *
         */
        var Feature = (function () {
            function Feature() {
                this.type = 'Feature';
                this._gui = { included: true };
                this.logs = {};
            }
            Feature.serialize = function (f) {
                var res = {};
                res.id = f.id;
                res.type = f.type;
                res.geometry = f.geometry;
                res.properties = f.properties;
                res.logs = f.logs;
                if (f.timestamps)
                    res.timestamps = f.timestamps;
                if (f.sensors)
                    res.sensors = f.sensors;
                return res;
            };
            return Feature;
        }());
        Services.Feature = Feature;
        (function (DrawingModeType) {
            DrawingModeType[DrawingModeType["None"] = 0] = "None";
            DrawingModeType[DrawingModeType["Image"] = 1] = "Image";
            DrawingModeType[DrawingModeType["Point"] = 2] = "Point";
            DrawingModeType[DrawingModeType["Square"] = 3] = "Square";
            DrawingModeType[DrawingModeType["Rectangle"] = 4] = "Rectangle";
            DrawingModeType[DrawingModeType["Line"] = 5] = "Line";
            DrawingModeType[DrawingModeType["Circle"] = 6] = "Circle";
            DrawingModeType[DrawingModeType["Freehand"] = 7] = "Freehand";
            DrawingModeType[DrawingModeType["Polyline"] = 8] = "Polyline";
            DrawingModeType[DrawingModeType["Polygon"] = 9] = "Polygon";
            DrawingModeType[DrawingModeType["MultiPolygon"] = 10] = "MultiPolygon";
        })(Services.DrawingModeType || (Services.DrawingModeType = {}));
        var DrawingModeType = Services.DrawingModeType;
        //export enum propertyTypeType {
        //    Text,
        //    TextArea,
        //    Rating,
        //    Number,
        //    Bbcode,
        //    Boolean,
        //    Bit,
        //    Sensor,
        //    Xml,
        //    Options,
        //    Unknown,
        //    Image,
        //    DateTime,
        //    Mediafolder
        //}
        (function (featureFilterType) {
            /** Turn filtering off */
            featureFilterType[featureFilterType["none"] = 0] = "none";
            /** Default for numbers: histogram */
            featureFilterType[featureFilterType["bar"] = 1] = "bar";
            /** Default for text */
            featureFilterType[featureFilterType["text"] = 2] = "text";
        })(Services.featureFilterType || (Services.featureFilterType = {}));
        var featureFilterType = Services.featureFilterType;
        (function (LayerActivationTypes) {
            LayerActivationTypes[LayerActivationTypes["manual"] = 0] = "manual";
            LayerActivationTypes[LayerActivationTypes["automatic"] = 1] = "automatic";
        })(Services.LayerActivationTypes || (Services.LayerActivationTypes = {}));
        var LayerActivationTypes = Services.LayerActivationTypes;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=feature.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var Feed = (function (_super) {
            __extends(Feed, _super);
            function Feed() {
                _super.apply(this, arguments);
            }
            return Feed;
        }(Services.Feature));
        Services.Feed = Feed;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=feed.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        (function (LayerType) {
            LayerType[LayerType["GeoJson"] = 0] = "GeoJson";
            LayerType[LayerType["Kml"] = 1] = "Kml";
        })(Services.LayerType || (Services.LayerType = {}));
        var LayerType = Services.LayerType;
        /** a project group contains a list of layers that can be grouped together.
         * Filters, styles can clustering is always defined on the group level.
         * If a filter is selected (e.g. show only the features within a certain property range)
         * this filter is applied to all layers within this group.
         * If clustering is enabled all features in all layers are grouped together
         */
        var ProjectGroup = (function () {
            function ProjectGroup() {
                /**
                 * gui is used for setting temp. properties for rendering
                 */
                this._gui = {};
            }
            /**
             * Returns an object which contains all the data that must be serialized.
             */
            ProjectGroup.serializeableData = function (projectGroup) {
                return {
                    id: projectGroup.id,
                    title: projectGroup.title,
                    description: projectGroup.description,
                    showTitle: projectGroup.showTitle,
                    clustering: projectGroup.clustering,
                    clusterLevel: projectGroup.clusterLevel,
                    maxClusterRadius: projectGroup.maxClusterRadius,
                    oneLayerActive: projectGroup.oneLayerActive,
                    styleProperty: projectGroup.styleProperty,
                    languages: projectGroup.languages,
                    layers: csComp.Helpers.serialize(projectGroup.layers, Services.ProjectLayer.serializeableData)
                };
            };
            ProjectGroup.deserialize = function (input) {
                var res = $.extend(new ProjectGroup(), input);
                if (res.owsurl) {
                    res.loadLayersFromOWS();
                }
                if (res.layers) {
                    res.layers.forEach(function (layer) {
                        if (!layer.opacity)
                            layer.opacity = 100;
                    });
                }
                return res;
            };
            ProjectGroup.prototype.loadLayersFromOWS = function ($injector) {
                var _this = this;
                if ($injector === void 0) { $injector = null; }
                this.layers = []; // add some layers here...
                if ($injector == null) {
                    $injector = angular.injector(['ng']);
                }
                $injector.invoke(function ($http) {
                    $http.get(_this.owsurl)
                        .success(function (xml) { _this.parseXML(xml); })
                        .error(function (xml, status) {
                        console.log('Unable to load OWSurl: ' + _this.owsurl);
                        console.log('          HTTP status: ' + status);
                    });
                });
            };
            ProjectGroup.prototype.parseXML = function (xml) {
                var theGroup = this;
                var baseurl = this.owsurl.split('?')[0];
                $(xml).find('Layer').each(function () {
                    // DO NOT use arrow notation (=>) as it will break this !!!
                    var layerName = $(this).children('Name').text();
                    if (layerName != null && layerName !== '') {
                        var title = $(this).children('Title').text();
                        // If <KeywordList> element has an element <keyword vocabulary="defaultFeatureType">featureType</keyword>
                        // use featureType as defaultFeatureType
                        var featureType = $(this).children('KeywordList').children('[vocabulary="defaultFeatureType"]').text();
                        var resourceURL = $(this).children('KeywordList').children('[vocabulary="typeResourceURL"]').text();
                        // TODO: should be using layerService.initLayer(theGroup, layer);
                        // But I don't know how to 'inject' layerService :(
                        var layer = theGroup.buildLayer(baseurl, title, layerName);
                        if (featureType != '') {
                            layer.defaultFeatureType = featureType;
                            layer.typeUrl = 'data/resourceTypes/resources.json';
                        }
                        if (resourceURL != '') {
                            layer.typeUrl = resourceURL;
                        }
                        theGroup.layers.push(layer);
                    }
                });
            };
            ProjectGroup.prototype.buildLayer = function (baseurl, title, layerName) {
                var extraInfo = {
                    'id': csComp.Helpers.getGuid(),
                    'reference': layerName,
                    'title': title,
                    'enabled': false,
                    'group': this
                };
                // Image layers
                if (this.owsgeojson) {
                    extraInfo['type'] = 'geojson';
                    extraInfo['url'] = baseurl + '?service=wfs&request=getFeature' +
                        '&outputFormat=application/json&typeName=' + layerName;
                }
                else {
                    extraInfo['type'] = 'wms';
                    extraInfo['wmsLayers'] = layerName;
                    extraInfo['url'] = baseurl;
                }
                var layer = jQuery.extend(new Services.ProjectLayer(), extraInfo);
                return layer;
            };
            return ProjectGroup;
        }());
        Services.ProjectGroup = ProjectGroup;
        /**
         * Filters are used to select a subset of features within a group.
         */
        var GroupFilter = (function () {
            function GroupFilter() {
            }
            return GroupFilter;
        }());
        Services.GroupFilter = GroupFilter;
        /**
         * Styles determine how features are shown on the map.
         */
        var GroupStyle = (function () {
            function GroupStyle($translate) {
                var _this = this;
                this.availableAspects = ['strokeColor', 'fillColor', 'strokeWidth', 'height'];
                this.colorScales = {};
                this.legends = {};
                this.fixedColorRange = false;
                $translate('WHITE_RED').then(function (translation) {
                    _this.colorScales[translation] = ['white', 'red'];
                });
                $translate('GREEN_RED').then(function (translation) {
                    _this.colorScales[translation] = ['green', 'red'];
                });
                $translate('RED_GREEN').then(function (translation) {
                    _this.colorScales[translation] = ['red', 'green'];
                });
                $translate('BLUE_RED').then(function (translation) {
                    _this.colorScales[translation] = ['#F04030', '#3040F0'];
                });
                $translate('RED_BLUE').then(function (translation) {
                    _this.colorScales[translation] = ['#3040F0', '#F04030'];
                });
                $translate('WHITE_BLUE').then(function (translation) {
                    _this.colorScales[translation] = ['white', 'blue'];
                });
                $translate('BLUE_WHITE').then(function (translation) {
                    _this.colorScales[translation] = ['blue', 'white'];
                });
                $translate('WHITE_GREEN').then(function (translation) {
                    _this.colorScales[translation] = ['white', 'green'];
                });
                $translate('GREEN_WHITE').then(function (translation) {
                    _this.colorScales[translation] = ['green', 'white'];
                });
                $translate('WHITE_ORANGE').then(function (translation) {
                    _this.colorScales[translation] = ['white', '#FF5500'];
                });
                $translate('ORANGE_WHITE').then(function (translation) {
                    _this.colorScales[translation] = ['#FF5500', 'white'];
                });
                $translate('RED_WHITE_BLUE').then(function (translation) {
                    _this.colorScales[translation] = ['red', 'white', 'blue'];
                });
            }
            return GroupStyle;
        }());
        Services.GroupStyle = GroupStyle;
        /**
         * the Legend class provides a data structure that is used to map a value to a color
         * (see also the function getColor())
        */
        var Legend = (function () {
            function Legend() {
            }
            return Legend;
        }());
        Services.Legend = Legend;
        var LegendEntry = (function () {
            function LegendEntry() {
            }
            return LegendEntry;
        }());
        Services.LegendEntry = LegendEntry;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=group.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        /** Layer information. a layer is described in a project file and is always part of a group */
        var ProjectLayer = (function () {
            function ProjectLayer() {
                /** Default true, but if set to false, do not notify the timeline of changes. */
                this.timeAware = true;
                /**
                 * gui is used for setting temp. values for rendering
                 */
                this._gui = {};
                /** show notification on new feature */
                this.showFeatureNotifications = true;
            }
            /** Get the features from the layer's original source, if present. */
            ProjectLayer.getFeatures = function (layer) {
                return (layer.data && layer.data.features)
                    ? layer.data.features
                    : null;
            };
            /**
             * Returns an object which contains all the data that must be serialized.
             */
            ProjectLayer.serializeableData = function (pl) {
                return {
                    id: pl.id,
                    title: pl.title,
                    description: pl.description,
                    type: pl.type,
                    renderType: pl.renderType,
                    heatmapSettings: pl.heatmapSettings,
                    heatmapItems: csComp.Helpers.serialize(pl.heatmapItems, Heatmap.HeatmapItem.serializeableData),
                    url: pl.url,
                    typeUrl: pl.typeUrl,
                    sensors: pl.sensors,
                    sensorLink: pl.sensorLink,
                    wmsLayers: pl.wmsLayers,
                    opacity: pl.opacity,
                    isSublayer: pl.isSublayer,
                    BBOX: pl.BBOX,
                    refreshBBOX: pl.refreshBBOX,
                    refreshTimeInterval: pl.refreshTimeInterval,
                    quickRefresh: pl.quickRefresh,
                    languages: pl.languages,
                    events: pl.events,
                    dataSourceParameters: pl.dataSourceParameters,
                    defaultFeatureType: pl.defaultFeatureType,
                    defaultLegendProperty: pl.defaultLegendProperty,
                    defaultLegend: pl.defaultLegend,
                    useProxy: pl.useProxy,
                    isDynamic: pl.isDynamic,
                    isEditable: pl.isEditable,
                    useLog: pl.useLog,
                    tags: pl.tags,
                    hasSensorData: pl.hasSensorData,
                    timeAware: pl.timeAware,
                    fitToMap: pl.fitToMap,
                    minZoom: pl.minZoom,
                    maxZoom: pl.maxZoom
                };
            };
            return ProjectLayer;
        }());
        Services.ProjectLayer = ProjectLayer;
        var BaseLayer = (function () {
            function BaseLayer() {
                /**
                 * Max native zoom level:
                 * Maximum zoom number the tiles source has available.
                 * If it is specified, the tiles on all zoom levels higher than maxNativeZoom will be loaded from maxZoom level and auto-scaled.
                 */
                this.maxNativeZoom = 19;
            }
            return BaseLayer;
        }());
        Services.BaseLayer = BaseLayer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=layer.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        Services.availableZoomLevels = [
            { title: 'decades', value: 315360000000 },
            { title: 'years', value: 31536000000 },
            { title: 'weeks', value: 604800000 },
            { title: 'days', value: 86400000 },
            { title: 'hours', value: 3600000 },
            { title: 'quarters', value: 900000 },
            { title: 'minutes', value: 60000 },
            { title: 'seconds', value: 1000 },
            { title: 'milliseconds', value: 1 }
        ];
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=map.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        /**
        * Expert level for determining what options to show to the user.
        */
        (function (Expertise) {
            Expertise[Expertise["Beginner"] = 1] = "Beginner";
            Expertise[Expertise["Intermediate"] = 2] = "Intermediate";
            Expertise[Expertise["Expert"] = 3] = "Expert";
            Expertise[Expertise["Admin"] = 4] = "Admin";
        })(Services.Expertise || (Services.Expertise = {}));
        var Expertise = Services.Expertise;
        var VisualState = (function () {
            function VisualState() {
                this.leftPanelVisible = false;
                this.rightPanelVisible = false;
                this.dashboardVisible = true;
                this.mapVisible = true;
                this.mapWidth = '100%';
                this.alignMapRight = false; // Default align map left
                this.timelineVisible = true;
            }
            return VisualState;
        }());
        Services.VisualState = VisualState;
        //** class for describing time ranges for timeline, including focus time */
        var DateRange = (function () {
            function DateRange() {
                var _this = this;
                this.enableLive = true;
                this.enablePlay = true;
                this.enableEvents = true;
                this.enableFocus = true;
                this.startDate = function () {
                    if (_this.focus < _this.start) {
                        _this.start = _this.focus - _this.range / 5;
                    }
                    return new Date(_this.start);
                };
                this.focusDate = function () { return new Date(_this.focus); };
                this.endDate = function () {
                    if (_this.focus > _this.end) {
                        _this.end = _this.focus + _this.range / 5;
                    }
                    return new Date(_this.end);
                };
            }
            //constructor() {
            //    if (!this.focus) this.setFocus(new Date());
            //}
            DateRange.deserialize = function (input) {
                var res = $.extend(new DateRange(), input);
                if (typeof res.focus === 'undefined' || res.focus === null) {
                    res.focus = Date.now();
                }
                if (typeof res.enableLive === 'undefined') {
                    res.enableLive = true;
                }
                if (typeof res.enablePlay === 'undefined') {
                    res.enablePlay = true;
                }
                if (typeof res.enableEvents === 'undefined') {
                    res.enableEvents = true;
                }
                if (typeof res.enableFocus === 'undefined') {
                    res.enableFocus = true;
                }
                if (typeof res.expandHeight === 'undefined') {
                    res.expandHeight = 150;
                }
                return res;
            };
            /**
            * Set the focus time of the timeline, optionally including start and end time.
            */
            DateRange.prototype.setFocus = function (d, s, e) {
                var _this = this;
                this.focus = d.getTime();
                if (s) {
                    this.start = s.getTime();
                }
                if (e) {
                    this.end = e.getTime();
                }
                var newRange = this.end - this.start;
                if (this.range !== newRange) {
                    this.range = newRange;
                    Services.availableZoomLevels.some(function (tl) {
                        _this.zoomLevel = tl.value;
                        _this.zoomLevelName = tl.title;
                        return (tl.value < (_this.range / 10));
                    });
                }
            };
            return DateRange;
        }());
        Services.DateRange = DateRange;
        /**
         * Represents to the overall solution class. A solution can contain multiple project.
         * This can be usefull when you want to have the same website, but with different content.
         * e.g. you could make it so that you can switch between different regions or different domains of interest.
         */
        var Solution = (function () {
            function Solution() {
                this.widgetStyles = {};
            }
            return Solution;
        }());
        Services.Solution = Solution;
        /** Project within a solution file, refers to a project url*/
        var SolutionProject = (function () {
            function SolutionProject() {
            }
            return SolutionProject;
        }());
        Services.SolutionProject = SolutionProject;
        (function (authMethods) {
            authMethods[authMethods["none"] = 0] = "none";
            authMethods[authMethods["local"] = 1] = "local";
            authMethods[authMethods["custom"] = 2] = "custom";
        })(Services.authMethods || (Services.authMethods = {}));
        var authMethods = Services.authMethods;
        /** project configuration. */
        var Project = (function () {
            function Project() {
                this.expertMode = Expertise.Expert;
                this.markers = {};
                /** List of search providers to use, e.g. bag, offline, bing */
                this.searchProviders = [];
            }
            // /** If true (default false), indicates that we should load an offline search result. */
            // useOfflineSearch: boolean = false;
            // /** If true (default false), indicates that we should enable an online search engine. */
            // useOnlineSearch: boolean = false;
            // /** If useOnlineSearch = true define the url of the online search engine. */
            // onlineSearchUrl: string;
            /**
             * Serialize the project to a JSON string.
             */
            Project.prototype.serialize = function () {
                return JSON.stringify(Project.serializeableData(this), function (key, value) {
                    // Skip serializing certain keys
                    switch (key) {
                        case 'timestamp':
                        //case 'values':
                        //case 'mcas':
                        case '$$hashKey':
                        case 'div':
                            return undefined;
                        default:
                            return value;
                    }
                }, 2);
            };
            Project.serializeFeatureType = function (ft) {
                return {
                    name: ft.name,
                    style: ft.style,
                    propertyTypeKeys: ft.propertyTypeKeys,
                    showAllProperties: ft.showAllProperties
                };
            };
            /**
             * Returns an object which contains all the data that must be serialized.
             */
            Project.serializeableData = function (project) {
                return {
                    id: project.id,
                    title: project.title,
                    description: project.description,
                    logo: project.logo,
                    otpServer: project.otpServer,
                    url: project.url,
                    isDynamic: project.isDynamic,
                    startPosition: project.startposition,
                    timeLine: project.timeLine,
                    opacity: project.opacity,
                    mcas: project.mcas,
                    profile: project.profile,
                    datasources: csComp.Helpers.serialize(project.datasources, Services.DataSource.serializeableData),
                    dashboards: csComp.Helpers.serialize(project.dashboards, Services.Dashboard.serializeableData),
                    viewBounds: project.viewBounds,
                    collapseAllLayers: project.collapseAllLayers,
                    userPrivileges: project.userPrivileges,
                    languages: project.languages,
                    modeSelection: project.exportModeSelectionEnabled,
                    expertMode: project.expertMode,
                    baselayers: project.baselayers,
                    featureTypes: project.featureTypes,
                    propertyTypeData: project.propertyTypeData,
                    groups: csComp.Helpers.serialize(project.groups, Services.ProjectGroup.serializeableData, true),
                    layerDirectory: project.layerDirectory,
                    eventTab: project.eventTab,
                    searchProviders: project.searchProviders
                };
            };
            Project.prototype.deserialize = function (input) {
                var res = jQuery.extend(new Project(), input);
                res.solution = input.solution;
                if (typeof input.exportModeSelectionEnabled === 'undefined')
                    res.exportModeSelectionEnabled = true;
                if (typeof input.profile === 'undefined')
                    res.profile = {};
                if (typeof res.profile.authenticationMethod === 'undefined')
                    res.profile.authenticationMethod = authMethods.local;
                if (!input.opacity) {
                    input.opacity = 100;
                }
                if (input.timeLine) {
                    res.timeLine = DateRange.deserialize(input.timeLine);
                } // <DateRange>jQuery.extend(new DateRange(), input.timeLine);
                if (input.dashboards) {
                    res.dashboards = [];
                    input.dashboards.forEach(function (d) {
                        res.dashboards.push(Services.Dashboard.deserialize(d, input.solution));
                    });
                }
                res.mcas = [];
                for (var index in input.mcas) {
                    var mca = new Mca.Models.Mca();
                    res.mcas.push(mca.deserialize(input.mcas[index]));
                }
                if (!res.propertyTypeData) {
                    res.propertyTypeData = {};
                }
                if (!res.mcas) {
                    res.mcas = [];
                }
                if (input.groups) {
                    res.groups = [];
                    input.groups.forEach(function (group) {
                        res.groups.push(Services.ProjectGroup.deserialize(group));
                    });
                }
                if (typeof res.id === 'undefined') {
                    res.id = res.title;
                }
                return res;
            };
            return Project;
        }());
        Services.Project = Project;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=project.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        /** Class containing references to feature & property types */
        var TypeResource = (function () {
            function TypeResource() {
            }
            /**
             * Serialize the project to a JSON string.
             */
            TypeResource.serialize = function (resource) {
                var data = {
                    featureTypes: {},
                    propertyTypeData: {},
                    legends: {}
                };
                for (var rt in resource.featureTypes) {
                    data.featureTypes[rt] = Services.Project.serializeFeatureType(resource.featureTypes[rt]);
                }
                for (var pt in resource.propertyTypeData) {
                    data.propertyTypeData[pt] = resource.propertyTypeData[pt];
                }
                for (var l in resource.legends) {
                    data.legends[l] = resource.legends[pt];
                }
                return JSON.stringify(data);
            };
            return TypeResource;
        }());
        Services.TypeResource = TypeResource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=typeresource.js.map
var ColorExt;
(function (ColorExt) {
    /** Color utility class */
    var Utils = (function () {
        function Utils() {
        }
        /**
         * HSV to RGB color conversion.
         *
         * HSV:
         * 		Hue (the actual color between 0 and 360 degrees),
         *   	Saturation between 0 (grey) and 100 (full color),
         *   	Value of Brightness between 0 (black) and 100 white.
         */
        Utils.hsv2rgb = function (h, s, v) {
            // adapted from http://schinckel.net/2012/01/10/hsv-to-rgb-in-javascript/
            var rgb, i, data = [];
            if (s === 0) {
                rgb = [v, v, v];
            }
            else {
                h = h / 60;
                i = Math.floor(h);
                data = [v * (1 - s), v * (1 - s * (h - i)), v * (1 - s * (1 - (h - i)))];
                switch (i) {
                    case 0:
                        rgb = [v, data[2], data[0]];
                        break;
                    case 1:
                        rgb = [data[1], v, data[0]];
                        break;
                    case 2:
                        rgb = [data[0], v, data[2]];
                        break;
                    case 3:
                        rgb = [data[0], data[1], v];
                        break;
                    case 4:
                        rgb = [data[2], data[0], v];
                        break;
                    default:
                        rgb = [v, data[0], data[1]];
                        break;
                }
            }
            return '#' + rgb.map(function (x) {
                return ("0" + Math.round(x * 255).toString(16)).slice(-2);
            }).join('');
        };
        Utils.toColor = function (val, min, max, primaryColorHue, secondaryColorHue) {
            var h = primaryColorHue + Math.floor(val / (max - min) * (secondaryColorHue - primaryColorHue));
            return Utils.hsv2rgb(h, 1, 1);
        };
        /**
         * Calculate the hue value from a hexadecimal RGB string. Return a value between 0 and 360 degrees
         * equation from: en.wikipedia.org/wiki/Hue#Computing_hue_from_RGB
         */
        Utils.rgbToHue = function (rgb) {
            if (!rgb)
                return;
            if (rgb[0] === '#')
                rgb = rgb.substr(1);
            if (rgb.length !== 6) {
                console.log("Wrong rgb format: " + rgb);
                return;
            }
            var r = parseInt(rgb.substring(0, 2), 16) / 255;
            var g = parseInt(rgb.substring(2, 4), 16) / 255;
            var b = parseInt(rgb.substring(4, 6), 16) / 255;
            var h = Math.atan2(Math.sqrt(3) * (g - b), 2 * (r - g - b));
            while (h < 0) {
                h += (2 * Math.PI);
            }
            ;
            while (h >= (2 * Math.PI)) {
                h -= (2 * Math.PI);
            }
            ;
            h = (h * 180 / Math.PI);
            return h;
        };
        /**
         * Convert an R, G and B combination to hexadecimal string (with preceding #)
         * @param  number[] rgb array
         * @return string  hex string
         */
        Utils.rgbToHex = function (rgb) {
            return '#' + rgb.map(function (x) {
                return ("0" + x.toString(16)).slice(-2);
            }).join('');
        };
        Utils.colorNameToHex = function (color) {
            var colors = { "aliceblue": "#f0f8ff", "antiquewhite": "#faebd7", "aqua": "#00ffff", "aquamarine": "#7fffd4", "azure": "#f0ffff", "beige": "#f5f5dc", "bisque": "#ffe4c4", "black": "#000000", "blanchedalmond": "#ffebcd", "blue": "#0000ff", "blueviolet": "#8a2be2", "brown": "#a52a2a", "burlywood": "#deb887", "cadetblue": "#5f9ea0", "chartreuse": "#7fff00", "chocolate": "#d2691e", "coral": "#ff7f50", "cornflowerblue": "#6495ed", "cornsilk": "#fff8dc", "crimson": "#dc143c", "cyan": "#00ffff", "darkblue": "#00008b", "darkcyan": "#008b8b", "darkgoldenrod": "#b8860b", "darkgray": "#a9a9a9", "darkgreen": "#006400", "darkkhaki": "#bdb76b", "darkmagenta": "#8b008b", "darkolivegreen": "#556b2f", "darkorange": "#ff8c00", "darkorchid": "#9932cc", "darkred": "#8b0000", "darksalmon": "#e9967a", "darkseagreen": "#8fbc8f", "darkslateblue": "#483d8b", "darkslategray": "#2f4f4f", "darkturquoise": "#00ced1", "darkviolet": "#9400d3", "deeppink": "#ff1493", "deepskyblue": "#00bfff", "dimgray": "#696969", "dodgerblue": "#1e90ff", "firebrick": "#b22222", "floralwhite": "#fffaf0", "forestgreen": "#228b22", "fuchsia": "#ff00ff", "gainsboro": "#dcdcdc", "ghostwhite": "#f8f8ff", "gold": "#ffd700", "goldenrod": "#daa520", "gray": "#808080", "green": "#008000", "greenyellow": "#adff2f", "honeydew": "#f0fff0", "hotpink": "#ff69b4", "indianred": "#cd5c5c", "indigo": "#4b0082", "ivory": "#fffff0", "khaki": "#f0e68c", "lavender": "#e6e6fa", "lavenderblush": "#fff0f5", "lawngreen": "#7cfc00", "lemonchiffon": "#fffacd", "lightblue": "#add8e6", "lightcoral": "#f08080", "lightcyan": "#e0ffff", "lightgoldenrodyellow": "#fafad2", "lightgrey": "#d3d3d3", "lightgreen": "#90ee90", "lightpink": "#ffb6c1", "lightsalmon": "#ffa07a", "lightseagreen": "#20b2aa", "lightskyblue": "#87cefa", "lightslategray": "#778899", "lightsteelblue": "#b0c4de", "lightyellow": "#ffffe0", "lime": "#00ff00", "limegreen": "#32cd32", "linen": "#faf0e6", "magenta": "#ff00ff", "maroon": "#800000", "mediumaquamarine": "#66cdaa", "mediumblue": "#0000cd", "mediumorchid": "#ba55d3", "mediumpurple": "#9370d8", "mediumseagreen": "#3cb371", "mediumslateblue": "#7b68ee", "mediumspringgreen": "#00fa9a", "mediumturquoise": "#48d1cc", "mediumvioletred": "#c71585", "midnightblue": "#191970", "mintcream": "#f5fffa", "mistyrose": "#ffe4e1", "moccasin": "#ffe4b5", "navajowhite": "#ffdead", "navy": "#000080", "oldlace": "#fdf5e6", "olive": "#808000", "olivedrab": "#6b8e23", "orange": "#ffa500", "orangered": "#ff4500", "orchid": "#da70d6", "palegoldenrod": "#eee8aa", "palegreen": "#98fb98", "paleturquoise": "#afeeee", "palevioletred": "#d87093", "papayawhip": "#ffefd5", "peachpuff": "#ffdab9", "peru": "#cd853f", "pink": "#ffc0cb", "plum": "#dda0dd", "powderblue": "#b0e0e6", "purple": "#800080", "red": "#ff0000", "rosybrown": "#bc8f8f", "royalblue": "#4169e1", "saddlebrown": "#8b4513", "salmon": "#fa8072", "sandybrown": "#f4a460", "seagreen": "#2e8b57", "seashell": "#fff5ee", "sienna": "#a0522d", "silver": "#c0c0c0", "skyblue": "#87ceeb", "slateblue": "#6a5acd", "slategray": "#708090", "snow": "#fffafa", "springgreen": "#00ff7f", "steelblue": "#4682b4", "tan": "#d2b48c", "teal": "#008080", "thistle": "#d8bfd8", "tomato": "#ff6347", "turquoise": "#40e0d0", "violet": "#ee82ee", "wheat": "#f5deb3", "white": "#ffffff", "whitesmoke": "#f5f5f5", "yellow": "#ffff00", "yellowgreen": "#9acd32" };
            if (typeof colors[color.toLowerCase()] != 'undefined' && colors.hasOwnProperty(color.toLowerCase())) {
                return colors[color.toLowerCase()];
            }
            else {
                return "#000000";
            }
        };
        return Utils;
    }());
    ColorExt.Utils = Utils;
})(ColorExt || (ColorExt = {}));
//# sourceMappingURL=ColorExt.js.map
var csComp;
(function (csComp) {
    var Helpers;
    (function (Helpers) {
        /**
         * Translated Jason Davies' JavaScript version to TypeScript in 2015.
         * Erik Vullings
         *
         * Copyright (c) 2010, Jason Davies.
         *
         * All rights reserved.  This code is based on Bradley White's Java version,
         * which is in turn based on Nicholas Yue's C++ version, which in turn is based
         * on Paul D. Bourke's original Fortran version.  See below for the respective
         * copyright notices.
         *
         * See http://paulbourke.net/papers/conrec for the original
         * paper by Paul D. Bourke.
         *
         * The vector conversion code is based on http://apptree.net/conrec.htm by
         * Graham Cox.
         *
         * Redistribution and use in source and binary forms, with or without
         * modification, are permitted provided that the following conditions are met:
         *     * Redistributions of source code must retain the above copyright
         *       notice, this list of conditions and the following disclaimer.
         *     * Redistributions in binary form must reproduce the above copyright
         *       notice, this list of conditions and the following disclaimer in the
         *       documentation and/or other materials provided with the distribution.
         *     * Neither the name of the <organization> nor the
         *       names of its contributors may be used to endorse or promote products
         *       derived from this software without specific prior written permission.
         *
         * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
         * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
         * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
         * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
         * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
         * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
         * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
         * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
         * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         */
        /*
         * Copyright (c) 1996-1997 Nicholas Yue
         *
         * This software is copyrighted by Nicholas Yue. This code is based on Paul D.
         * Bourke's CONREC.F routine.
         *
         * The authors hereby grant permission to use, copy, and distribute this
         * software and its documentation for any purpose, provided that existing
         * copyright notices are retained in all copies and that this notice is
         * included verbatim in any distributions. Additionally, the authors grant
         * permission to modify this software and its documentation for any purpose,
         * provided that such modifications are not distributed without the explicit
         * consent of the authors and that existing copyright notices are retained in
         * all copies. Some of the algorithms implemented by this software are
         * patented, observe all applicable patent law.
         *
         * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
         * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
         * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
         * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         *
         * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
         * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
         * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS
         * PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO
         * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
         * MODIFICATIONS.
         */
        var EPSILON = 1e-10;
        var ContourBuilder = (function () {
            function ContourBuilder(level) {
                this.level = level;
                this.count = 0;
                this.s = null;
            }
            ContourBuilder.prototype.addSegment = function (a, b) {
                var ss = this.s;
                var ma = null, mb = null;
                var prependA = false, prependB = false;
                while (ss) {
                    if (ma === null) {
                        // no match for a yet
                        if (this.pointsEqual(a, ss.head.p)) {
                            ma = ss;
                            prependA = true;
                        }
                        else if (this.pointsEqual(a, ss.tail.p)) {
                            ma = ss;
                        }
                    }
                    if (mb === null) {
                        // no match for b yet
                        if (this.pointsEqual(b, ss.head.p)) {
                            mb = ss;
                            prependB = true;
                        }
                        else if (this.pointsEqual(b, ss.tail.p)) {
                            mb = ss;
                        }
                    }
                    // if we matched both no need to continue searching
                    if (mb != null && ma != null) {
                        break;
                    }
                    else {
                        ss = ss.next;
                    }
                }
                // c is the case selector based on which of ma and/or mb are set
                var c = ((ma != null) ? 1 : 0) | ((mb != null) ? 2 : 0);
                switch (c) {
                    case 0:
                        var aa = { p: a, prev: null };
                        var bb = { p: b, next: null };
                        aa.next = bb;
                        bb.prev = aa;
                        // create sequence element and push onto head of main list. The order
                        // of items in this list is unimportant
                        ma = { head: aa, tail: bb, next: this.s, prev: null, closed: false };
                        if (this.s) {
                            this.s.prev = ma;
                        }
                        this.s = ma;
                        ++this.count; // not essential - tracks number of unmerged sequences
                        break;
                    case 1:
                        var pp = { p: b };
                        if (prependA) {
                            pp.next = ma.head;
                            pp.prev = null;
                            ma.head.prev = pp;
                            ma.head = pp;
                        }
                        else {
                            pp.next = null;
                            pp.prev = ma.tail;
                            ma.tail.next = pp;
                            ma.tail = pp;
                        }
                        break;
                    case 2:
                        var pp = { p: a };
                        if (prependB) {
                            pp.next = mb.head;
                            pp.prev = null;
                            mb.head.prev = pp;
                            mb.head = pp;
                        }
                        else {
                            pp.next = null;
                            pp.prev = mb.tail;
                            mb.tail.next = pp;
                            mb.tail = pp;
                        }
                        break;
                    case 3:
                        // if the sequences are the same, do nothing, as we are simply closing this path (could set a flag)
                        if (ma === mb) {
                            var pp = { p: ma.tail.p, next: ma.head, prev: null };
                            ma.head.prev = pp;
                            ma.head = pp;
                            ma.closed = true;
                            break;
                        }
                        // there are 4 ways the sequence pair can be joined. The current setting of prependA and
                        // prependB will tell us which type of join is needed. For head/head and tail/tail joins
                        // one sequence needs to be reversed
                        switch ((prependA ? 1 : 0) | (prependB ? 2 : 0)) {
                            case 0:
                                // reverse ma and append to mb
                                this.reverseList(ma);
                            // fall through to head/tail case
                            case 1:
                                // ma is appended to mb and ma discarded
                                mb.tail.next = ma.head;
                                ma.head.prev = mb.tail;
                                mb.tail = ma.tail;
                                //discard ma sequence record
                                this.remove_seq(ma);
                                break;
                            case 3:
                                // reverse ma and append mb to it
                                this.reverseList(ma);
                            // fall through to tail/head case
                            case 2:
                                // mb is appended to ma and mb is discarded
                                ma.tail.next = mb.head;
                                mb.head.prev = ma.tail;
                                ma.tail = mb.tail;
                                //discard mb sequence record
                                this.remove_seq(mb);
                                break;
                        }
                }
            };
            ContourBuilder.prototype.remove_seq = function (list) {
                // if list is the first item, static ptr s is updated
                if (list.prev) {
                    list.prev.next = list.next;
                }
                else {
                    this.s = list.next;
                }
                if (list.next) {
                    list.next.prev = list.prev;
                }
                --this.count;
            };
            /**
             * Are two points equal.
             * @param  {IPoint} a Point 1
             * @param  {IPoint} b Point 2
             * @return {boolean}  [True if equal, false otherwise]
             */
            ContourBuilder.prototype.pointsEqual = function (a, b) {
                var dx = a.x - b.x, dy = a.y - b.y;
                return dx * dx + dy * dy < EPSILON;
            };
            ContourBuilder.prototype.reverseList = function (list) {
                var pp = list.head;
                while (pp) {
                    // swap prev/next pointers
                    var temp = pp.next;
                    pp.next = pp.prev;
                    pp.prev = temp;
                    // continue through the list
                    pp = temp;
                }
                // swap head/tail pointers
                var temp = list.head;
                list.head = list.tail;
                list.tail = temp;
            };
            return ContourBuilder;
        }());
        /**
          * Implements CONREC.
          *
          * @param {function} drawContour function for drawing contour.  Defaults to a
          *                               custom "contour builder", which populates the
          *                               contourList property.
          */
        var Conrec = (function () {
            /**
             * Create a new Conrec class, optionally specifying the function to use for drawing the contour line.
             * @param  {number} drawContour [description]
             * @return {[type]}             [description]
             */
            function Conrec(drawContour) {
                this.h = new Array(5);
                this.sh = new Array(5);
                this.xh = new Array(5);
                this.yh = new Array(5);
                if (drawContour)
                    this.drawContour = drawContour;
            }
            /**
             * contour is a contouring subroutine for rectangularily spaced data
             *
             * It emits calls to a line drawing subroutine supplied by the user which
             * draws a contour map corresponding to real*4data on a randomly spaced
             * rectangular grid. The coordinates emitted are in the same units given in
             * the x() and y() arrays.
             *
             * Any number of contour levels may be specified but they must be in order of
             * increasing value.
             *
             *
             * @param {number[][]} d - matrix of data to contour
             * @param {number} ilb,iub,jlb,jub - index lower and upper bounds of data matrix,
             *                                 	 i in rows/latitude direction, j in columns/longitude direction
             *
             *             The following two, one dimensional arrays (x and y) contain
             *             the horizontal and vertical coordinates of each sample points.
             * @param {number[]} x  - data matrix column coordinates, e.g. latitude coordinates
             * @param {number[]} y  - data matrix row coordinates, e.g. longitude coordinates
             * @param {number} nc   - number of contour levels
             * @param {number[]} z  - contour levels in increasing order.
             * @param {number[]} noDataValue  - when one of the corners of the grid cell contains a noDataValue, that cell is skipped.
             */
            Conrec.prototype.contour = function (d, ilb, iub, jlb, jub, x, y, nc, z, noDataValue) {
                var h = this.h, sh = this.sh, xh = this.xh, yh = this.yh;
                var drawContour = this.drawContour;
                this.contours = {};
                /** private */
                var xsect = function (p1, p2) {
                    return (h[p2] * xh[p1] - h[p1] * xh[p2]) / (h[p2] - h[p1]);
                };
                var ysect = function (p1, p2) {
                    return (h[p2] * yh[p1] - h[p1] * yh[p2]) / (h[p2] - h[p1]);
                };
                var m1, m2, m3;
                var case_value;
                var dmin, dmax;
                var x1 = 0.0;
                var x2 = 0.0;
                var y1 = 0.0;
                var y2 = 0.0;
                // The indexing of im and jm should be noted as it has to start from zero
                // unlike the fortran counter part
                var im = [0, 1, 1, 0];
                var jm = [0, 0, 1, 1];
                // Note that castab is arranged differently from the FORTRAN code because
                // Fortran and C/C++ arrays are transposed of each other, in this case
                // it is more tricky as castab is in 3 dimensions
                var castab = [
                    [
                        [0, 0, 8], [0, 2, 5], [7, 6, 9]
                    ],
                    [
                        [0, 3, 4], [1, 3, 1], [4, 3, 0]
                    ],
                    [
                        [9, 6, 7], [5, 2, 0], [8, 0, 0]
                    ]
                ];
                for (var j = (jub - 1); j >= jlb; j--) {
                    for (var i = ilb; i < iub; i++) {
                        if (d[i][j] === noDataValue || d[i + 1][j] === noDataValue || d[i][j + 1] === noDataValue || d[i + 1][j + 1] === noDataValue)
                            return;
                        var temp1, temp2;
                        temp1 = Math.min(d[i][j], d[i][j + 1]);
                        temp2 = Math.min(d[i + 1][j], d[i + 1][j + 1]);
                        dmin = Math.min(temp1, temp2);
                        temp1 = Math.max(d[i][j], d[i][j + 1]);
                        temp2 = Math.max(d[i + 1][j], d[i + 1][j + 1]);
                        dmax = Math.max(temp1, temp2);
                        if (dmax < z[0] && dmin > z[nc - 1])
                            continue;
                        for (var k = 0; k < nc; k++) {
                            if (z[k] >= dmin && z[k] <= dmax) {
                                for (var m = 4; m >= 0; m--) {
                                    if (m > 0) {
                                        // The indexing of im and jm should be noted as it has to
                                        // start from zero
                                        h[m] = d[i + im[m - 1]][j + jm[m - 1]] - z[k];
                                        xh[m] = x[i + im[m - 1]];
                                        yh[m] = y[j + jm[m - 1]];
                                    }
                                    else {
                                        h[0] = 0.25 * (h[1] + h[2] + h[3] + h[4]);
                                        xh[0] = 0.5 * (x[i] + x[i + 1]);
                                        yh[0] = 0.5 * (y[j] + y[j + 1]);
                                    }
                                    if (h[m] > EPSILON) {
                                        sh[m] = 1;
                                    }
                                    else if (h[m] < -EPSILON) {
                                        sh[m] = -1;
                                    }
                                    else
                                        sh[m] = 0;
                                }
                                //
                                // Note: at this stage the relative heights of the corners and the
                                // centre are in the h array, and the corresponding coordinates are
                                // in the xh and yh arrays. The centre of the box is indexed by 0
                                // and the 4 corners by 1 to 4 as shown below.
                                // Each triangle is then indexed by the parameter m, and the 3
                                // vertices of each triangle are indexed by parameters m1,m2,and
                                // m3.
                                // It is assumed that the centre of the box is always vertex 2
                                // though this isimportant only when all 3 vertices lie exactly on
                                // the same contour level, in which case only the side of the box
                                // is drawn.
                                //
                                //
                                //      vertex 4 +-------------------+ vertex 3
                                //               | \               / |
                                //               |   \    m-3    /   |
                                //               |     \       /     |
                                //               |       \   /       |
                                //               |  m=2    X   m=2   |       the centre is vertex 0
                                //               |       /   \       |
                                //               |     /       \     |
                                //               |   /    m=1    \   |
                                //               | /               \ |
                                //      vertex 1 +-------------------+ vertex 2
                                //
                                //
                                //
                                //               Scan each triangle in the box
                                //
                                for (m = 1; m <= 4; m++) {
                                    m1 = m;
                                    m2 = 0;
                                    if (m != 4) {
                                        m3 = m + 1;
                                    }
                                    else {
                                        m3 = 1;
                                    }
                                    case_value = castab[sh[m1] + 1][sh[m2] + 1][sh[m3] + 1];
                                    if (case_value != 0) {
                                        switch (case_value) {
                                            case 1:
                                                x1 = xh[m1];
                                                y1 = yh[m1];
                                                x2 = xh[m2];
                                                y2 = yh[m2];
                                                break;
                                            case 2:
                                                x1 = xh[m2];
                                                y1 = yh[m2];
                                                x2 = xh[m3];
                                                y2 = yh[m3];
                                                break;
                                            case 3:
                                                x1 = xh[m3];
                                                y1 = yh[m3];
                                                x2 = xh[m1];
                                                y2 = yh[m1];
                                                break;
                                            case 4:
                                                x1 = xh[m1];
                                                y1 = yh[m1];
                                                x2 = xsect(m2, m3);
                                                y2 = ysect(m2, m3);
                                                break;
                                            case 5:
                                                x1 = xh[m2];
                                                y1 = yh[m2];
                                                x2 = xsect(m3, m1);
                                                y2 = ysect(m3, m1);
                                                break;
                                            case 6:
                                                x1 = xh[m3];
                                                y1 = yh[m3];
                                                x2 = xsect(m1, m2);
                                                y2 = ysect(m1, m2);
                                                break;
                                            case 7:
                                                x1 = xsect(m1, m2);
                                                y1 = ysect(m1, m2);
                                                x2 = xsect(m2, m3);
                                                y2 = ysect(m2, m3);
                                                break;
                                            case 8:
                                                x1 = xsect(m2, m3);
                                                y1 = ysect(m2, m3);
                                                x2 = xsect(m3, m1);
                                                y2 = ysect(m3, m1);
                                                break;
                                            case 9:
                                                x1 = xsect(m3, m1);
                                                y1 = ysect(m3, m1);
                                                x2 = xsect(m1, m2);
                                                y2 = ysect(m1, m2);
                                                break;
                                            default:
                                                break;
                                        }
                                        // Put your processing code here and comment out the printf
                                        //printf("%f %f %f %f %f\n",x1,y1,x2,y2,z[k]);
                                        this.drawContour(x1, y1, x2, y2, z[k], k);
                                    } // if case_value
                                } // for m
                            } // for z
                        } // for k
                    } // for i
                } // for j
            };
            /**
             * drawContour - interface for implementing the user supplied method to
             * render the countours.
             *
             * Draws a line between the start and end coordinates.
             *
             * @param startX    - start coordinate for X
             * @param startY    - start coordinate for Y
             * @param endX      - end coordinate for X
             * @param endY      - end coordinate for Y
             * @param contourLevel - Contour level for line.
             */
            Conrec.prototype.drawContour = function (startX, startY, endX, endY, contourLevel, k) {
                var cb = this.contours[k];
                if (!cb) {
                    cb = this.contours[k] = new ContourBuilder(contourLevel);
                }
                cb.addSegment({ x: startX, y: startY }, { x: endX, y: endY });
            };
            Object.defineProperty(Conrec.prototype, "contourList", {
                get: function () {
                    var l = [];
                    var a = this.contours;
                    for (var k in a) {
                        var s = a[k].s;
                        var level = a[k].level;
                        while (s) {
                            var h = s.head;
                            var l2 = [];
                            l2.level = level;
                            l2.k = k;
                            while (h && h.p) {
                                l2.push(h.p);
                                h = h.next;
                            }
                            l.push(l2);
                            s = s.next;
                        }
                    }
                    l.sort(function (a, b) { return a.k - b.k; });
                    return l;
                },
                enumerable: true,
                configurable: true
            });
            return Conrec;
        }());
        Helpers.Conrec = Conrec;
    })(Helpers = csComp.Helpers || (csComp.Helpers = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=conrec.js.map
Date.prototype.getJulian = function () {
    /* Calculate the present UTC Julian Date. Function is valid after
     * the beginning of the UNIX epoch 1970-01-01 and ignores leap
     * seconds. */
    return (this / 86400000) + 2440587.5;
};
Date.prototype.getGMST = function () {
    /* Calculate Greenwich Mean Sidereal Time according to
       http://aa.usno.navy.mil/faq/docs/GAST.php */
    var julianDay = this.getJulian();
    var d = julianDay - 2451545.0;
    // Low precision equation is good enough for our purposes.
    return (18.697374558 + 24.06570982441908 * d) % 24;
};
Date.prototype.yyyymmdd = function () {
    var yyyy = this.getFullYear().toString();
    var mm = (this.getMonth() + 1).toString(); // getMonth() is zero-based
    var dd = this.getDate().toString();
    return yyyy + (mm[1] ? mm : "0" + mm[0]) + (dd[1] ? dd : "0" + dd[0]); // padding
};
//# sourceMappingURL=DateExt.js.map
var csComp;
(function (csComp) {
    var Helpers;
    (function (Helpers) {
        var Dictionary = (function () {
            function Dictionary() {
                this.theKeys = [];
                this.theValues = [];
            }
            Dictionary.prototype.initialize = function (init) {
                for (var x = 0; x < init.length; x++) {
                    this[init[x].key] = init[x].value;
                    this.theKeys.push(init[x].key);
                    this.theValues.push(init[x].value);
                }
            };
            Dictionary.prototype.add = function (key, value) {
                this[key] = value;
                this.theKeys.push(key);
                this.theValues.push(value);
            };
            Dictionary.prototype.remove = function (key) {
                var index = this.theKeys.indexOf(key, 0);
                this.theKeys.splice(index, 1);
                this.theValues.splice(index, 1);
                delete this[key];
            };
            Dictionary.prototype.clear = function () {
                for (var i = this.theKeys.length; i >= 0; i--) {
                    var key = this.theKeys[i];
                    this.remove(key);
                }
            };
            Dictionary.prototype.count = function () {
                return this.theKeys.length;
            };
            Dictionary.prototype.keys = function () {
                return this.theKeys;
            };
            Dictionary.prototype.values = function () {
                return this.theValues;
            };
            Dictionary.prototype.containsKey = function (key) {
                return (typeof this[key] !== "undefined");
            };
            Dictionary.prototype.toLookup = function () {
                return this;
            };
            return Dictionary;
        }());
        Helpers.Dictionary = Dictionary;
    })(Helpers = csComp.Helpers || (csComp.Helpers = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=Dictionary.js.map
var esriJsonConverter;
(function (esriJsonConverter_1) {
    var esriJsonConverter = (function () {
        function esriJsonConverter() {
            this.esriCon = {};
            /************************************************
             * GeoJSON to ESRI Rest Converter
             ************************************************/
            this.gCon = {};
        }
        /*determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring
          or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-
          points-are-in-clockwise-order*/
        esriJsonConverter.prototype.ringIsClockwise = function (ringToTest) {
            var total = 0, i = 0, rLength = ringToTest.length, pt1 = ringToTest[i], pt2;
            for (i; i < rLength - 1; i++) {
                pt2 = ringToTest[i + 1];
                total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);
                pt1 = pt2;
            }
            return (total >= 0);
        };
        /*Converts ESRI Rest Geometry to GeoJSON Geometry
          Input is ESRI Rest Geometry Object*/
        esriJsonConverter.prototype.esriGeometryToGcGeometry = function (esriGeom) {
            var gcGeom, i, g, coordinates, geomType, geomParts, polyArray, ringArray, ring;
            //check for x, points, paths, or rings to determine geometry type.
            if (esriGeom) {
                //gcGeom = {};
                if (((esriGeom.x && esriGeom.x !== "NaN") || esriGeom.x === 0) &&
                    ((esriGeom.y && esriGeom.y !== "NaN") || esriGeom.y === 0)) {
                    geomType = "Point";
                    coordinates = [esriGeom.x, esriGeom.y];
                }
                else if (esriGeom.points && esriGeom.points.length) {
                    geomType = "MultiPoint";
                    coordinates = esriGeom.points;
                }
                else if (esriGeom.paths && esriGeom.paths.length) {
                    geomParts = esriGeom.paths;
                    if (geomParts.length === 1) {
                        geomType = "LineString";
                        coordinates = geomParts[0];
                    }
                    else {
                        geomType = "MultiLineString";
                        coordinates = geomParts;
                    }
                }
                else if (esriGeom.rings && esriGeom.rings.length) {
                    //array to hold the individual polygons. A polygon is an outer ring with one or more inner rings
                    //the conversion logic assumes that the Esri json is in the format of an outer ring (clockwise)
                    //followed by inner rings (counter-clockwise) with a clockwise ring signalling the start of a new polygon
                    polyArray = [];
                    geomParts = esriGeom.rings;
                    for (i = 0; i < geomParts.length; i++) {
                        ring = geomParts[i];
                        if (this.ringIsClockwise(ring)) {
                            //outer ring so new polygon. Add to poly array
                            polyArray.push([ring]);
                        }
                        else if (polyArray.length > 0) {
                            //inner ring. Add as part of last polygon in poly array
                            polyArray[polyArray.length - 1].push(ring);
                        }
                    }
                    if (polyArray.length > 1) {
                        //MultiPolygon. Leave coordinates wrapped in outer array
                        coordinates = polyArray;
                        geomType = "MultiPolygon";
                    }
                    else {
                        //Polygon. Remove outer array wrapper.
                        coordinates = polyArray.pop();
                        geomType = "Polygon";
                    }
                }
                gcGeom = (coordinates && geomType) ? { type: geomType, coordinates: coordinates } : null;
                return gcGeom;
            }
            return gcGeom;
        };
        /*
         * Converts GeoJSON feature to ESRI REST Feature.
         * Input parameter is an ESRI Rest Feature object
         */
        esriJsonConverter.prototype.esriFeatureToGcFeature = function (esriFeature) {
            var gcFeat = null, prop, gcProps, i, p;
            if (esriFeature) {
                gcFeat = {
                    type: "Feature"
                };
                if (esriFeature.geometry) {
                    gcFeat.geometry = this.esriGeometryToGcGeometry(esriFeature.geometry);
                }
                if (esriFeature.attributes) {
                    gcProps = {};
                    p = esriFeature.attributes;
                    for (prop in esriFeature.attributes) {
                        gcProps[prop] = esriFeature.attributes[prop];
                    }
                    gcFeat.properties = gcProps;
                }
            }
            return gcFeat;
        };
        /*Converts ESRI Rest Featureset, Feature, or Geometry
          to GeoJSON FeatureCollection, Feature, or Geometry */
        esriJsonConverter.prototype.toGeoJson = function (esriObject) {
            var outObj, i, esriFeats, gcFeat;
            if (esriObject) {
                if (esriObject.features) {
                    outObj = {
                        type: "FeatureCollection",
                        features: []
                    };
                    esriFeats = esriObject.features;
                    for (i = 0; i < esriFeats.length; i++) {
                        gcFeat = this.esriFeatureToGcFeature(esriFeats[i]);
                        if (gcFeat) {
                            outObj.features.push(gcFeat);
                        }
                    }
                }
                else if (esriObject.geometry) {
                    outObj = this.esriFeatureToGcFeature(esriObject);
                }
                else {
                    outObj = this.esriGeometryToGcGeometry(esriObject);
                }
            }
            return outObj;
        };
        ;
        /*compares a GeoJSON geometry type and ESRI geometry type to see if they can be safely
          put together in a single ESRI feature. ESRI features must only have one
          geometry type, point, line, polygon*/
        esriJsonConverter.prototype.isCompatible = function (esriGeomType, gcGeomType) {
            var compatible = false;
            if ((esriGeomType === "esriGeometryPoint" || esriGeomType === "esriGeometryMultipoint") && (gcGeomType === "Point" || gcGeomType === "MultiPoint")) {
                compatible = true;
            }
            else if (esriGeomType === "esriGeometryPolyline" && (gcGeomType === "LineString" || gcGeomType === "MultiLineString")) {
                compatible = true;
            }
            else if (esriGeomType === "esriGeometryPolygon" && (gcGeomType === "Polygon" || gcGeomType === "MultiPolygon")) {
                compatible = true;
            }
            return compatible;
        };
        /*Take a GeoJSON geometry type and make an object that has information about
          what the ESRI geometry should hold. Includes the ESRI geometry type and the name
          of the member that holds coordinate information*/
        esriJsonConverter.prototype.gcGeomTypeToEsriGeomInfo = function (gcType) {
            var esriType, geomHolderId;
            if (gcType === "Point") {
                esriType = "esriGeometryPoint";
            }
            else if (gcType === "MultiPoint") {
                esriType = "esriGeometryMultipoint";
                geomHolderId = "points";
            }
            else if (gcType === "LineString" || gcType === "MultiLineString") {
                esriType = "esriGeometryPolyline";
                geomHolderId = "paths";
            }
            else if (gcType === "Polygon" || gcType === "MultiPolygon") {
                esriType = "esriGeometryPolygon";
                geomHolderId = "rings";
            }
            return {
                type: esriType,
                geomHolder: geomHolderId
            };
        };
        /*Convert GeoJSON polygon coordinates to ESRI polygon coordinates.
          GeoJSON rings are listed starting with a singular outer ring. ESRI
          rings can be listed in any order, but unlike GeoJSON, the ordering of
          vertices determines whether it's an outer or inner ring. Clockwise
          vertices indicate outer ring and counter-clockwise vertices indicate
          inner ring */
        esriJsonConverter.prototype.gcPolygonCoordinatesToEsriPolygonCoordinates = function (gcCoords) {
            var i, len, esriCoords = [], ring;
            for (i = 0, len = gcCoords.length; i < len; i++) {
                ring = gcCoords[i];
                // Exclusive OR.
                if ((i == 0) != this.ringIsClockwise(ring)) {
                    ring = ring.reverse();
                }
                esriCoords.push(ring);
            }
            return esriCoords;
        };
        /*Wraps GeoJSON coordinates in an array if necessary so code can iterate
          through array of points, rings, or lines and add them to an ESRI geometry
          Input is a GeoJSON geometry object. A GeoJSON GeometryCollection is not a
          valid input */
        esriJsonConverter.prototype.gcCoordinatesToEsriCoordinates = function (gcGeom) {
            var i, len, esriCoords;
            if (gcGeom.type === "MultiPoint" || gcGeom.type === "MultiLineString") {
                esriCoords = gcGeom.coordinates;
            }
            else if (gcGeom.type === "Point" || gcGeom.type === "LineString") {
                esriCoords = [gcGeom.coordinates];
            }
            else if (gcGeom.type === "Polygon") {
                esriCoords = this.gcPolygonCoordinatesToEsriPolygonCoordinates(gcGeom.coordinates);
            }
            else if (gcGeom.type === "MultiPolygon") {
                esriCoords = [];
                for (i = 0, len = gcGeom.coordinates.length; i < len; i++) {
                    esriCoords.push(this.gcPolygonCoordinatesToEsriPolygonCoordinates(gcGeom.coordinates[i])[0]);
                }
            }
            return esriCoords;
        };
        /*Converts GeoJSON geometry to ESRI geometry. The ESRI geometry is
          only allowed to contain one type of geometry, so if the GeoJSON
          geometry is a GeometryCollection, then only geometries compatible
          with the first geometry type in the collection are added to the ESRI geometry

          Input parameter is a GeoJSON geometry object.*/
        esriJsonConverter.prototype.gcGeometryToEsriGeometry = function (gcGeom) {
            var esriGeometry, esriGeomInfo, gcGeometriesToConvert, i, g, coords;
            //if geometry collection, get info about first geometry in collection
            if (gcGeom.type === "GeometryCollection") {
                gcGeometriesToConvert = [gcGeom.geometries.shift()];
                esriGeomInfo = this.gcGeomTypeToEsriGeomInfo(gcGeometriesToConvert[0].type);
                //loop through collection and only add compatible geometries to the array
                //of geometries that will be converted
                for (i = 0; i < gcGeom.geometries.length; i++) {
                    if (this.isCompatible(esriGeomInfo.type, gcGeom.geometries[i].type)) {
                        gcGeometriesToConvert.push(gcGeom.geometries[i]);
                    }
                }
            }
            else {
                esriGeomInfo = this.gcGeomTypeToEsriGeomInfo(gcGeom.type);
                gcGeometriesToConvert = [gcGeom];
            }
            //if a collection contained multiple points, change the ESRI geometry
            //type to MultiPoint
            if (esriGeomInfo.type === "esriGeometryPoint" && gcGeometriesToConvert.length > 1) {
                esriGeomInfo = this.gcGeomTypeToEsriGeomInfo("MultiPoint");
            }
            //make new empty ESRI geometry object
            esriGeometry = {
                //type: esriGeomInfo.type,
                spatialReference: {
                    wkid: 4326
                }
            };
            //perform conversion
            if (esriGeomInfo.type === "esriGeometryPoint") {
                if (gcGeometriesToConvert[0].coordinates.length === 0) {
                    esriGeometry.x = null;
                    esriGeometry.y = null;
                }
                else {
                    esriGeometry.x = gcGeometriesToConvert[0].coordinates[0];
                    esriGeometry.y = gcGeometriesToConvert[0].coordinates[1];
                }
            }
            else {
                esriGeometry[esriGeomInfo.geomHolder] = [];
                for (i = 0; i < gcGeometriesToConvert.length; i++) {
                    coords = this.gcCoordinatesToEsriCoordinates(gcGeometriesToConvert[i]);
                    for (g = 0; g < coords.length; g++) {
                        esriGeometry[esriGeomInfo.geomHolder].push(coords[g]);
                    }
                }
            }
            return esriGeometry;
        };
        /*Converts GeoJSON feature to ESRI REST Feature.
          Input parameter is a GeoJSON Feature object*/
        esriJsonConverter.prototype.gcFeatureToEsriFeature = function (gcFeature) {
            var esriFeat, prop, esriAttribs;
            if (gcFeature) {
                esriFeat = {};
                if (gcFeature.geometry) {
                    esriFeat.geometry = this.gcGeometryToEsriGeometry(gcFeature.geometry);
                }
                if (gcFeature.properties) {
                    esriAttribs = {};
                    for (prop in gcFeature.properties) {
                        esriAttribs[prop] = gcFeature.properties[prop];
                    }
                    esriFeat.attributes = esriAttribs;
                }
            }
            return esriFeat;
        };
        /*Converts GeoJSON FeatureCollection, Feature, or Geometry
          to ESRI Rest Featureset, Feature, or Geometry*/
        esriJsonConverter.prototype.toEsri = function (geoJsonObject) {
            var outObj, i, gcFeats, esriFeat;
            if (geoJsonObject) {
                if (geoJsonObject.type === "FeatureCollection") {
                    outObj = {
                        features: []
                    };
                    gcFeats = geoJsonObject.features;
                    for (i = 0; i < gcFeats.length; i++) {
                        esriFeat = this.gcFeatureToEsriFeature(gcFeats[i]);
                        if (esriFeat) {
                            outObj.features.push(esriFeat);
                        }
                    }
                }
                else if (geoJsonObject.type === "Feature") {
                    outObj = this.gcFeatureToEsriFeature(geoJsonObject);
                }
                else {
                    outObj = this.gcGeometryToEsriGeometry(geoJsonObject);
                }
            }
            return outObj;
        };
        ;
        return esriJsonConverter;
    }());
    esriJsonConverter_1.esriJsonConverter = esriJsonConverter;
})(esriJsonConverter || (esriJsonConverter = {}));
//# sourceMappingURL=esriJsonConverter.js.map
var csComp;
(function (csComp) {
    var Helpers;
    (function (Helpers) {
        /**
        * A set of static geo tools
        * Source: http://www.csgnetwork.com/degreelenllavcalc.html
        */
        var GeoExtensions = (function () {
            function GeoExtensions() {
            }
            GeoExtensions.getFeatureBounds = function (feature) {
                if (!feature || !feature.geometry)
                    return [new L.LatLng(360, 180)]; // Return illegal coordinate.
                var geoType = feature.geometry.type || 'Point';
                switch (geoType) {
                    case 'Point':
                        return [new L.LatLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0])];
                    default:
                        var bounds = d3.geo.bounds(feature);
                        return new L.LatLngBounds([bounds[0][1], bounds[0][0]], [bounds[1][1], bounds[1][0]]);
                }
            };
            GeoExtensions.getBoundingBox = function (data) {
                var bounds = {}, coords, point, latitude, longitude;
                // We want to use the “features” key of the FeatureCollection (see above)
                data = data.features;
                // Loop through each “feature”
                for (var i = 0; i < data.length; i++) {
                    // get bound
                    if (!data[i].hasOwnProperty('geometry'))
                        continue;
                    var b = d3.geo.bounds(data[i]);
                    // Update the bounds recursively by comparing the current
                    // xMin/xMax and yMin/yMax with the coordinate
                    // we're currently checking
                    bounds.xMin = bounds.xMin < b[0][0] ? bounds.xMin : b[0][0];
                    bounds.xMax = bounds.xMax > b[1][0] ? bounds.xMax : b[1][0];
                    bounds.yMin = bounds.yMin < b[0][1] ? bounds.yMin : b[0][1];
                    bounds.yMax = bounds.yMax > b[1][1] ? bounds.yMax : b[1][1];
                }
                bounds.southWest = [bounds.yMin, bounds.xMin];
                bounds.northEast = [bounds.yMax, bounds.xMax];
                // Returns an object that contains the bounds of this GeoJSON
                // data. The keys of this object describe a box formed by the
                // northwest (xMin, yMin) and southeast (xMax, yMax) coordinates.
                return bounds;
            };
            /**
            * Convert topojson data to geojson data.
            */
            GeoExtensions.convertTopoToGeoJson = function (data) {
                // Convert topojson to geojson format
                var o = typeof data === 'string'
                    ? JSON.parse(data)
                    : data;
                var newData = {};
                newData.featureTypes = data.featureTypes;
                newData.features = [];
                for (var i in o.objects) {
                    var ft = topojson.feature(o, o.objects[i]);
                    if (ft.features) {
                        // ft contains multiple features
                        ft.features.forEach(function (f) { return newData.features.push(f); });
                    }
                    else {
                        newData.features.push(ft);
                    }
                }
                return newData;
            };
            GeoExtensions.deg2rad = function (degree) {
                return (degree * GeoExtensions.Rad2Deg);
            };
            GeoExtensions.rad2deg = function (rad) {
                return (rad / GeoExtensions.Rad2Deg);
            };
            /** Get the approximate centroid of a polygon by averaging the coordinates of its vertices. */
            GeoExtensions.getCentroid = function (arr) {
                if (!arr || arr.length === 0)
                    return { type: 'Point', coordinates: [0, 0] };
                if (arr[0] instanceof Array) {
                    if (arr[0][0] instanceof Array) {
                        arr = arr[0][0];
                    }
                    else {
                        arr = arr[0];
                    }
                }
                // http://stackoverflow.com/questions/22796520/finding-the-center-of-leaflet-polygon
                var centroid = arr.reduce(function (x, y) {
                    return [x[0] + y[0] / arr.length, x[1] + y[1] / arr.length];
                }, [0, 0]);
                return { type: 'Point', coordinates: centroid };
            };
            /**
             * Convert an array of RD (Rijksdriehoek) features to WGS84.
             * @param  {IFeature[]} rd [Array of features in RD]
             * @return {void} The function changes the passed parameter, returns nothing.  [void]
             * Source: http://home.solcon.nl/pvanmanen/Download/Transformatieformules.pdf, http://www.roelvanlisdonk.nl/?p=2950
             */
            GeoExtensions.convertRDFeaturesToWGS84 = function (rd) {
                if (!rd || rd.length <= 0) {
                    return;
                }
                rd.forEach(function (f) {
                    switch (f.geometry.type.toLowerCase()) {
                        case 'point':
                            GeoExtensions.convertGeoJsonRDToWGS84(f.geometry.coordinates);
                            break;
                        case 'linestring':
                        case 'polygon':
                            f.geometry.coordinates.forEach(function (line) {
                                line.forEach(function (segment) {
                                    GeoExtensions.convertGeoJsonRDToWGS84(segment);
                                });
                            });
                            break;
                        case 'multipolygon':
                            f.geometry.coordinates.forEach(function (poly) {
                                poly.forEach(function (line) {
                                    line.forEach(function (segment) {
                                        GeoExtensions.convertGeoJsonRDToWGS84(segment);
                                    });
                                });
                            });
                            break;
                    }
                });
            };
            GeoExtensions.convertGeoJsonRDToWGS84 = function (coord) {
                var latlon = GeoExtensions.convertRDToWGS84(coord[0], coord[1]);
                coord[0] = latlon.longitude;
                coord[1] = latlon.latitude;
            };
            /**
             * Convert RD (Rijksdriehoek) coordinates to WGS84.
             * @param  {number} x [RD X coordinate]
             * @param  {number} y [RD Y coordinate]
             * @return {[type]}   [object with latitude and longitude coordinate in WGS84]
             * Source: http://home.solcon.nl/pvanmanen/Download/Transformatieformules.pdf, http://www.roelvanlisdonk.nl/?p=2950
             */
            GeoExtensions.convertRDToWGS84 = function (x, y) {
                var x0 = 155000.000, y0 = 463000.000, f0 = 52.156160556, l0 = 5.387638889, a01 = 3236.0331637, b10 = 5261.3028966, a20 = -32.5915821, b11 = 105.9780241, a02 = -0.2472814, b12 = 2.4576469, a21 = -0.8501341, b30 = -0.8192156, a03 = -0.0655238, b31 = -0.0560092, a22 = -0.0171137, b13 = 0.0560089, a40 = 0.0052771, b32 = -0.0025614, a23 = -0.0003859, b14 = 0.0012770, a41 = 0.0003314, b50 = 0.0002574, a04 = 0.0000371, b33 = -0.0000973, a42 = 0.0000143, b51 = 0.0000293, a24 = -0.0000090, b15 = 0.0000291;
                var dx = (x - x0) * Math.pow(10, -5);
                var dy = (y - y0) * Math.pow(10, -5);
                var df = a01 * dy + a20 * Math.pow(dx, 2) + a02 * Math.pow(dy, 2) + a21 * Math.pow(dx, 2) * dy + a03 * Math.pow(dy, 3);
                df += a40 * Math.pow(dx, 4) + a22 * Math.pow(dx, 2) * Math.pow(dy, 2) + a04 * Math.pow(dy, 4) + a41 * Math.pow(dx, 4) * dy;
                df += a23 * Math.pow(dx, 2) * Math.pow(dy, 3) + a42 * Math.pow(dx, 4) * Math.pow(dy, 2) + a24 * Math.pow(dx, 2) * Math.pow(dy, 4);
                var f = f0 + df / 3600;
                var dl = b10 * dx + b11 * dx * dy + b30 * Math.pow(dx, 3) + b12 * dx * Math.pow(dy, 2) + b31 * Math.pow(dx, 3) * dy;
                dl += b13 * dx * Math.pow(dy, 3) + b50 * Math.pow(dx, 5) + b32 * Math.pow(dx, 3) * Math.pow(dy, 2) + b14 * dx * Math.pow(dy, 4);
                dl += b51 * Math.pow(dx, 5) * dy + b33 * Math.pow(dx, 3) * Math.pow(dy, 3) + b15 * dx * Math.pow(dy, 5);
                var l = l0 + dl / 3600;
                var lat = f + (-96.862 - 11.714 * (f - 52) - 0.125 * (l - 5)) / 100000, lon = l + (-37.902 + 0.329 * (f - 52) - 14.667 * (l - 5)) / 100000;
                return { latitude: lat, longitude: lon };
            };
            /**
            * Calculate the log base 10 of val
            */
            GeoExtensions.log10 = function (val) {
                return (Math.LOG10E * Math.log(val));
            };
            GeoExtensions.convertDegreesToMeters = function (latitudeDegrees) {
                // Convert latitude to radians
                var lat = GeoExtensions.deg2rad(latitudeDegrees);
                // Set up "Constants"
                var m1 = 111132.92, // latitude calculation term 1
                m2 = -559.82, // latitude calculation term 2
                m3 = 1.175, // latitude calculation term 3
                m4 = -0.0023, // latitude calculation term 4
                p1 = 111412.84, // longitude calculation term 1
                p2 = -93.5, // longitude calculation term 2
                p3 = 0.118; // longitude calculation term 3
                // Calculate the length of a degree of latitude and longitude in meters
                var latlen = m1 + (m2 * Math.cos(2 * lat)) + (m3 * Math.cos(4 * lat)) + (m4 * Math.cos(6 * lat));
                var lonlen = (p1 * Math.cos(lat)) + (p2 * Math.cos(3 * lat)) + (p3 * Math.cos(5 * lat));
                return {
                    /**
                    * Length of a degree of latitude in meters
                    */
                    latitudeLength: latlen,
                    /**
                    * Length of a degree of longitude in meters
                    */
                    longitudeLength: lonlen
                };
            };
            /**
             * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
             *
             * @module turf/polygon
             * @category helper
             * @param {Array<Array<Number>>} rings an array of LinearRings
             * @param {Object=} properties a properties object
             * @returns {Feature<Polygon>} a Polygon feature
             * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
             * or if a LinearRing of the Polygon does not have matching Positions at the
             * beginning & end.
             * @example
             * var polygon = createPolygon([[
             *  [-2.275543, 53.464547],
             *  [-2.275543, 53.489271],
             *  [-2.215118, 53.489271],
             *  [-2.215118, 53.464547],
             *  [-2.275543, 53.464547]
             * ]], { name: 'poly1', population: 400});
             *
             * @seealso https://github.com/Turfjs/turf-polygon/blob/master/index.js
             */
            GeoExtensions.createPolygonFeature = function (coordinates, properties) {
                if (coordinates === null)
                    throw new Error('No coordinates passed');
                for (var i = 0; i < coordinates.length; i++) {
                    var ring = coordinates[i];
                    for (var j = 0; j < ring[ring.length - 1].length; j++) {
                        if (ring.length < 4) {
                            new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
                        }
                        if (ring[ring.length - 1][j] !== ring[0][j]) {
                            new Error('First and last Position are not equivalent.');
                        }
                    }
                }
                var polygon = {
                    "type": "Feature",
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": coordinates
                    },
                    "properties": properties
                };
                if (!polygon.properties) {
                    polygon.properties = {};
                }
                return polygon;
            };
            /**
             * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
             *
             * @param {Feature[]} features input features
             * @returns {FeatureCollection} a FeatureCollection of input features
             * @example
             * var features = [
             *  turf.point([-75.343, 39.984], {name: 'Location A'}),
             *  turf.point([-75.833, 39.284], {name: 'Location B'}),
             *  turf.point([-75.534, 39.123], {name: 'Location C'})
             * ];
             *
             * var fc = turf.featurecollection(features);
             *
             * @seealso https://github.com/Turfjs/turf-featurecollection/blob/master/index.js
             */
            GeoExtensions.createFeatureCollection = function (features) {
                return {
                    type: "FeatureCollection",
                    features: features
                };
            };
            GeoExtensions.createPointFeature = function (lon, lat, properties, sensors) {
                var gjson = {
                    type: "Feature",
                    geometry: {
                        type: "Point",
                        coordinates: [lon, lat]
                    },
                    properties: properties
                };
                if (sensors && sensors !== {}) {
                    gjson["sensors"] = sensors;
                }
                return gjson;
            };
            GeoExtensions.createLineFeature = function (coordinates, properties) {
                if (coordinates === null)
                    throw new Error('No coordinates passed');
                for (var i = 0; i < coordinates.length; i++) {
                    var ring = coordinates[i];
                    if (ring.length < 2) {
                        new Error('Each LineString of a Polygon must have 2 or more Positions.');
                    }
                }
                var lines = {
                    "type": "Feature",
                    "geometry": {
                        "type": "LineString",
                        "coordinates": coordinates
                    },
                    "properties": properties
                };
                if (!lines.properties) {
                    lines.properties = {};
                }
                return lines;
            };
            GeoExtensions.createPropertyType = function (name, section) {
                if (!name)
                    return;
                var propType = {
                    label: name,
                    title: name,
                    type: "text",
                    visibleInCallOut: true,
                    canEdit: true,
                    isSearchable: false
                };
                if (section)
                    propType["section"] = section;
                return propType;
            };
            GeoExtensions.convertMileToKm = function (miles) {
                if (!miles || isNaN(miles))
                    return;
                return (miles * 1.609344);
            };
            GeoExtensions.convertKmToMile = function (km) {
                if (!km || isNaN(km))
                    return;
                return (km * 0.621371192);
            };
            /**
             * pointInsidePolygon returns true if a 2D point lies within a polygon of 2D points
             * @param  {number[]}   point   [lat, lng]
             * @param  {number[][]} polygon [[lat, lng], [lat,lng],...]
             * @return {boolean}            Inside == true
             */
            GeoExtensions.pointInsidePolygon = function (point, polygon) {
                // https://github.com/substack/point-in-polygon
                // ray-casting algorithm based on
                // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
                var x = point[0];
                var y = point[1];
                var p = polygon[0];
                var inside = false;
                for (var i = 0, j = p.length - 1; i < p.length; j = i++) {
                    var xi = p[i][0], yi = p[i][1];
                    var xj = p[j][0], yj = p[j][1];
                    var intersect = ((yi > y) != (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect)
                        inside = !inside;
                }
                return inside;
            };
            /**
             * pointInsideMultiPolygon returns true if a 2D point lies within a multipolygon
             * @param  {number[]}   point   [lat, lng]
             * @param  {number[][][]} polygon [[[lat, lng], [lat,lng]],...]]
             * @return {boolean}            Inside == true
             */
            GeoExtensions.pointInsideMultiPolygon = function (point, multipoly) {
                // https://github.com/substack/point-in-polygon
                // ray-casting algorithm based on
                // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
                var inside = false;
                for (var i = 0; i < multipoly.length; i++) {
                    var polygon = multipoly[i];
                    if (GeoExtensions.pointInsidePolygon(point, polygon))
                        inside = !inside;
                }
                return inside;
            };
            /** Convert a string representation of a bounding box to an LatLngBounds.  */
            GeoExtensions.toBoundingBox = function (bb) {
                var pts = [];
                bb.split(',').forEach(function (p) {
                    pts.push(+p);
                });
                return new L.LatLngBounds([pts[1], pts[0]], [pts[3], pts[2]]);
            };
            /** Start slippy map computation */
            /** Convert longitude to tile coordinate. */
            GeoExtensions.lon2tile = function (lon, zoom) {
                return (Math.floor((lon + 180) / 360 * Math.pow(2, zoom)));
            };
            /** Convert latitude to tile coordinate. */
            GeoExtensions.lat2tile = function (lat, zoom) {
                return (Math.floor((1 - Math.log(Math.tan(lat * GeoExtensions.Rad2Deg) + 1 / Math.cos(lat * GeoExtensions.Rad2Deg)) / Math.PI) / 2 * Math.pow(2, zoom)));
            };
            /**
             * Convert a bounding box to slippy tile coordinates.
             * Returns an object that specifies the top, bottom, left and right tiles, as well as its width and height.
             *
             * See http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#ECMAScript_.28JavaScript.2FActionScript.2C_etc..29
             */
            GeoExtensions.slippyMapTiles = function (zoom, bbox) {
                var bb;
                if (typeof bbox === 'string') {
                    bb = GeoExtensions.toBoundingBox(bbox);
                }
                else {
                    bb = bbox;
                }
                var north_edge = bb.getNorth(), south_edge = bb.getSouth(), west_edge = bb.getWest(), east_edge = bb.getEast();
                var top_tile = GeoExtensions.lat2tile(north_edge, zoom); // eg.lat2tile(34.422, 9);
                var left_tile = GeoExtensions.lon2tile(west_edge, zoom);
                var bottom_tile = GeoExtensions.lat2tile(south_edge, zoom);
                var right_tile = GeoExtensions.lon2tile(east_edge, zoom);
                var width = Math.abs(left_tile - right_tile) + 1;
                var height = Math.abs(top_tile - bottom_tile) + 1;
                return {
                    top: top_tile,
                    bottom: bottom_tile,
                    left: left_tile,
                    right: right_tile,
                    width: width,
                    height: height
                };
            };
            GeoExtensions.Rad2Deg = Math.PI / 180;
            return GeoExtensions;
        }());
        Helpers.GeoExtensions = GeoExtensions;
    })(Helpers = csComp.Helpers || (csComp.Helpers = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=GeoExtensions.js.map
// export interface Array<T> {
//     serialize<T>(): string
// }
//
// Array<T>.prototype.serialize<T> = function() {
//     return "";
// }
var csComp;
(function (csComp) {
    var Helpers;
    (function (Helpers) {
        /**
         * Serialize an array of type T to a JSON string, by calling the callback on each array element.
         */
        function serialize(arr, callback, skipTitlesOrIdStartingWithUnderscore) {
            if (skipTitlesOrIdStartingWithUnderscore === void 0) { skipTitlesOrIdStartingWithUnderscore = false; }
            if (typeof arr === 'undefined' || arr === null || arr.length === 0)
                return null;
            var result = [];
            arr.forEach(function (a) {
                if (skipTitlesOrIdStartingWithUnderscore
                    && ((a.hasOwnProperty('title') && a['title'][0] === '_')
                        || (a.hasOwnProperty('id') && a['id'][0] === '_')))
                    return;
                result.push(callback(a));
            });
            return result;
        }
        Helpers.serialize = serialize;
        function cloneWithoutUnderscore(v) {
            var _this = this;
            if (typeof v !== 'object')
                return v;
            if (v instanceof Array) {
                var a = [];
                v.forEach(function (i) {
                    a.push(_this.cloneWithoutUnderscore(i));
                });
                return a;
            }
            else {
                var c = {};
                for (var k in v) {
                    if (k[0] !== '_')
                        c[k] = this.cloneWithoutUnderscore(v[k]);
                }
                return c;
            }
        }
        Helpers.cloneWithoutUnderscore = cloneWithoutUnderscore;
        /** get the name part of a featureid (strips resource uri part if needed) */
        function getFeatureTypeName(id) {
            if (id.indexOf('#') >= 0) {
                return id.split('#')[1];
            }
            else
                return id;
        }
        Helpers.getFeatureTypeName = getFeatureTypeName;
        function getDefaultFeatureStyle(feature) {
            if (feature && (feature.geometry && feature.geometry.type && feature.geometry.type.toLowerCase() === 'point') || (feature.fType && feature.fType.style && feature.fType.style.drawingMode && feature.fType.style.drawingMode.toLowerCase() === "point")) {
                var p = {
                    nameLabel: 'Name',
                    drawingMode: 'Point',
                    strokeWidth: 1,
                    strokeColor: '#0033ff',
                    fillOpacity: 1,
                    strokeOpacity: 0,
                    opacity: 1,
                    fillColor: '#000000',
                    stroke: true,
                    rotate: 0,
                    cornerRadius: 50,
                    iconHeight: 32,
                    iconWidth: 32
                };
                return p;
            }
            else {
                var s = {
                    nameLabel: 'Name',
                    drawingMode: 'Polygon',
                    strokeWidth: 1,
                    strokeColor: '#0033ff',
                    fillOpacity: 0.75,
                    strokeOpacity: 1,
                    opacity: 0.75,
                    fillColor: '#FFFF00',
                    stroke: true,
                    iconUri: 'bower_components/csweb/dist-bower/images/marker.png'
                };
                return s;
            }
            //TODO: check compatibility for both heatmaps and other features
        }
        Helpers.getDefaultFeatureStyle = getDefaultFeatureStyle;
        /**
         * Export data to the file system.
         */
        function saveData(data, filename, fileType) {
            fileType = fileType.replace('.', '');
            filename = filename.replace('.' + fileType, '') + '.' + fileType; // if the filename already contains a type, first remove it before adding it.
            if (navigator.msSaveBlob) {
                // IE 10+
                var link = document.createElement('a');
                link.addEventListener('click', function (event) {
                    var blob = new Blob([data], { 'type': 'text/' + fileType + ';charset=utf-8;' });
                    navigator.msSaveBlob(blob, filename);
                }, false);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            else if (!csComp.Helpers.supportsDataUri()) {
                // Older versions of IE: show the data in a new window
                var popup = window.open('', fileType, '');
                popup.document.body.innerHTML = '<pre>' + data + '</pre>';
            }
            else {
                // Support for browsers that support the data uri.
                var a = document.createElement('a');
                document.body.appendChild(a);
                a.href = 'data:    text/' + fileType + ';charset=utf-8,' + encodeURI(data);
                a.target = '_blank';
                a.download = filename;
                a.click();
                document.body.removeChild(a);
            }
        }
        Helpers.saveData = saveData;
        /** Returns the next character. */
        function nextChar(c) {
            return String.fromCharCode(c.charCodeAt(0) + 1);
        }
        Helpers.nextChar = nextChar;
        function supportsDataUri() {
            var isOldIE = navigator.appName === 'Microsoft Internet Explorer';
            var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
            return !(isOldIE || isIE11); //Return true if not any IE
        }
        Helpers.supportsDataUri = supportsDataUri;
        function standardDeviation(values) {
            var avg = average(values);
            var squareDiffs = values.map(function (value) {
                var diff = value - avg;
                var sqrDiff = diff * diff;
                return sqrDiff;
            });
            var avgSquareDiff = average(squareDiffs);
            var stdDev = Math.sqrt(avgSquareDiff);
            return { avg: avg, stdDev: stdDev };
        }
        Helpers.standardDeviation = standardDeviation;
        function average(data) {
            var sum = data.reduce(function (accumulatedSum, value) { return (accumulatedSum + value); }, 0);
            var avg = sum / data.length;
            return avg;
        }
        Helpers.average = average;
        function getFeatureTitle(feature) {
            return featureTitle(feature.fType, feature);
        }
        Helpers.getFeatureTitle = getFeatureTitle;
        function featureTitle(type, feature) {
            var title = '';
            if (feature.hasOwnProperty('properties')) {
                if (feature.properties.hasOwnProperty('Name')) {
                    title = feature.properties['Name'];
                }
                else if (feature.properties.hasOwnProperty('name')) {
                    title = feature.properties['name'];
                }
                else if (feature.properties.hasOwnProperty('naam')) {
                    title = feature.properties['naam'];
                }
            }
            else if (type != null && type.style != null && type.style.nameLabel) {
                title = feature.properties[type.style.nameLabel];
            }
            if (!csComp.StringExt.isNullOrEmpty(title) && !$.isNumeric(title))
                title = title.replace(/&amp;/g, '&');
            return '' + title;
        }
        Helpers.featureTitle = featureTitle;
        /**
         * Collect all the property types that are referenced by a feature type.
         */
        function getPropertyTypes(type, propertyTypeData, feature) {
            var propertyTypes = [];
            if (type.propertyTypeKeys && type.propertyTypeKeys.length > 0 && typeof type.propertyTypeKeys === 'string') {
                var keys = type.propertyTypeKeys.split(/[,;]+/);
                keys.forEach(function (key) {
                    // First, lookup key in global propertyTypeData
                    if (propertyTypeData && propertyTypeData.hasOwnProperty(key)) {
                        propertyTypes.push(propertyTypeData[key]);
                    }
                    else if (type._propertyTypeData != null) {
                        // If you cannot find it there, look it up in the featureType's propertyTypeData.
                        var result = $.grep(type._propertyTypeData, function (e) { return e.label === key; });
                        if (result.length >= 1)
                            propertyTypes.push(result);
                    }
                });
            }
            // EV REMOVE?
            // if (type.showAllProperties && feature && feature.properties) {
            //     for (var key in feature.properties) {
            //         if (!propertyTypes.some((pt: csComp.Services.IPropertyType) => pt.label === key)) {
            //             //var pt =
            //         }
            //     }
            // }
            if (type._propertyTypeData != null) {
                if (type._propertyTypeData.forEach) {
                    type._propertyTypeData.forEach(function (pt) {
                        propertyTypes.push(pt);
                    });
                }
                else {
                    for (var ptlabel in type._propertyTypeData) {
                        if (type._propertyTypeData.hasOwnProperty(ptlabel)) {
                            propertyTypes.push(type._propertyTypeData[ptlabel]);
                        }
                    }
                }
            }
            return propertyTypes;
        }
        Helpers.getPropertyTypes = getPropertyTypes;
        function getPropertyKey(keyString, property) {
            var keys = keyString.split(';');
            var prop = property;
            var count = 1;
            while (keys.indexOf(prop) >= 0) {
                prop = property + count;
                count++;
            }
            return prop;
        }
        Helpers.getPropertyKey = getPropertyKey;
        function getPropertyType(feature, key) {
            var propertyType = {};
            propertyType.label = key;
            propertyType.title = key.replace('_', ' ');
            propertyType.isSearchable = true;
            propertyType.visibleInCallOut = true;
            propertyType.canEdit = false;
            var value = feature.properties[key]; // TODO Why does TS think we are returning an IStringToString object?
            if (csComp.StringExt.isDate(value)) {
                propertyType.type = 'date';
            }
            else if (csComp.StringExt.isNumber(value)) {
                propertyType.type = 'number';
            }
            else if (csComp.StringExt.isBoolean(value)) {
                propertyType.type = 'boolean';
            }
            else if (csComp.StringExt.isArray(value)) {
                propertyType.type = 'tags';
            }
            else if (csComp.StringExt.isBbcode(value)) {
                propertyType.type = 'bbcode';
            }
            else {
                propertyType.type = 'text';
            }
            return propertyType;
        }
        Helpers.getPropertyType = getPropertyType;
        function getMissingPropertyTypes(feature) {
            //var type = featureType;
            var res = [];
            //        if (!type.propertyTypeData) type.propertyTypeData = [];
            for (var key in feature.properties) {
                //if (!type.propertyTypeData.some((pt: csComp.Services.IPropertyType) => { return pt.label === key; })) {
                if (!feature.properties.hasOwnProperty(key))
                    continue;
                res.push(getPropertyType(feature, key));
            }
            return res;
        }
        Helpers.getMissingPropertyTypes = getMissingPropertyTypes;
        /** find a unique key name in object */
        function findUniqueKey(o, key) {
            var i = 2;
            var pk = key;
            while (o.hasOwnProperty(pk)) {
                key = key + pk;
                pk += 1;
            }
            return pk;
        }
        Helpers.findUniqueKey = findUniqueKey;
        function addPropertyTypes(feature, featureType, resource) {
            var _this = this;
            var type = featureType;
            if (type._propertyTypeData && type._propertyTypeData.length > 0) {
                type._propertyTypeData.forEach(function (pt) {
                    _this.updateSection(feature.layer, pt);
                });
            }
            else {
                for (var key in feature.properties) {
                    var pt;
                    if (resource)
                        pt = _.find(_.values(resource.propertyTypeData), function (i) { return i.label === key; });
                    if (!pt) {
                        pt = {};
                        pt.label = key;
                        pt.title = key.replace('_', ' ');
                        var value = feature.properties[key]; // TODO Why does TS think we are returning an IStringToString object?
                        // text is default, so we can ignore that
                        if (csComp.StringExt.isNumber(value)) {
                            {
                                pt.type = 'number';
                            }
                        }
                        else if (csComp.StringExt.isBoolean(value)) {
                            {
                                pt.type = 'boolean';
                            }
                        }
                        else if (csComp.StringExt.isBbcode(value)) {
                            {
                                pt.type = 'bbcode';
                            }
                        }
                        if (resource && resource.propertyTypeData) {
                            var ke = findUniqueKey(resource.propertyTypeData, key);
                            if (ke === key) {
                                delete pt.label;
                            }
                            resource.propertyTypeData[ke] = pt;
                            // since k was set in an internal loop. However, it may be that k => key
                            resource.propertyTypeData[ke] = pt;
                        }
                        else {
                            if (!featureType._propertyTypeData) {
                                featureType._propertyTypeData = [];
                            }
                            featureType._propertyTypeData[key] = pt;
                        }
                        updateSection(feature.layer, pt);
                    }
                }
            }
            return type;
        }
        Helpers.addPropertyTypes = addPropertyTypes;
        function updateSection(layer, prop) {
            if (!layer || !prop)
                return;
            if (prop.type === 'number' || prop.hasOwnProperty('legend')) {
                if (!layer._gui.hasOwnProperty('sections'))
                    layer._gui['sections'] = {};
                var sections = layer._gui['sections'];
                var s = (prop.section) ? prop.section : 'general';
                if (!sections.hasOwnProperty(s))
                    sections[s] = new csComp.Services.Section();
                if (!sections[s].properties.hasOwnProperty(prop.label))
                    sections[s].properties[prop.label] = prop;
            }
        }
        Helpers.updateSection = updateSection;
        /**
         * In case we are dealing with a regular JSON file without type information, create a default type.
         */
        function createDefaultType(feature, resource) {
            var type = {};
            type.style = getDefaultFeatureStyle(feature);
            this.addPropertyTypes(feature, type, resource);
            return type;
        }
        Helpers.createDefaultType = createDefaultType;
        /**
         * Convert a property value to a display value using the property info.
         */
        function convertPropertyInfo(pt, text) {
            var displayValue;
            // if (!csComp.StringExt.isNullOrEmpty(text) && !$.isNumeric(text))
            //     text = text.replace(/&amp;/g, '&');
            if (!text || !pt.type)
                return text;
            switch (pt.type) {
                case 'bbcode':
                    if (pt.stringFormat)
                        text = String.format(pt.stringFormat, text);
                    displayValue = XBBCODE.process({ text: text }).html;
                    break;
                case 'number':
                    if (!$.isNumeric(text)) {
                        displayValue = text;
                    }
                    else if (!pt.stringFormat) {
                        displayValue = text.toString();
                    }
                    else {
                        displayValue = String.format(pt.stringFormat, parseFloat(text));
                    }
                    break;
                case 'options':
                    if (!$.isNumeric(text)) {
                        displayValue = text;
                    }
                    else {
                        displayValue = pt.options[text];
                    }
                    break;
                case 'rank':
                    var rank = text.split(',');
                    if (rank.length !== 2)
                        return text;
                    if (pt.stringFormat) {
                        displayValue = String.format(pt.stringFormat, rank[0], rank[1]);
                    }
                    else {
                        displayValue = String.format('{0} / {1}', rank[0], rank[1]);
                    }
                    break;
                case 'hierarchy':
                    var hierarchy = text.split(';');
                    var count = hierarchy[0];
                    var calculation = hierarchy[1];
                    displayValue = count.toString();
                    break;
                case 'date':
                    var d;
                    if ($.isNumeric(text)) {
                        d = new Date(text);
                    }
                    else {
                        d = new Date(Date.parse(text));
                    }
                    displayValue = pt.stringFormat
                        ? String.format(pt.stringFormat, d)
                        : d.toLocaleString();
                    break;
                case 'duration':
                    if (!$.isNumeric(text)) {
                        displayValue = text;
                    }
                    else {
                        var d0 = new Date(0);
                        var d1 = new Date(text);
                        var h = d1.getHours() - d0.getHours();
                        var m = d1.getMinutes() - d0.getMinutes();
                        var s = d1.getSeconds() - d0.getSeconds();
                        displayValue = ('0' + h).slice(-2) + 'h' + ('0' + m).slice(-2) + 'm' + ('0' + s).slice(-2) + 's';
                    }
                    break;
                default:
                    displayValue = pt.stringFormat
                        ? String.format(pt.stringFormat, text)
                        : text;
                    break;
            }
            return displayValue;
        }
        Helpers.convertPropertyInfo = convertPropertyInfo;
        /**
        * Set the name of a feature.
        * @param {csComp.Services.IFeature} feature
        */
        function setFeatureName(feature, propertyTypeData) {
            // Case one: we don't need to set it, as it's already present.
            if (feature.properties.hasOwnProperty('Name'))
                return feature;
            if (feature.properties.hasOwnProperty('name')) {
                feature.properties['Name'] = feature.properties['name'];
                return feature;
            }
            if (feature.properties.hasOwnProperty('NAME')) {
                feature.properties['Name'] = feature.properties['NAME'];
                return feature;
            }
            // Case two: the feature's style tells us what property to use for the name.
            if (feature.fType && feature.fType.style && feature.fType.style.nameLabel) {
                var nameLabel = feature.fType.style.nameLabel;
                if (feature.properties.hasOwnProperty(nameLabel)) {
                    if (propertyTypeData && propertyTypeData.hasOwnProperty(nameLabel)) {
                        feature.properties['Name'] = convertPropertyInfo(propertyTypeData[nameLabel], feature.properties[nameLabel]);
                    }
                    else {
                        feature.properties['Name'] = feature.properties[nameLabel];
                    }
                    return feature;
                }
            }
            // Case three: the feature has a Name property which specifies a string format, meaning that the Name is derived from several existing properties.
            if (feature.fType._propertyTypeData) {
                // for .. of
                for (var i = 0; i < feature.fType._propertyTypeData.length; i++) {
                    var propertyType = feature.fType._propertyTypeData[i];
                    if (propertyType.label !== 'Name' || !propertyType.stringFormat)
                        continue;
                    feature.properties['Name'] = Helpers.convertStringFormat(feature, propertyType.stringFormat);
                    return feature;
                }
            }
            // If all else fails, use the first property
            for (var prop in feature.properties) {
                feature.properties['Name'] = prop.toString(); //feature.properties[prop];
                return feature;
            }
            // Finally, just create a GUID.
            feature.properties['Name'] = Helpers.getGuid();
            return feature;
        }
        Helpers.setFeatureName = setFeatureName;
        /**
        * Convert a feature's stringFormat to a string.
        * @param {Services.IFeature} feature
        * @param {string} stringFormat
        */
        function convertStringFormat(feature, stringFormat) {
            var openingBrackets = Helpers.indexes(stringFormat, '{');
            var closingBrackets = Helpers.indexes(stringFormat, '}');
            var convertedStringFormat = stringFormat;
            for (var j = 0; j < openingBrackets.length; j++) {
                var searchValue = stringFormat.substring(openingBrackets[j] + 1, closingBrackets[j]);
                var replaceValue = (feature.properties.hasOwnProperty(searchValue)) ? feature.properties[searchValue] : '';
                convertedStringFormat = convertedStringFormat.replace('{' + searchValue + '}', replaceValue);
            }
            return convertedStringFormat;
        }
        Helpers.convertStringFormat = convertStringFormat;
        /**
        * Get all indexes of the 'find' substring in the 'source' string.
        * @param {string} source
        * @param {string} find
        */
        function indexes(source, find) {
            if (!source)
                return [];
            var result = [];
            for (var i = 0; i < source.length; i++) {
                if (source.substr(i, find.length) === find)
                    result.push(i);
            }
            return result;
        }
        Helpers.indexes = indexes;
        function getGuid() {
            var guid = (this.S4() + this.S4() + '-' + this.S4() + '-4' + this.S4().substr(0, 3) + '-' + this.S4() + '-' + this.S4() + this.S4() + this.S4()).toLowerCase();
            return guid;
        }
        Helpers.getGuid = getGuid;
        function S4() {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        Helpers.S4 = S4;
        /**
         * Load the features as visible on the map, effectively creating a virtual
         * GeoJSON file that represents all visible items.
         * Also loads the keys into the featuretype's propertyTypeData collection.
         */
        function loadMapLayers(layerService) {
            var data = {
                type: '',
                features: [],
                featureTypes: {}
            };
            // If we are filtering, load the filter results
            layerService.project.groups.forEach(function (group) {
                if (group.filterResult != null)
                    group.filterResult.forEach(function (f) { return data.features.push(f); });
            });
            // Otherwise, take all loaded features
            if (data.features.length === 0)
                data.features = layerService.project.features;
            data.features.forEach(function (f) {
                if (!(data.featureTypes.hasOwnProperty(f.featureTypeName))) {
                    var featureType = layerService.getFeatureType(f);
                    if (!featureType.name)
                        featureType.name = f.featureTypeName.replace('_Default', '');
                    data.featureTypes[f.featureTypeName] = featureType;
                    if (featureType.propertyTypeKeys) {
                        featureType._propertyTypeData = [];
                        featureType.propertyTypeKeys.split(/[,;]+/).forEach(function (key) {
                            if (layerService.propertyTypeData.hasOwnProperty(key)) {
                                featureType._propertyTypeData.push(layerService.propertyTypeData[key]);
                            }
                        });
                    }
                }
            });
            return data;
        }
        Helpers.loadMapLayers = loadMapLayers;
        /**
         * Helper function to create content for the RightPanelTab
         * @param  {string} container The container name
         * @param  {string} directive The directive of the container
         * @param  {any}    data      Panel data
         * @return {RightPanelTab}    Returns the RightPanelTab instance. Add it to the
         * rightpanel by publishing it on the MessageBus.
         */
        function createRightPanelTab(container, directive, data, title, popover, icon, replace, canClose) {
            var rpt = new csComp.Services.RightPanelTab();
            rpt.container = container;
            rpt.data = data;
            rpt.title = title;
            rpt.directive = directive;
            rpt.popover = popover || '';
            rpt.icon = icon || 'tachometer';
            rpt.replace = replace;
            if (typeof canClose !== 'undefined')
                rpt.canClose = canClose;
            return rpt;
        }
        Helpers.createRightPanelTab = createRightPanelTab;
        /**
         * Helper function to parse a query of an url (e.g localhost:8080/api?a=1&b=2&c=3)
         */
        function parseUrlParameters(url, baseDelimiter, subDelimiter, valueDelimiter) {
            var baseUrl = url.split(baseDelimiter)[0];
            var croppedUrl = url.split(baseDelimiter)[1];
            var splittedUrl = croppedUrl.split(subDelimiter);
            var urlParameters = {};
            splittedUrl.forEach(function (param) {
                var keyValue = param.split(valueDelimiter);
                urlParameters[keyValue[0]] = (isNaN(+keyValue[1])) ? keyValue[1] : +keyValue[1]; //Store as number when possible
            });
            urlParameters['baseUrl'] = baseUrl;
            return urlParameters;
        }
        Helpers.parseUrlParameters = parseUrlParameters;
        /**
         * Helper function to parse a query of an url (e.g localhost:8080/api?a=1&b=2&c=3)
         */
        function joinUrlParameters(params, baseDelimiter, subDelimiter, valueDelimiter) {
            var url = params['baseUrl'] + baseDelimiter;
            for (var key in params) {
                if (params.hasOwnProperty(key) && key !== 'baseUrl' && params[key]) {
                    url = url + key + valueDelimiter + params[key] + subDelimiter;
                }
            }
            url = url.substring(0, url.length - 1);
            return url;
        }
        Helpers.joinUrlParameters = joinUrlParameters;
        function createIconHtml(feature, style) {
            var es = (typeof style === 'undefined') ? feature.effectiveStyle : style;
            var iconUri = es.iconUri; //ft.style.iconUri;
            var html, content, closeImageTag = '';
            switch (es.drawingMode) {
                case 'Line':
                    break;
                case 'Polygon':
                    html = '<img src="images/bom.png"></img>';
                    break;
                case 'Point':
                    // TODO refactor to object
                    var iconPlusBorderWidth, iconPlusBorderHeight;
                    if (es.hasOwnProperty('strokeWidth') && es.strokeWidth > 0) {
                        iconPlusBorderWidth = es.iconWidth + (2 * es.strokeWidth);
                        iconPlusBorderHeight = es.iconHeight + (2 * es.strokeWidth);
                    }
                    else {
                        iconPlusBorderWidth = es.iconWidth;
                        iconPlusBorderHeight = es.iconHeight;
                    }
                    if (es.innerTextProperty != null && feature.properties.hasOwnProperty(es.innerTextProperty)) {
                        var textSize = es.innerTextSize || 12;
                        if (es.marker === 'pin') {
                            content = "<div class=\"pin-inner\" style=\"font-size:" + textSize + "px;\">" + feature.properties[es.innerTextProperty] + "</div>";
                        }
                        else {
                            content = "<span style=\"font-size:" + textSize + "px;vertical-align:-webkit-baseline-middle\">" + feature.properties[es.innerTextProperty] + "</span>";
                        }
                    }
                    else if (iconUri != null) {
                        // Must the iconUri be formatted?
                        if (iconUri != null && iconUri.indexOf('{') >= 0)
                            iconUri = Helpers.convertStringFormat(feature, iconUri);
                        content = "<img src=\"" + iconUri + "\" style=\"width:" + es.iconWidth + "px;height:" + es.iconHeight + "px;display:block;";
                        if (es.rotate && es.rotate > 0)
                            content += ";transform:rotate(" + es.rotate + "deg)";
                        closeImageTag = '" />';
                    }
                    if (isNaN(es.fillOpacity))
                        es.fillOpacity = 1;
                    var bc = chroma(es.fillColor).alpha(+es.fillOpacity).rgba();
                    var backgroundColor = "rgba(" + bc[0] + "," + bc[1] + "," + bc[2] + "," + bc[3] + ")";
                    switch (es.marker) {
                        case 'pin':
                            if (es.innerTextProperty) {
                                html = '<div class="pin" style="display:inline-block;vertical-align:bottom;text-align:center;'
                                    + ("background:" + backgroundColor + ";")
                                    + ("width:" + iconPlusBorderWidth + "px;")
                                    + ("height:" + iconPlusBorderHeight + "px;")
                                    + ("opacity:" + (es.opacity || 1) + ";")
                                    + ("\">" + content + "</div>");
                            }
                            else {
                                html = '<div class="pin" style="display:inline-block;vertical-align:bottom;text-align:center;'
                                    + ("background:" + backgroundColor + ";")
                                    + ("width:" + iconPlusBorderWidth + "px;")
                                    + ("height:" + iconPlusBorderHeight + "px;")
                                    + ("opacity:" + (es.opacity || 1) + ";")
                                    + '"></div>'
                                    + content
                                    + ("position:absolute;margin:" + es.strokeWidth + "px\" />");
                            }
                            break;
                        case 'bubble':
                            html = '<div class="bubble" style="display:inline-block;vertical-align:bottom;text-align:center;'
                                + ("background:" + backgroundColor + ";")
                                + ("width:" + iconPlusBorderWidth + "px;")
                                + ("height:" + iconPlusBorderHeight + "px;")
                                + ("opacity:" + (es.opacity || 1) + ";")
                                + '"></div>'
                                + content + ("position:absolute;margin:" + es.strokeWidth + "px\" />");
                            break;
                        default:
                            var sc = chroma(es.strokeColor).alpha(+es.strokeOpacity || 1).rgba();
                            var strokeColor = "rgba(" + sc[0] + "," + sc[1] + "," + sc[2] + "," + sc[3] + ")";
                            html = '<div style="display:inline-block;vertical-align:middle;text-align:center;'
                                + ("background:" + backgroundColor + ";")
                                + ("width:" + iconPlusBorderWidth + "px;")
                                + ("height:" + iconPlusBorderHeight + "px;")
                                + ("border-radius:" + es.cornerRadius + "%;")
                                + 'border-style:solid;'
                                + ("border-color:" + strokeColor + ";")
                                + ("border-width:" + es.strokeWidth + "px;")
                                + ("opacity:" + (es.opacity || 1) + ";")
                                + '">'
                                + content + closeImageTag
                                + '</div>';
                            break;
                    }
            }
            var iconHtml = {
                html: html,
                iconPlusBorderWidth: iconPlusBorderWidth,
                iconPlusBorderHeight: iconPlusBorderHeight
            };
            return iconHtml;
        }
        Helpers.createIconHtml = createIconHtml;
    })(Helpers = csComp.Helpers || (csComp.Helpers = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=Helpers.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Helpers;
    (function (Helpers) {
        var PieData = (function () {
            function PieData() {
            }
            return PieData;
        }());
        Helpers.PieData = PieData;
        var AsterPieData = (function (_super) {
            __extends(AsterPieData, _super);
            function AsterPieData() {
                _super.apply(this, arguments);
            }
            return AsterPieData;
        }(PieData));
        Helpers.AsterPieData = AsterPieData;
        var Plot = (function () {
            function Plot() {
            }
            /**
             * Draw a histogram, and, if xy is specified, a line plot of x versus y (e.g. a scoring function).
             */
            Plot.drawHistogram = function (values, options) {
                var id = (options != null && options.hasOwnProperty("id")) ? options.id : "myHistogram";
                var numberOfBins = (options != null && options.hasOwnProperty("numberOfBins")) ? options.numberOfBins : 10;
                var width = (options != null && options.hasOwnProperty("width")) ? options.width : 200;
                var height = (options != null && options.hasOwnProperty("height")) ? options.height : 150;
                var xLabel = (options != null && options.hasOwnProperty("xLabel")) ? options.xLabel : "";
                var selectedValue = (options != null && options.hasOwnProperty("selectedValue")) ? options.selectedValue : null;
                // var yLabel       = (options != null && options.hasOwnProperty('yLabel'))        ? options.yLabel        : '#';
                var margin = { top: 0, right: 6, bottom: 24, left: 6 };
                width -= margin.left + margin.right,
                    height -= margin.top + margin.bottom;
                var svgId = 'the_SVG_ID';
                Plot.clearSvg(svgId);
                if (values.length < numberOfBins)
                    return;
                // A formatter for counts.
                var formatCount = d3.format(",.0f");
                var max = Math.max.apply(null, values);
                var min = Math.min.apply(null, values);
                var range = max - min;
                // Scale the x-range, so we don't have such long numbers
                var scale = Plot.getScale(range / numberOfBins, max);
                // var scale = range >= 10
                //    ? Math.max(d3.round(range, 0), d3.round(max, 0)).toString().length - 2 // 100 -> 1
                //    : -2;
                var scaleFactor = 0;
                if (Math.abs(scale) > 0) {
                    xLabel += " (x10^" + scale + ")";
                    scaleFactor = Math.pow(10, scale);
                }
                var tickFormatter = function (value) {
                    return scaleFactor > 0
                        ? d3.round(value / scaleFactor, 0).toString()
                        : d3.round(value, 0).toString();
                };
                var tempScale = d3.scale.linear().domain([0, numberOfBins]).range([min, max]);
                var tickArray = d3.range(numberOfBins + 1).map(tempScale);
                var x = d3.scale.linear()
                    .domain([min, max])
                    .range([0, width]);
                var xAxis = d3.svg.axis()
                    .scale(x)
                    .tickValues(tickArray)
                    .tickFormat(tickFormatter)
                    .orient("bottom");
                // Generate a histogram using numberOfBins uniformly-spaced bins.
                var data = d3.layout.histogram().bins(numberOfBins)(values);
                var y = d3.scale.linear()
                    .domain([0, d3.max(data, function (d) { return d.y; })])
                    .range([height, 0]);
                var svg = d3.select("#" + id)
                    .append("svg")
                    .attr("id", svgId)
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .attr("style", "display: block; margin: 0 auto;")
                    .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var bar = svg.selectAll(".bar")
                    .data(data)
                    .enter().append("g")
                    .attr("class", function (d, i) {
                    return selectedValue != null && (d.x < selectedValue && selectedValue < d.x + data[i].dx)
                        ? "bar highlight"
                        : "bar";
                })
                    .attr("transform", function (d) { return "translate(" + x(d.x) + "," + y(d.y) + ")"; });
                bar.append("rect")
                    .attr("x", 1)
                    .attr("width", x(min + data[0].dx) - 1)
                    .attr("height", function (d) { return height - y(d.y); });
                var conditionalFormatCounter = function (value) {
                    return (height - y(value) > 6)
                        ? formatCount(value)
                        : "";
                };
                // Text (count) inside the bins
                bar.append("text")
                    .attr("dy", ".75em")
                    .attr("y", 6)
                    .attr("x", x(min + data[0].dx) / 2)
                    .attr("text-anchor", "middle")
                    .text(function (d) { return conditionalFormatCounter(d.y); });
                // x-label
                svg.append("text")
                    .attr("class", "x label")
                    .attr("text-anchor", "end")
                    .attr("x", width)
                    .attr("y", height / 2 - 6)
                    .text(xLabel);
                svg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis);
            };
            Plot.getScale = function (stepSize, max) {
                for (var sf = -5; sf < 5; sf++) {
                    var scale = Math.pow(10, sf);
                    var ls = d3.round(stepSize / scale, 0);
                    var lm = d3.round(max / scale, 0);
                    if (0 < ls && ls < 10 && 0 < lm && lm < 100)
                        return sf;
                }
                return 0;
            };
            Plot.drawMcaPlot = function (values, options) {
                var id = (options != null && options.hasOwnProperty("id")) ? options.id : "myHistogram";
                var numberOfBins = (options != null && options.hasOwnProperty("numberOfBins")) ? options.numberOfBins : 10;
                var width = (options != null && options.hasOwnProperty("width")) ? options.width : 200;
                var height = (options != null && options.hasOwnProperty("height")) ? options.height : 150;
                var xLabel = (options != null && options.hasOwnProperty("xLabel")) ? options.xLabel : "";
                var xyData = (options != null && options.hasOwnProperty("xy")) ? options.xy : null;
                var featureValue = (options != null && options.hasOwnProperty("featureValue")) ? options.featureValue : null;
                // var yLabel       = (options != null && options.hasOwnProperty('yLabel'))       ? options.yLabel       : '#';
                var margin = { top: 0, right: 6, bottom: 24, left: 6 };
                width -= margin.left + margin.right,
                    height -= margin.top + margin.bottom;
                var svgId = id + "_histogram";
                Plot.clearSvg(svgId);
                // A formatter for counts.
                var formatCount = d3.format(",.0f");
                var max, min, range;
                if (xyData != null) {
                    max = xyData.x[xyData.x.length - 1];
                    min = xyData.x[0];
                    range = max - min;
                    max += range / 10;
                    min -= range / 10;
                }
                else {
                    max = Math.max.apply(null, values);
                    min = Math.min.apply(null, values);
                }
                range = max - min;
                // Scale the x-range, so we don't have such long numbers
                var scale = Plot.getScale(range / numberOfBins, max);
                // var scale = range >= 10
                //    ? Math.max(d3.round(range, 0), d3.round(max, 0)).toString().length - 2 // 100 -> 1
                //    : -2;
                var scaleFactor = 0;
                xLabel += " (";
                if (Math.abs(scale) > 0) {
                    xLabel += "x10^" + scale;
                    scaleFactor = Math.pow(10, scale);
                }
                var tickFormatter = function (value) {
                    return scaleFactor > 0
                        ? d3.round(value / scaleFactor, 0).toString()
                        : d3.round(value, 0).toString();
                };
                var tempScale = d3.scale.linear().domain([0, numberOfBins]).range([min, max]);
                var tickArray = d3.range(numberOfBins + 1).map(tempScale);
                var x = d3.scale.linear()
                    .domain([min, max])
                    .range([0, width]);
                var xAxis = d3.svg.axis()
                    .scale(x)
                    .tickValues(tickArray)
                    .tickFormat(tickFormatter)
                    .orient("bottom");
                // Generate a histogram using numberOfBins uniformly-spaced bins.
                var valuesInRange = values.filter(function (value) { return (min <= value && value <= max); });
                if (valuesInRange.length < 3) {
                    var svg1 = d3.select("#" + id)
                        .append("svg")
                        .attr("id", svgId)
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom)
                        .append("g")
                        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                    svg1.append("text")
                        .attr("class", "x label")
                        .attr("text-anchor", "center")
                        .attr("x", width / 2)
                        .attr("y", height / 2 + 6)
                        .text("\u03A7 NO DATA IN RANGE");
                    return;
                }
                xLabel += " \u03A3" + valuesInRange.length;
                var data = d3.layout.histogram().bins(numberOfBins)(valuesInRange);
                var y = d3.scale.linear()
                    .domain([0, d3.max(data, function (d) { return d.y; })])
                    .range([height, 0]);
                var svg = d3.select("#" + id)
                    .append("svg")
                    .attr("id", svgId)
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .attr("style", "display: block; margin: 0 auto;")
                    .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var bar = svg.selectAll(".bar")
                    .data(data)
                    .enter().append("g")
                    .attr("class", "bar")
                    .attr("transform", function (d) { return "translate(" + x(d.x) + "," + y(d.y) + ")"; });
                bar.append("rect")
                    .attr("x", 1)
                    .attr("width", x(min + data[0].dx) - 1)
                    .attr("height", function (d) { return height - y(d.y); });
                var conditionalFormatCounter = function (value) {
                    return (height - y(value) > 6)
                        ? formatCount(value)
                        : "";
                };
                // Text (count) inside the bins
                bar.append("text")
                    .attr("dy", ".75em")
                    .attr("y", 6)
                    .attr("x", x(min + data[0].dx) / 2)
                    .attr("text-anchor", "middle")
                    .text(function (d) { return conditionalFormatCounter(d.y); });
                // x-label
                xLabel += ")";
                svg.append("text")
                    .attr("class", "x label")
                    .attr("text-anchor", "end")
                    .attr("x", width)
                    .attr("y", height / 2 - 6)
                    .text(xLabel);
                svg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis);
                if (xyData == null)
                    return;
                // Draw line chart
                var xy = [];
                xy.push({ x: min, y: xyData.y[0] });
                for (var i = 0; i < xyData.x.length; i++) {
                    xy.push({ x: xyData.x[i], y: xyData.y[i] });
                }
                xy.push({ x: max, y: xyData.y[xyData.y.length - 1] });
                var y2 = d3.scale.linear()
                    .domain([0, d3.max(xy, function (d) { return d.y; })])
                    .range([height - 1, 1]);
                var lineFunc = d3.svg.line()
                    .x(function (d) { return x(d.x); })
                    .y(function (d) { return y2(d.y); })
                    .interpolate("linear");
                svg.append("svg:path")
                    .attr("d", lineFunc(xy))
                    .attr("stroke", "red")
                    .attr("stroke-width", 2)
                    .attr("fill", "none");
                if (featureValue == null)
                    return;
                // Draw feature on the score
                xy = [];
                xy.push({ x: featureValue, y: 0 });
                xy.push({ x: featureValue, y: height });
                svg.append("svg:path")
                    .attr("d", lineFunc(xy))
                    .attr("stroke", "blue")
                    .attr("stroke-width", 2)
                    .attr("fill", "none");
            };
            /**
            * Draw a Pie chart.
            */
            Plot.drawPie = function (pieRadius, data, parentId, colorScale, svgId) {
                if (parentId === void 0) { parentId = 'mcaPieChart'; }
                if (colorScale === void 0) { colorScale = 'Reds'; }
                if (svgId === void 0) { svgId = 'the_SVG_ID'; }
                Plot.clearSvg(svgId);
                if (!data)
                    return;
                var width = pieRadius, height = pieRadius, radius = Math.min(width, height) / 2, innerRadius = 0;
                var pie = d3.layout.pie()
                    .sort(null)
                    .value(function (d) { return d.weight; });
                var tip = d3.tip()
                    .attr('class', 'd3-tip')
                    .offset([0, 0])
                    .html(function (d) { return '<strong>' + d.data.label + ": </strong><span style='color:orangered'>" +
                    Math.round(d.data.weight * 100) + "%</span>"; });
                var arc = d3.svg.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(radius);
                var outlineArc = d3.svg.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(radius);
                var svg = d3.select('#' + parentId)
                    .append("svg")
                    .attr("id", svgId)
                    .attr("width", width)
                    .attr("height", height)
                    .attr("style", "display: block; margin: 0 auto;")
                    .append("g")
                    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
                // svg.call(tip);
                var colors = chroma.scale(colorScale).domain([0, data.length - 1], data.length);
                var path = svg.selectAll(".solidArc")
                    .data(pie(data))
                    .enter().append("path")
                    .attr("fill", function (d, i) { return d.data.color || colors(i).hex(); })
                    .attr("class", "solidArc")
                    .attr("stroke", "gray")
                    .attr("d", arc)
                    .on('mouseover', function (d, i) {
                    tip.show(d, i);
                })
                    .on('mouseout', tip.hide);
                var outerPath = svg.selectAll(".outlineArc")
                    .data(pie(data))
                    .enter().append("path")
                    .attr("fill", "none")
                    .attr("stroke", "gray")
                    .attr("class", "outlineArc")
                    .attr("d", outlineArc);
            };
            /**
            * Draw an Aster Pie chart, i.e. a pie chart with varying radius depending on the score,
            * where the maximum score of 100 equals the pie radius.
            * See http://bl.ocks.org/bbest/2de0e25d4840c68f2db1
            */
            Plot.drawAsterPlot = function (pieRadius, data, parentId, colorScale, svgId) {
                if (parentId === void 0) { parentId = 'mcaPieChart'; }
                if (colorScale === void 0) { colorScale = 'Reds'; }
                if (svgId === void 0) { svgId = 'the_SVG_ID'; }
                Plot.clearSvg(svgId);
                if (!data)
                    return;
                var width = pieRadius, height = pieRadius, radius = Math.min(width, height) / 2, innerRadius = 0.3 * radius;
                var pie = d3.layout.pie()
                    .sort(null)
                    .value(function (d) { return d.weight; });
                var tip = d3.tip()
                    .attr('class', 'd3-tip')
                    .offset([0, 0])
                    .html(function (d) { return '<strong>' + d.data.label + ': </strong> <span style="color:orangered">' +
                    Math.round(d.data.weight * 100) + '% x ' + Math.round(d.data.score) + '&nbsp; = ' +
                    Math.round(d.data.weight * d.data.score) + '</span>'; });
                var arc = d3.svg.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(function (d) { return (radius - innerRadius) * (d.data.score / 100.0) + innerRadius; });
                var outlineArc = d3.svg.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(radius);
                var svg = d3.select('#' + parentId)
                    .append('svg')
                    .attr('id', svgId)
                    .attr('width', width)
                    .attr('height', height)
                    .attr('style', 'display: block; margin: 0 auto;')
                    .append('g')
                    .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');
                try {
                    svg.call(tip);
                }
                catch (err) {
                    console.log('Error: ' + err.message);
                }
                var colors = chroma.scale(colorScale).domain([0, data.length - 1], data.length);
                var path = svg.selectAll('.solidArc')
                    .data(pie(data))
                    .enter().append('path')
                    .attr('fill', function (d, i) { return d.data.color || colors(i).hex(); })
                    .attr('class', 'solidArc')
                    .attr('stroke', 'gray')
                    .attr('d', arc)
                    .on('mouseover', function (d, i) {
                    tip.show(d, i);
                    // $rootScope.$broadcast('tooltipShown', { id: d.data.id });
                })
                    .on('mouseout', tip.hide);
                var outerPath = svg.selectAll('.outlineArc')
                    .data(pie(data))
                    .enter().append('path')
                    .attr('fill', 'none')
                    .attr('stroke', 'gray')
                    .attr('class', 'outlineArc')
                    .attr('d', outlineArc);
                // calculate the weighted mean score
                var totalWeight = 0;
                var totalScore = 0;
                data.forEach(function (p) {
                    totalWeight += p.weight;
                    totalScore += p.weight * p.score;
                });
                svg.append('svg:text')
                    .attr('class', 'aster-score')
                    .attr('dy', '.35em')
                    .attr('text-anchor', 'middle') // text-align: right
                    .text(Math.round(totalScore / totalWeight));
            };
            Plot.clearSvg = function (svgId) {
                var svgElement = d3.select('#' + svgId);
                if (svgElement)
                    svgElement.remove();
            };
            Plot.pieColors = ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"];
            return Plot;
        }());
        Helpers.Plot = Plot;
    })(Helpers = csComp.Helpers || (csComp.Helpers = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=Plot.js.map
var csComp;
(function (csComp) {
    var StringExt;
    (function (StringExt) {
        function isNullOrEmpty(s) {
            return !isNumber(s) && !s;
        }
        StringExt.isNullOrEmpty = isNullOrEmpty;
        /**
         * String formatting
         * 'Added {0} by {1} to your collection'.f(title, artist)
         * 'Your balance is {0} USD'.f(77.7)
         */
        function format(s) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var i = args.length;
            while (i--) {
                // "gm" = RegEx options for Global search (more than one instance) and for Multiline search
                s = s.replace(new RegExp('\\{' + i + '\\}', 'gm'), args[i]);
            }
            return s;
        }
        StringExt.format = format;
        ;
        /*
         * Returns true if we are dealing with a number, false otherwise.
         */
        function isDate(n) {
            return moment(n, moment.ISO_8601).isValid();
        }
        StringExt.isDate = isDate;
        /*
         * Returns true if we are dealing with a number, false otherwise.
         */
        function isNumber(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
        StringExt.isNumber = isNumber;
        /*
         * Returns true if we are dealing with a boolean, false otherwise.
         */
        function isBoolean(s) {
            return s === 'true' || s === 'false';
            //if (typeof s === 'boolean') return true;
        }
        StringExt.isBoolean = isBoolean;
        /*
         * Returns true if we are dealing with a array, false otherwise.
         */
        function isArray(s) {
            return s && s.constructor === Array;
        }
        StringExt.isArray = isArray;
        /*
         * Returns true if we are dealing with a bbcode, false otherwise.
         */
        function isBbcode(s) {
            return false;
            // if (s == null) return false;
            // return s.indexOf("[b]") > 0 || s.indexOf("[i]") > 0 || s.indexOf("[url") > 0;
        }
        StringExt.isBbcode = isBbcode;
    })(StringExt = csComp.StringExt || (csComp.StringExt = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=StringExt.js.map
var StringFormat;
(function (StringFormat) {
    /**
     * Config
     */
    var moduleName = 'csComp';
    try {
        StringFormat.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        StringFormat.myModule = angular.module(moduleName, []);
    }
    /**
     * Directive to display a feature's properties in a panel.
     *
     * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
     * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
     */
    StringFormat.myModule.directive('stringy', ['$compile',
        function ($compile) {
            return {
                require: "ngModel",
                terminal: false,
                restrict: 'A',
                scope: {},
                link: function (scope, element, attr, ngModel) {
                    scope.$watch(function () {
                        return ngModel.$modelValue;
                    }, function (modelValue) {
                        element[0].innerText = String.format("{0:0,0}", ngModel.$modelValue);
                    });
                }
            };
        }
    ]);
})(StringFormat || (StringFormat = {}));
//# sourceMappingURL=StringFormatDirective.js.map
/*!
 * string_score.js: String Scoring Algorithm 0.1.22
 *
 * http://joshaven.com/string_score
 * https://github.com/joshaven/string_score
 *
 * Copyright (C) 2009-2014 Joshaven Potter <yourtech@gmail.com>
 * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score
 * MIT License: http://opensource.org/licenses/MIT
 *
 * Date: Tue Mar 1 2011
 * Updated: Tue Mar 10 2015
*/
/*jslint nomen:true, white:true, browser:true,devel:true */
/**
 * Scores a string against another string.
 *    'Hello World'.score('he');         //=> 0.5931818181818181
 *    'Hello World'.score('Hello');    //=> 0.7318181818181818
 */
String.prototype.score = function (word, fuzziness) {
    'use strict';
    // If the string is equal to the word, perfect match.
    if (this === word) {
        return 1;
    }
    //if it's not a perfect match and is empty return 0
    if (word === '') {
        return 0;
    }
    var runningScore = 0, charScore, finalScore, string = this, lString = string.toLowerCase(), strLength = string.length, lWord = word.toLowerCase(), wordLength = word.length, idxOf, startAt = 0, fuzzies = 1, fuzzyFactor, i;
    // Cache fuzzyFactor for speed increase
    if (fuzziness) {
        fuzzyFactor = 1 - fuzziness;
    }
    // Walk through word and add up scores.
    // Code duplication occurs to prevent checking fuzziness inside for loop
    if (fuzziness) {
        for (i = 0; i < wordLength; i += 1) {
            // Find next first case-insensitive match of a character.
            idxOf = lString.indexOf(lWord[i], startAt);
            if (idxOf === -1) {
                fuzzies += fuzzyFactor;
            }
            else {
                if (startAt === idxOf) {
                    // Consecutive letter & start-of-string Bonus
                    charScore = 0.7;
                }
                else {
                    charScore = 0.1;
                    // Acronym Bonus
                    // Weighing Logic: Typing the first character of an acronym is as if you
                    // preceded it with two perfect character matches.
                    if (string[idxOf - 1] === ' ') {
                        charScore += 0.8;
                    }
                }
                // Same case bonus.
                if (string[idxOf] === word[i]) {
                    charScore += 0.1;
                }
                // Update scores and startAt position for next round of indexOf
                runningScore += charScore;
                startAt = idxOf + 1;
            }
        }
    }
    else {
        for (i = 0; i < wordLength; i += 1) {
            idxOf = lString.indexOf(lWord[i], startAt);
            if (-1 === idxOf) {
                return 0;
            }
            if (startAt === idxOf) {
                charScore = 0.7;
            }
            else {
                charScore = 0.1;
                if (string[idxOf - 1] === ' ') {
                    charScore += 0.8;
                }
            }
            if (string[idxOf] === word[i]) {
                charScore += 0.1;
            }
            runningScore += charScore;
            startAt = idxOf + 1;
        }
    }
    // Reduce penalty for longer strings.
    finalScore = 0.5 * (runningScore / strLength + runningScore / wordLength) / fuzzies;
    if ((lWord[0] === lString[0]) && (finalScore < 0.85)) {
        finalScore += 0.15;
    }
    return finalScore;
};
//# sourceMappingURL=StringScore.js.map
var csComp;
(function (csComp) {
    var Helpers;
    (function (Helpers) {
        /**
         * Either get the color from the string value by using the active legend, or else return
         * the current value (e.g. assuming that the current property contains a color).
         */
        function getColorFromStringValue(v, gs) {
            if (gs.activeLegend) {
                var defaultcolor = '#000000';
                var l = gs.activeLegend;
                var s = l.id;
                var n = l.legendEntries.length;
                if (n === 0)
                    return (defaultcolor);
                if (l.legendKind.toLowerCase() === 'discretestrings') {
                    var i = 0;
                    while (i < n) {
                        var e = l.legendEntries[i];
                        if (v === e.stringValue) {
                            return e.color;
                        }
                        i++;
                    }
                    return defaultcolor;
                }
                return defaultcolor;
            }
            return v;
        }
        Helpers.getColorFromStringValue = getColorFromStringValue;
        function getImageUri(ft) {
            if (!ft)
                return;
            var iconUri = (ft && ft.style && ft.style.iconUri) ? ft.style.iconUri : 'bower_components/csweb/dist-bower/images/marker.png';
            if (iconUri.indexOf('{') >= 0)
                iconUri = iconUri.replace('{', '').replace('}', '');
            if (ft && ft.style != null && ft.style.drawingMode != null && ft.style.drawingMode.toLowerCase() != "point") {
                if (iconUri.indexOf('_Media') < 0) {
                    return iconUri;
                }
                else {
                    return 'cs/images/polygon.png';
                }
            }
            else if (ft && ft.style != null && iconUri != null) {
                return iconUri;
            }
            else {
                return 'bower_components/csweb/dist-bower/images/marker.png';
            }
        }
        Helpers.getImageUri = getImageUri;
        function getColorFromStringLegend(v, l, defaultcolor) {
            if (defaultcolor === void 0) { defaultcolor = '#000000'; }
            var n = l.legendEntries.length;
            if (n === 0)
                return (defaultcolor);
            if (l.legendKind.toLowerCase() === 'discretestrings') {
                var i = 0;
                while (i < n) {
                    var e = l.legendEntries[i];
                    if (v === e.stringValue) {
                        return e.color;
                    }
                    i++;
                }
                return defaultcolor;
            }
            return defaultcolor;
        }
        Helpers.getColorFromStringLegend = getColorFromStringLegend;
        function getColorFromLegend(v, l, defaultcolor) {
            if (defaultcolor === void 0) { defaultcolor = '#000000'; }
            var n = l.legendEntries.length;
            if (n === 0)
                return (defaultcolor);
            if (l.legendKind.toLowerCase() === 'discretestrings') {
                var i = 0;
                while (i < n) {
                    var e = l.legendEntries[i];
                    if (v.toString() === e.stringValue) {
                        return e.color;
                    }
                    i++;
                }
                return defaultcolor;
            }
            var e1 = l.legendEntries[0]; // first
            var e2 = l.legendEntries[n - 1]; // last
            if (l.legendKind.toLowerCase() === 'interpolated') {
                // interpolate between two colors
                if (v < e1.value)
                    return e1.color;
                if (v > e2.value)
                    return e2.color;
                var i = 0;
                while (i < n - 1) {
                    e1 = l.legendEntries[i];
                    e2 = l.legendEntries[i + 1];
                    if ((v >= e1.value) && (v <= e2.value)) {
                        var bezInterpolator = chroma.bezier([e1.color, e2.color]);
                        var r = bezInterpolator((v - e1.value) / (e2.value - e1.value)).hex();
                        return r;
                    }
                    i++;
                }
                return (defaultcolor);
            }
            if (l.legendKind.toLowerCase() === 'discrete') {
                if (e1.interval && e2.interval && typeof e1.interval.min !== 'undefined' && typeof e2.interval.max !== 'undefined') {
                    if (v < e1.interval.min)
                        return e1.color;
                    if (v > e2.interval.max)
                        return e2.color;
                }
                var i = 0;
                while (i < n) {
                    var e = l.legendEntries[i];
                    if (e.value) {
                        if (v === e.value)
                            return e.color;
                    }
                    else if (e.interval && (v >= e.interval.min) && (v <= e.interval.max)) {
                        return e.color;
                    }
                    i++;
                }
                return defaultcolor;
            }
            return defaultcolor;
        }
        Helpers.getColorFromLegend = getColorFromLegend;
        function getColor(v, gs) {
            if (gs.activeLegend) {
                return getColorFromLegend(v, gs.activeLegend);
            }
            var max = gs.info.userMax || gs.info.max;
            var min = gs.info.userMin || gs.info.min;
            if (v > max)
                return gs.colors[gs.colors.length - 1];
            if (v < min)
                return gs.colors[0];
            //var bezInterpolator = chroma.interpolate.bezier(gs.colors);
            //var r = bezInterpolator((v - gs.info.sdMin) / (gs.info.sdMax - gs.info.sdMin)).hex();
            //return r;
            var color = d3.scale.linear()
                .domain([min, max]) //domain and range should have the same arraylength!!!
                .range(gs.colors);
            var hexColor = color(v).toString();
            return hexColor;
        }
        Helpers.getColor = getColor;
        /**
         * Extract a valid color string, without transparency.
         */
        function getColorString(color, defaultColor) {
            if (defaultColor === void 0) { defaultColor = '#000000'; }
            if (!color)
                return defaultColor;
            if (color === 'transparent')
                return '#00000000';
            if (color.length === 4 || color.length === 7)
                return color;
            if (color.length === 9)
                return '#' + color.substr(3, 6);
            return defaultColor;
        }
        Helpers.getColorString = getColorString;
    })(Helpers = csComp.Helpers || (csComp.Helpers = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=StyleHelpers.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var FSM;
(function (FSM) {
    /**
     * Transition grouping to faciliate fluent api
     * @class Transitions<T>
     */
    var Transitions = (function () {
        function Transitions(fsm) {
            this.fsm = fsm;
        }
        /**
         * Specify the end state(s) of a transition function
         * @method to
         * @param ...states {T[]}
         */
        Transitions.prototype.to = function () {
            var states = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                states[_i - 0] = arguments[_i];
            }
            this.toStates = states;
            return this.fsm.addTransitions(this);
        };
        Transitions.prototype.toAny = function (states) {
            var toStates = [];
            for (var s in states) {
                if (states.hasOwnProperty(s)) {
                    toStates.push(states[s]);
                }
            }
            this.toStates = toStates;
            this.fsm.addTransitions(this);
        };
        return Transitions;
    }());
    FSM.Transitions = Transitions;
    /**
     * Internal representation of a transition function
     * @class TransitionFunction<T>
     */
    var TransitionFunction = (function () {
        // public events: {
        //     [trigger: number]: {
        //         callback: Function,
        //         args: any[]
        //     }
        // }[];
        function TransitionFunction(fsm, from, to) {
            this.fsm = fsm;
            this.from = from;
            this.to = to;
        }
        return TransitionFunction;
    }());
    FSM.TransitionFunction = TransitionFunction;
    var TransitionFunctions = (function (_super) {
        __extends(TransitionFunctions, _super);
        function TransitionFunctions(fsm) {
            _super.call(this);
            this.fsm = fsm;
        }
        TransitionFunctions.prototype.on = function (trigger, callback) {
            var _this = this;
            this.forEach(function (t) {
                if (callback)
                    _this.fsm.on(t.to, callback);
                _this.fsm.addEvent(trigger, t.from, t.to);
            });
        };
        return TransitionFunctions;
    }(Array));
    FSM.TransitionFunctions = TransitionFunctions;
    /***
     * A simple finite state machine implemented in TypeScript, the templated argument is meant to be used
     * with an enumeration.
     * @class FiniteStateMachine<T>
     */
    var FiniteStateMachine = (function () {
        /**
         * @constructor
         * @param startState {T} Intial starting state
         */
        function FiniteStateMachine(startState) {
            this._transitionFunctions = [];
            this._onCallbacks = {};
            this._exitCallbacks = {};
            this._enterCallbacks = {};
            this._triggers = {};
            this.currentState = startState;
            this._startState = startState;
        }
        FiniteStateMachine.prototype.addTransitions = function (fcn) {
            var _this = this;
            var newTransitions = new TransitionFunctions(this);
            fcn.fromStates.forEach(function (from) {
                fcn.toStates.forEach(function (to) {
                    // self transitions are invalid and don't add duplicates
                    if (from !== to && !_this._validTransition(from, to)) {
                        newTransitions.push(new TransitionFunction(_this, from, to));
                    }
                });
            });
            newTransitions.forEach(function (t) { return _this._transitionFunctions.push(t); });
            return newTransitions;
        };
        FiniteStateMachine.prototype.addEvent = function (trigger, fromState, toState) {
            var fr = fromState.toString();
            if (!this._triggers[fr])
                this._triggers[fr] = {};
            this._triggers[fr][trigger.toString()] = toState;
        };
        FiniteStateMachine.prototype.trigger = function (trigger) {
            if (typeof trigger === 'undefined')
                return;
            var t = trigger.toString();
            var current = this.currentState.toString();
            if (!this._triggers.hasOwnProperty(current) || !this._triggers[current].hasOwnProperty(t))
                return;
            this.go(this._triggers[current][t]);
        };
        /**
         * Listen for the transition to this state and fire the associated callback
         * @method on
         * @param state {T} State to listen to
         * @param callback {fcn} Callback to fire
         */
        FiniteStateMachine.prototype.on = function (state, callback) {
            var key = state.toString();
            if (!this._onCallbacks[key]) {
                this._onCallbacks[key] = [];
            }
            this._onCallbacks[key].push(callback);
            return this;
        };
        /**
            * Listen for the transition to this state and fire the associated callback, returning
            * false in the callback will block the transition to this state.
            * @method on
            * @param state {T} State to listen to
            * @param callback {fcn} Callback to fire
            */
        FiniteStateMachine.prototype.onEnter = function (state, callback) {
            var key = state.toString();
            if (!this._enterCallbacks[key]) {
                this._enterCallbacks[key] = [];
            }
            this._enterCallbacks[key].push(callback);
            return this;
        };
        /**
            * Listen for the transition to this state and fire the associated callback, returning
            * false in the callback will block the transition from this state.
            * @method on
            * @param state {T} State to listen to
            * @param callback {fcn} Callback to fire
            */
        FiniteStateMachine.prototype.onExit = function (state, callback) {
            var key = state.toString();
            if (!this._exitCallbacks[key]) {
                this._exitCallbacks[key] = [];
            }
            this._exitCallbacks[key].push(callback);
            return this;
        };
        /**
            * Declares the start state(s) of a transition function, must be followed with a '.to(...endStates)'
            * @method from
            * @param ...states {T[]}
            */
        FiniteStateMachine.prototype.from = function () {
            var states = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                states[_i - 0] = arguments[_i];
            }
            var _transition = new Transitions(this);
            _transition.fromStates = states;
            return _transition;
        };
        FiniteStateMachine.prototype.fromAny = function (states) {
            var fromStates = [];
            for (var s in states) {
                if (states.hasOwnProperty(s)) {
                    fromStates.push(states[s]);
                }
            }
            var _transition = new Transitions(this);
            _transition.fromStates = fromStates;
            return _transition;
        };
        FiniteStateMachine.prototype._validTransition = function (from, to) {
            return this._transitionFunctions.some(function (tf) {
                return (tf.from === from && tf.to === to);
            });
        };
        /**
          * Check whether a transition to a new state is valide
          * @method canGo
          * @param state {T}
          */
        FiniteStateMachine.prototype.canGo = function (state) {
            return this.currentState === state || this._validTransition(this.currentState, state);
        };
        /**
          * Transition to another valid state
          * @method go
          * @param state {T}
          */
        FiniteStateMachine.prototype.go = function (state) {
            if (!this.canGo(state)) {
                throw new Error('Error no transition function exists from state ' + this.currentState.toString() + ' to ' + state.toString());
            }
            this._transitionTo(state);
        };
        /**
         * This method is availble for overridding for the sake of extensibility.
         * It is called in the event of a successful transition.
         * @method onTransition
         * @param from {T}
         * @param to {T}
         */
        FiniteStateMachine.prototype.onTransition = function (from, to) {
            // pass, does nothing untill overridden
        };
        /**
         * Reset the finite state machine back to the start state, DO NOT USE THIS AS A SHORTCUT for a transition.
         * This is for starting the fsm from the beginning.
         * @method reset
         */
        FiniteStateMachine.prototype.reset = function () {
            this.currentState = this._startState;
        };
        FiniteStateMachine.prototype._transitionTo = function (state) {
            var _this = this;
            if (!this._exitCallbacks[this.currentState.toString()]) {
                this._exitCallbacks[this.currentState.toString()] = [];
            }
            if (!this._enterCallbacks[state.toString()]) {
                this._enterCallbacks[state.toString()] = [];
            }
            if (!this._onCallbacks[state.toString()]) {
                this._onCallbacks[state.toString()] = [];
            }
            var canExit = this._exitCallbacks[this.currentState.toString()].reduce(function (accum, next) {
                return accum && next.call(_this, state);
            }, true);
            var canEnter = this._enterCallbacks[state.toString()].reduce(function (accum, next) {
                return accum && next.call(_this, _this.currentState);
            }, true);
            if (canExit && canEnter) {
                var old = this.currentState;
                this.currentState = state;
                this._onCallbacks[this.currentState.toString()].forEach(function (fcn) {
                    fcn.call(_this, old, state);
                });
                this.onTransition(old, state);
            }
        };
        return FiniteStateMachine;
    }());
    FSM.FiniteStateMachine = FiniteStateMachine;
})(FSM || (FSM = {}));
//# sourceMappingURL=typestate.js.map
var csComp;
(function (csComp) {
    (function (FileType) {
        FileType[FileType["Js"] = 0] = "Js";
        FileType[FileType["Css"] = 1] = "Css";
    })(csComp.FileType || (csComp.FileType = {}));
    var FileType = csComp.FileType;
    var Utils = (function () {
        function Utils() {
        }
        Utils.twoDigitStr = function (v) {
            var s;
            s = v.toString();
            if (s.length === 1) {
                s = '0' + s;
            }
            return (s);
        };
        ;
        /**
        * Load a JavaScript or CSS file dynamically by adding it to the end of the HEAD section in your document.
        * See also: http://www.javascriptkit.com/javatutors/loadjavascriptcss.shtml
        */
        Utils.loadJsCssfile = function (filename, filetype, callback) {
            if (Utils.loadedFiles.indexOf(filename) > 0)
                return;
            Utils.loadedFiles.push(filename);
            switch (filetype) {
                case FileType.Js:
                    var fileRef = document.createElement('script');
                    fileRef.setAttribute("type", "text/javascript");
                    fileRef.setAttribute("src", filename);
                    if (callback) {
                        fileRef.onload = function (evt) {
                            callback(evt);
                        };
                    }
                    document.getElementsByTagName("head")[0].appendChild(fileRef);
                    break;
                case FileType.Css:
                    var linkRef = document.createElement("link");
                    linkRef.setAttribute("rel", "stylesheet");
                    linkRef.setAttribute("type", "text/css");
                    linkRef.setAttribute("href", filename);
                    if (callback) {
                        linkRef.onload = function (evt) {
                            callback(evt);
                        };
                    }
                    document.getElementsByTagName("head")[0].appendChild(linkRef);
                    break;
            }
        };
        Utils.loadedFiles = [];
        return Utils;
    }());
    csComp.Utils = Utils;
})(csComp || (csComp = {}));
//# sourceMappingURL=Utils.js.map
var LayersDirective;
(function (LayersDirective) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        LayersDirective.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        LayersDirective.myModule = angular.module(moduleName, []);
    }
    LayersDirective.myModule.directive('validtitle', function () {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function (scope, elm, attrs, ctrl) {
                var validator = function (value) {
                    var v = (typeof value === 'undefined') || (value.length === 0);
                    if (!v) {
                        if (value.match(/^[a-zA-Z0-9\s]*$/)) {
                            ctrl.$setValidity('validtitle', true);
                            return value;
                        }
                        else {
                            ctrl.$setValidity('validtitle', false);
                            return undefined;
                        }
                    }
                    else {
                        ctrl.$setValidity('validtitle', false);
                        return undefined;
                    }
                };
                ctrl.$parsers.unshift(validator);
                ctrl.$formatters.unshift(validator);
            }
        };
    });
    LayersDirective.myModule.directive('validfeaturetypeid', function () {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function (scope, elm, attrs, ctrl) {
                var validator = function (value) {
                    var v = (typeof value === 'undefined') || (value.length === 0);
                    if (!v) {
                        var ft = scope.featureType;
                        if (!ft._isInitialized && ft._resource.featureTypes.hasOwnProperty(value)) {
                            ctrl.$setValidity('validfeaturetypeid', false);
                            return undefined;
                        }
                        else {
                            ctrl.$setValidity('validfeaturetypeid', true);
                            return value;
                        }
                    }
                    else {
                        ctrl.$setValidity('validfeaturetypeid', false);
                        return undefined;
                    }
                };
                ctrl.$parsers.unshift(validator);
                ctrl.$formatters.unshift(validator);
            }
        };
    });
    LayersDirective.myModule.directive('duplicategroup', function () {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function (scope, elm, attrs, ctrl) {
                var validate = function (viewValue) {
                    if (typeof viewValue === 'undefined' || viewValue === "") {
                        ctrl.$setValidity('duplicategroup', false);
                        return undefined;
                    }
                    var noduplicate = scope.$parent.vm.groups.every(function (g) { return g.title !== viewValue; });
                    ctrl.$setValidity('duplicategroup', noduplicate);
                    return viewValue;
                };
                ctrl.$parsers.unshift(validate);
                ctrl.$formatters.unshift(validate);
            }
        };
    });
})(LayersDirective || (LayersDirective = {}));
//# sourceMappingURL=ValidationDirectives.js.map
var Translations;
(function (Translations) {
    var English = (function () {
        function English() {
        }
        English.locale = {
            CANCEL_BTN: 'Cancel',
            OK_BTN: 'OK',
            FROM: 'from',
            TO: 'to',
            ZOOM_LEVEL_LOW: 'Zoom level too low',
            ZOOM_IN_FOR_CONTOURS: 'Zoom in to show contours',
            NAVIGATE: {
                TITLE: 'Search results'
            },
            CREATE_SCATTER: 'Create scatter with',
            EXPAND_ALL: 'Expand all',
            COLLAPSE_ALL: 'Collapse all',
            SELECT_ALL: 'Select all',
            DESELECT_ALL: 'Deselect all',
            CHOOSE_DROPDOWN: 'Choose...',
            ENABLE_LOCATION_FILTER: 'Enable location filter',
            DISABLE_LOCATION_FILTER: 'Disable location filter',
            SELECT_A_FEATURE: 'Select a feature',
            SELECT_FEATURE_FOR_WIDGET: 'Please select a feature to show the widget.',
            SELECT_FEATURE_FOR_STYLE: 'Please select a feature to before setting the style.',
            SELECT_LAYER_GROUP: 'Select Layers',
            SELECT_CATEGORY: 'Select Category',
            SELECT_PROPERTIES: 'Select Properties',
            NO_RELATIONS_FOUND: 'No relations can be shown for the selected feature. Either the zoom level is too low, there are too many features in the view or there are no relations defined.',
            BASESTYLES: 'Baselayers',
            MAP: 'Maps',
            MAP_LABEL: 'Map',
            TABLE_LABEL: 'Table',
            LAYERS: 'Layers',
            DIRECTORY: 'Available layers',
            CREATELAYER: 'Create new layer',
            ADDFEATURES: 'Add items',
            ADDTYPE: 'Add new type',
            DONE: 'done',
            FILTERS: 'Filters',
            FILTER_INFO: 'At the moment, no filters have been selected. In order to add a filter, click on an icon or area on the map, and click on the filter icon (<span class="fa fa-filter"></span>) in the right menu. This will create a filter for the selected property.',
            STYLES: 'Styles',
            STYLE_INFO: 'At the moment, no style has been selected. In order to add a style, click on an icon or area on the map, and click on the style icon (<span class="smallStyleIcon"></span>) in the right menu. This will create a filter for the selected property.',
            FEATURES: 'Features',
            LEGEND: 'Legend',
            SEARCH: 'Search',
            HIDE_PANEL: 'Hide this panel',
            EDIT_INDICATORS: 'Edit indicators',
            RELATED_FEATURES: 'Show related features',
            FEATURE_INFO: 'Show information about the selected feature',
            MAP_FEATURES: 'Map features',
            NEARBY_FEATURES: 'Nearby features',
            TOGGLE_MENU: 'Toggle menu visibility',
            DASHBOARD_SELECTION: 'Dashboard selection',
            SETTINGS: 'Settings',
            SPEEDS_TAOUFIK: 'speed colors Taoufik',
            SPEEDS_GOOGLEMAPS: 'speed colors Google Maps',
            VERWARMINGSSYSTEEM: 'Heating system',
            PERCENTAGES_V1: 'percentages v1',
            ORANGE_RED: 'orange - red',
            WHITE_RED: 'white - red',
            RED_WHITE: 'red - white',
            RED_WHITE_BLUE: 'red - white - blue',
            GREEN_RED: 'green - red',
            RED_GREEN: 'red - green',
            BLUE_RED: 'blue - red',
            RED_BLUE: 'red - blue',
            WHITE_BLUE: 'white - blue',
            BLUE_WHITE: 'blue - white',
            WHITE_GREEN: 'white - green',
            GREEN_WHITE: 'green - white',
            WHITE_ORANGE: 'white - orange',
            ORANGE_WHITE: 'orange - white',
            SAVE: 'save',
            CONFIG: 'config',
            EDIT: 'edit',
            APPLY: 'apply',
            REMOVE: 'remove',
            STATS: {
                COUNT: '#',
                COUNT_TOOLTIP: 'Count of selected items',
                MIN: 'min',
                MIN_TOOLTIP: 'Minimum of selected items',
                MAX: 'max',
                MAX_TOOLTIP: 'Maximum of selected items',
                MEAN: 'µ',
                MEAN_TOOLTIP: 'Mean of selected items',
                SUM: 'Σ',
                SUM_TOOLTIP: 'Sum of selected items'
            },
            UTILS: {
                FILTER: 'Use this property as filter',
                STYLE: 'Use this property as style',
                STATS: 'Show property statistics',
                CHART: 'Show property in time',
                CONFIG: 'Configure property'
            },
            EXPERTMODE: {
                BEGINNER: 'Novice',
                INTERMEDIATE: 'Intermediate',
                EXPERT: 'Expert',
                ADMIN: 'Admin',
                EXPLANATION: 'Select your expertise in order to unlock more functionality.'
            },
            LAYER_SERVICE: {
                RELOAD_PROJECT_TITLE: 'Data is reloaded',
                RELOAD_PROJECT_MSG: 'After switching the language, we need to reload all the map data. Our appologies for the inconvenience.'
            },
            HEATMAP: {
                NAME: 'Heatmaps',
                DESCRIPTION: '<h4>Heatmap</h4><p  style="text-align: left; margin-left:5px;">Heatmap highlights areas on the map that fulfill multiple selected criteria.',
                INFO: 'At the moment, no map layers are loaded that contain a heatmap. Open another map layer to use it.',
                INFO_EXPERT: 'At the moment, no map layers are loaded that contain a heatmap. Open another map layer to use it, or create a new heatmap using the wizard.',
                SHOW_FEATURE_MSG: 'Select a feature on the map to see the heatmap.',
                TOTAL_RESULT: 'Combined result',
                DELETE_MSG: 'Delete "{0}"',
                DELETE_MSG2: 'Are you sure?',
                EDITOR_TITLE: 'Heatmap Editor',
                MAIN_FEATURE: 'Select the main feature',
                PROPERTIES: 'Select the properties',
                INTENSITY_SCALE: 'Intensity scale',
                RESOLUTION: 'Resolution',
                TITLE: 'Title... *',
                TITLE_TAG: 'Title',
                SCALE_MIN_TITLE: '[Min. scale]',
                SCALE_MAX_TITLE: '[Max. scale]',
                MIN_MAX_ZOOM: 'Min./Max. zoom',
                AT_LOCATION_VALUE: '[Weight at location]',
                DISTANCE_MAX_VALUE: '[Ideal distance]',
                LOST_INTEREST_VALUE: '[Lost interest distance]',
                LINEAR_ASC_DESC: 'Linearly increasing, then decreasing function.',
                ADD_HEATMAP: 'Add a new heatmap.',
                DELETE_HEATMAP: 'Delete the heatmap.',
                EDIT_HEATMAP: 'Edit the heatmap.',
                EXPORT_HEATMAP: 'Export the heatmap.'
            },
            MCA: {
                NAME: 'Multi-Criteria Analysis (MCA)',
                DESCRIPTION: '<h4>Multi-Criteria Analysis</h4><p  style="text-align: left; margin-left:5px;">MCA, is a method that combines multiple properties of a feature on the map into a new property. It achieves this by:<ol><li>Scaling each property to a range between 0 (no value) and 1 (maximum value).</li><li>Weighing each property relative to the others, where a weight less than 0 indicates you wish to avoid it, 0 is ignored, and a value greater than 0 is prefered.</li></ol> In fact, it is a kind of linear regression.',
                INFO: 'At the moment, no map layers are loaded that contain a multi-criteria analysis. Open another map layer to see it.',
                INFO_EXPERT: 'At the moment, no map layers are loaded that contain a multi-criteria analysis. Open another map layer to use it, or create a new MCA using the wizard.',
                SHOW_FEATURE_MSG: 'Select a feature on the map to see the effects of the Multi-Criteria Analysis (MCA).',
                TOTAL_RESULT: 'Combined result',
                DELETE_MSG: 'Delete "{0}"',
                DELETE_MSG2: 'Are you sure?',
                HAS_CATEGORY: '  Has category? ',
                HAS_RANK: '  Include rank? ',
                EDITOR_TITLE: 'MCA Editor',
                MAIN_FEATURE: 'Select the main feature',
                PROPERTIES: 'Select the properties',
                INCLUDE_RANK: '  Show rank? ',
                RANK_TITLE: '[Rank title...]',
                TITLE: 'Title... *',
                CATEGORY_MSG: '[Category...]',
                TOGGLE_SPARKLINE: 'Show or hide bar charts and scoring function.',
                SCALE_MIN_TITLE: '[Min. scale]',
                SCALE_MAX_TITLE: '[Max. scale]',
                MIN_VALUE: '[Minimum (\u03BC-2\u03C3)]',
                MAX_VALUE: '[Maximum (\u03BC+2\u03C3)]',
                MIN_CUTOFF_VALUE: '[Ignore when below this value]',
                MAX_CUTOFF_VALUE: '[Ignore when above this value]',
                LINEAR: 'Linearly increasing function between min and max.',
                SIGMOID: 'Tangentially increasing function between min and max',
                GAUSSIAN: 'Normal distribution increasing function between min and max.',
                ADD_MCA: 'Add a new MCA.',
                DELETE_MCA: 'Delete the MCA.',
                EDIT_MCA: 'Edit the MCA.',
                SET_STYLE: 'Set style'
            },
            PROJECTSETTINGS: {
                TITLE: 'Project Settings',
                DESCRIPTION: 'Settings'
            },
            CHOOSE_CATEGORY: 'Choose category...',
            SHOW5: 'Show 5 items',
            SHOW10: 'Show 10 items',
            SHOW15: 'Show 15 items',
            SHOW20: 'Show 20 items',
            SHOW25: 'Show 25 items',
            SHOW30: 'Show 30 items',
            SHOW35: 'Show 35 items',
            SHOW40: 'Show 40 items',
            RISK_DIAGRAM_FOR: 'Risk-diagram for a ',
            SAVE_FEATURE_DEPENDENCIES: 'Save dependencies to the selected feature only',
            SAVE_FEATURETYPE_DEPENDENCIES: 'Save dependencies to all features of this type',
            SAVE_MARVEL: 'Save ',
            SAVE_EVERY_MARVEL: 'Save every ',
            MARVEL_WATER_LEVEL: 'Water level [m]',
            MARVEL_UPS_DURATION: 'UPS duration [mins]',
            MARVEL_FEATURE_DEP: 'Depends on',
            STATE: 'State',
            EVENT_INFO: 'Show a list of events',
            CLEAR_EVENTS: 'Clear event log',
            SEARCH_PLACEHOLDER: 'Municipality, address, ...'
        };
        return English;
    }());
    Translations.English = English;
})(Translations || (Translations = {}));
//# sourceMappingURL=locale-en.js.map
var Translations;
(function (Translations) {
    var French = (function () {
        function French() {
        }
        French.locale = {
            "CANCEL_BTN": "Annuler",
            "OK_BTN": "D'accord",
            "FROM": "de",
            "TO": "à",
            "NAVIGATE": "Début",
            "CREATE_SCATTER": "Créer scatter avec",
            "EXPAND_ALL": "Développer tout",
            "COLLAPSE_ALL": "Réduire tout",
            "SELECT_ALL": "Sélectionner tout",
            "DESELECT_ALL": "Tout déselectionner",
            "CHOOSE_DROPDOWN": "Choisir...",
            "ENABLE_LOCATION_FILTER": "Activez le filtre de localisation",
            "DISABLE_LOCATION_FILTER": "filtre de localisation Désactiver",
            "SELECT_A_FEATURE": "Sélectionnez une fonction",
            "SELECT_FEATURE_FOR_WIDGET": "S'il vous plaît sélectionner une fonction pour afficher le widget.",
            "SELECT_FEATURE_FOR_STYLE": "S'il vous plaît sélectionner une fonction à avant de définir le style.",
            "SELECT_LAYER_GROUP": "Sélectionner les couches",
            "SELECT_CATEGORY": "Choisir une catégorie",
            "SELECT_PROPERTIES": "Sélectionnez Propriétés",
            "NO_RELATIONS_FOUND": "Aucune relation ne peuvent être affichés pour la fonction sélectionnée. ",
            "BASESTYLES": "Couches de base",
            "MAP": "Cartes",
            "MAP_LABEL": "Carte",
            "TABLE_LABEL": "Table",
            "LAYERS": "Couches",
            "DIRECTORY": "couches disponibles",
            "CREATELAYER": "Créer un nouveau calque",
            "ADDFEATURES": "Ajouter des éléments",
            "ADDTYPE": "Ajouter nouveau type",
            "DONE": "terminé",
            "FILTERS": "Filtres",
            "FILTER_INFO": "À l'heure actuelle, aucun filtre ont été sélectionnés. ",
            "STYLES": "modes",
            "STYLE_INFO": "À l'heure actuelle, aucun style a été sélectionné. ",
            "FEATURES": "Caractéristiques",
            "LEGEND": "Légende",
            "SEARCH": "Chercher",
            "HIDE_PANEL": "Cachez ce panneau",
            "EDIT_INDICATORS": "Modifier les indicateurs",
            "RELATED_FEATURES": "Afficher les caractéristiques liées",
            "FEATURE_INFO": "Affiche des informations sur la fonction sélectionnée",
            "MAP_FEATURES": "caractéristiques de la carte",
            "NEARBY_FEATURES": "caractéristiques à proximité",
            "TOGGLE_MENU": "Menu Basculer la visibilité",
            "DASHBOARD_SELECTION": "sélection de tableau de bord",
            "SETTINGS": "Paramètres",
            "SPEEDS_GOOGLEMAPS": "couleurs de vitesse Google Maps",
            "VERWARMINGSSYSTEEM": "Système de chauffage",
            "PERCENTAGES_V1": "pourcentages v1",
            "ORANGE_RED": "rouge-orange",
            "WHITE_RED": "blanc rouge",
            "RED_WHITE": "rouge blanc",
            "RED_WHITE_BLUE": "rouge - blanc - bleu",
            "GREEN_RED": "vert rouge",
            "RED_GREEN": "rouge vert",
            "BLUE_RED": "bleu rouge",
            "RED_BLUE": "rouge Bleu",
            "WHITE_BLUE": "blanc bleu",
            "BLUE_WHITE": "bleu blanc",
            "WHITE_GREEN": "blanc - vert",
            "GREEN_WHITE": "vert - blanc",
            "WHITE_ORANGE": "blanc - orange,",
            "ORANGE_WHITE": "d'orange - blanc",
            "SAVE": "enregistrer",
            "CONFIG": "config",
            "EDIT": "modifier",
            "APPLY": "appliquer",
            "REMOVE": "retirer",
            "STATS": {
                "COUNT_TOOLTIP": "Décompte des éléments sélectionnés",
                "COUNT": "#",
                "MAX_TOOLTIP": "Maximum d'éléments sélectionnés",
                "MEAN_TOOLTIP": "Moyenne des éléments sélectionnés",
                "SUM_TOOLTIP": "Somme des éléments sélectionnés",
                "MIN_TOOLTIP": "Minimum d'éléments sélectionnés",
                "MAX": "max",
                "MIN": "min",
                "SUM": "Î £",
                "MEAN": ", mu"
            },
            "UTILS": {
                "STATS": "Voir les statistiques de l'immobilier",
                "STYLE": "Utilisez cette propriété que le style",
                "CONFIG": "Configurer la propriété",
                "FILTER": "Utilisez cette propriété comme filtre",
                "CHART": "Voir la propriété dans le temps"
            },
            "EXPERTMODE": {
                "ADMIN": "Administrateur",
                "INTERMEDIATE": "Intermédiaire",
                "BEGINNER": "Novice",
                "EXPERT": "Expert",
                "EXPLANATION": "Sélectionnez votre expertise afin de débloquer plus de fonctionnalités."
            },
            "LAYER_SERVICE": {
                "RELOAD_PROJECT_MSG": "Après le passage de la langue, nous avons besoin de recharger toutes les données cartographiques. ",
                "RELOAD_PROJECT_TITLE": "Les données sont rechargées"
            },
            "HEATMAP": {
                "DISTANCE_MAX_VALUE": "[La distance Idéal]",
                "TOTAL_RESULT": "résultat combiné",
                "ADD_HEATMAP": "Ajouter un nouveau heatmap.",
                "MIN_MAX_ZOOM": "Min max. ",
                "RESOLUTION": "Résolution",
                "INFO_EXPERT": "À l'heure actuelle, pas de couches de carte sont chargées qui contiennent un heatmap. ",
                "TITLE_TAG": "Titre",
                "DELETE_HEATMAP": "Supprimer le heatmap.",
                "NAME": "heatmaps",
                "SCALE_MAX_TITLE": "[Max. ",
                "EXPORT_HEATMAP": "Export de la heatmap.",
                "SHOW_FEATURE_MSG": "Sélectionnez une fonction sur la carte pour voir le heatmap.",
                "EDITOR_TITLE": "Heatmap Editor",
                "INFO": "À l'heure actuelle, pas de couches de carte sont chargées qui contiennent un heatmap. ",
                "LINEAR_ASC_DESC": "augmenter linéairement, puis diminution de la fonction.",
                "DESCRIPTION": "<H4> Heatmap </ h4> <p style = `text-align: left; margin-left: 5px;`> Heatmap met en évidence les zones sur la carte qui remplissent plusieurs critères sélectionnés.",
                "INTENSITY_SCALE": "échelle d'intensité",
                "DELETE_MSG": "Supprimer `{0}`",
                "MAIN_FEATURE": "Sélectionnez la fonction principale",
                "PROPERTIES": "Sélectionnez les propriétés",
                "EDIT_HEATMAP": "Modifiez le heatmap.",
                "DELETE_MSG2": "Êtes-vous sûr?",
                "SCALE_MIN_TITLE": "[Min. ",
                "LOST_INTEREST_VALUE": "[Distance de l'intérêt perdu]",
                "TITLE": "Titre... *",
                "AT_LOCATION_VALUE": "[Poids à l'emplacement]"
            },
            "MCA": {
                "SIGMOID": "Tangentiellement fonction croissante entre min et max",
                "EDIT_MCA": "Modifiez le MCA.",
                "TOTAL_RESULT": "résultat combiné",
                "INCLUDE_RANK": "Afficher le rang?",
                "GAUSSIAN": "Distribution normale fonction entre min et max croissante.",
                "LINEAR": "fonction entre min et max augmenter linéairement.",
                "MAIN_FEATURE": "Sélectionnez la fonction principale",
                "PROPERTIES": "Sélectionnez les propriétés",
                "CATEGORY_MSG": "[Catégorie...]",
                "INFO_EXPERT": "À l'heure actuelle, pas de couches de carte sont chargées qui contiennent une analyse multi-critères. ",
                "RANK_TITLE": "[Rank titre ...]",
                "HAS_RANK": "Inclure rang?",
                "DELETE_MSG": "Supprimer `{0}`",
                "SHOW_FEATURE_MSG": "Sélectionnez une fonction sur la carte pour voir les effets de l'analyse multi-critères (MCA).",
                "MIN_VALUE": "[Minimum (ï¼-2Ïƒ)]",
                "HAS_CATEGORY": "A catégorie?",
                "EDITOR_TITLE": "MCA Editor",
                "SCALE_MIN_TITLE": "[Min. ",
                "DESCRIPTION": "<H4> analyse multicritères </ h4> <p style = `text-align: left; margin-left: 5px;`> MCA, est une méthode qui combine plusieurs propriétés d'une entité sur la carte dans une nouvelle propriété. ",
                "TOGGLE_SPARKLINE": "Afficher ou masquer les graphiques à barres et la fonction de notation.",
                "MAX_VALUE": "[Maximum (ï¼ 2Ïƒ)]",
                "TITLE": "Titre... *",
                "MIN_CUTOFF_VALUE": "[Ignorer quand dessous de cette valeur]",
                "SCALE_MAX_TITLE": "[Max. ",
                "INFO": "À l'heure actuelle, pas de couches de carte sont chargées qui contiennent une analyse multi-critères. ",
                "DELETE_MCA": "Supprimer le MCA.",
                "MAX_CUTOFF_VALUE": "[Ignorer quand dessus de cette valeur]",
                "DELETE_MSG2": "Êtes-vous sûr?",
                "ADD_MCA": "Ajouter un nouveau MCA.",
                "NAME": "Analyse multi-critères (MCA)",
                "SET_STYLE": "Set de style"
            },
            "PROJECTSETTINGS": {
                "DESCRIPTION": "Paramètres",
                "TITLE": "Paramètres du projet"
            },
            "CHOOSE_CATEGORY": "Choisir la catégorie ...",
            "SHOW5": "Afficher 5 articles",
            "SHOW10": "Afficher 10 articles",
            "SHOW15": "Afficher 15 articles",
            "SHOW20": "Afficher 20 articles",
            "SHOW25": "Afficher 25 articles",
            "SHOW30": "Afficher les 30 articles",
            "SHOW35": "Afficher 35 articles",
            "SHOW40": "Afficher 40 articles",
            "RISK_DIAGRAM_FOR": "Risque-diagramme pour une",
            "SAVE_FEATURE_DEPENDENCIES": "Enregistrer les dépendances à la fonction sélectionnée uniquement",
            "SAVE_FEATURETYPE_DEPENDENCIES": "Enregistrer les dépendances à toutes les fonctionnalités de ce type",
            "SAVE_MARVEL": "sauvegarder",
            "SAVE_EVERY_MARVEL": "Enregistrer tous les",
            "MARVEL_WATER_LEVEL": "Le niveau d'eau [m]",
            "MARVEL_UPS_DURATION": "durée UPS [minutes]",
            "MARVEL_FEATURE_DEP": "Dépend de",
            "STATE": "Etat",
            "EVENT_INFO": "Afficher une liste des événements",
            "CLEAR_EVENTS": "Effacer le journal des événements"
        };
        return French;
    }());
    Translations.French = French;
})(Translations || (Translations = {}));
//# sourceMappingURL=locale-fr.js.map
var Translations;
(function (Translations) {
    var Dutch = (function () {
        function Dutch() {
        }
        Dutch.locale = {
            CANCEL_BTN: 'Annuleren',
            OK_BTN: 'OK',
            FROM: 'van',
            TO: 'tot',
            ZOOM_LEVEL_LOW: 'Zoom niveau te laag',
            ZOOM_IN_FOR_CONTOURS: 'Zoom in om de contouren te tonen',
            NAVIGATE: {
                TITLE: 'Zoekresultaten'
            },
            REMOVE: 'Verwijder',
            CREATE_SCATTER: 'Creeer spreidingsdiagram',
            EXPAND_ALL: 'Alles uitklappen',
            COLLAPSE_ALL: 'Alles inklappen',
            SELECT_ALL: 'Selecteer alles',
            DESELECT_ALL: 'Deselecteer alles',
            ENABLE_LOCATION_FILTER: 'Activeer locatiefilter',
            SELECT_A_FEATURE: 'Selecteer een feature',
            DISABLE_LOCATION_FILTER: 'Deactiveer locatiefilter',
            SELECT_FEATURE_FOR_WIDGET: 'Selecteer een gebied om de widget te tonen.',
            SELECT_FEATURE_FOR_STYLE: 'Selecteer een gebied om de stijl te activeren.',
            SELECT_LAYER_GROUP: 'Selecteer lagen',
            SELECT_CATEGORY: 'Selecteer categorie',
            SELECT_PROPERTIES: 'Selecteer eigenschappen',
            NO_RELATIONS_FOUND: 'Geen relaties voor het geselecteerde item gevonden. Ofwel het zoomniveau is te laag, er zijn teveel items zichtbaar of er zijn geen relaties gedefiniëerd.',
            CHOOSE_DROPDOWN: 'Kies...',
            BASESTYLES: 'Basiskaarten',
            MAP: 'Kaarten',
            MAP_LABEL: 'Kaart',
            TABLE_LABEL: 'Tabel',
            LAYERS: 'Kaartlagen',
            DIRECTORY: 'Beschikbare lagen',
            CREATELAYER: 'Nieuwe laag maken',
            ADDFEATURES: 'Objecten toevoegen',
            ADDTYPE: 'Nieuwe type toevoegen',
            FILTERS: 'Filters',
            FILTER_INFO: 'Momenteel zijn er geen filters geselecteerd. Klik op een icoon of gebied op de kaart, en klik op het filter icoontje (<span class="fa fa-filter"></span>) in het rechter menu om een filter toe te voegen. Dan wordt er een filter aangemaakt voor de geselecteerde eigenschap.',
            STYLES: 'Stijlen',
            STYLE_INFO: 'Momenteel zijn er geen stijlen geselecteerd. Klik op een icoon of gebied op de kaart, en klik op het stijl icoontje (<span class="smallStyleIcon"></span>) in het rechter menu om een stijl toe te voegen. Dan wordt er een stijl aangemaakt voor de geselecteerde eigenschap.',
            FEATURES: 'Features',
            LEGEND: 'Legenda',
            SEARCH: 'Zoeken',
            HIDE_PANEL: 'Verberg dit paneel',
            EDIT_INDICATORS: 'Wijzig indicatoren',
            RELATED_FEATURES: 'Toon gerelateerde features',
            FEATURE_INFO: 'Toon informatie over de geselecteerde feature',
            MAP_FEATURES: 'Kaartfeatures',
            NEARBY_FEATURES: 'Dichtbijgelegen features',
            DASHBOARD_SELECTION: 'Dashboardselectie',
            SETTINGS: 'Instellingen',
            TOGGLE_MENU: 'Wissel de zichtbaarheid van het menu',
            SPEEDS_TAOUFIK: 'snelheden legenda Taoufik',
            SPEEDS_GOOGLEMAPS: 'snelheden legenda Google Maps',
            VERWARMINGSSYSTEEM: 'Verwarmingssysteem',
            PERCENTAGES_V1: 'percentages v1',
            ORANGE_RED: 'oranje - rood',
            WHITE_RED: 'wit - rood',
            RED_WHITE_BLUE: 'rood - wit - blauw',
            RED_WHITE: 'rood - wit',
            GREEN_RED: 'groen - rood',
            RED_GREEN: 'rood - groen',
            BLUE_RED: 'blauw - rood',
            RED_BLUE: 'rood - blauw',
            WHITE_BLUE: 'wit - blauw',
            BLUE_WHITE: 'wit - groen',
            WHITE_GREEN: 'wit - groen',
            GREEN_WHITE: 'groen - wit',
            WHITE_ORANGE: 'wit - oranje',
            ORANGE_WHITE: 'oranje - wit',
            SAVE: 'opslaan',
            APPLY: 'toepassen',
            DONE: 'klaar',
            CONFIG: 'config',
            EDIT: 'aanpassen',
            STATS: {
                COUNT: '#',
                COUNT_TOOLTIP: 'Aantal geselecteerde items',
                MIN: 'min',
                MIN_TOOLTIP: 'Minimum van geselecteerde items',
                MAX: 'max',
                MAX_TOOLTIP: 'Maximum van geselecteerde items',
                MEAN: 'µ',
                MEAN_TOOLTIP: 'Gemiddelde van geselecteerde items',
                SUM: 'Σ',
                SUM_TOOLTIP: 'Som van geselecteerde items'
            },
            UTILS: {
                FILTER: 'Gebruik dit kenmerk als filter',
                STYLE: 'Gebruik dit kenmerk als stijl',
                STATS: 'Toon de statistieken van dit kenmerk',
                CHART: 'Toon het verloop van dit kenmerk in de tijd',
                CONFIG: 'Configureer dit kenmerk'
            },
            EXPERTMODE: {
                BEGINNER: 'Beginner',
                INTERMEDIATE: 'Gevorderd',
                EXPERT: 'Expert',
                ADMIN: 'Admin',
                EXPLANATION: 'Selecteer uw expertise om meer functionaliteit te kunnen gebruiken.'
            },
            LAYER_SERVICE: {
                RELOAD_PROJECT_TITLE: 'Data wordt opnieuw geladen',
                RELOAD_PROJECT_MSG: 'Na het wisselen van de taal moet de kaartdata opnieuw ingelezen worden. Excuses voor het ongemak.'
            },
            HEATMAP: {
                NAME: 'Heatmaps',
                DESCRIPTION: '<h4>Toelichting heatmap</h4><div style="text-align: left; margin-left:5px;"><p>Heatmap laat gebieden op de kaart oplichten die voldoen aan bepaalde criteria.',
                INFO: 'Momenteel zijn er geen kaartlagen geopend die heatmaps bevatten.',
                INFO_EXPERT: 'Momenteel zijn er geen kaartlagen geopend die heatmaps bevatten. Open een kaartlaag en maak een nieuwe heatmap aan met behulp van de wizard.',
                SHOW_FEATURE_MSG: 'Selecteer een feature op de kaart om de heatmap resultaten in detail te bekijken.',
                TOTAL_RESULT: 'Gecombineerd resultaat',
                DELETE_MSG: 'Verwijder "{0}"',
                DELETE_MSG2: 'Weet u het zeker?',
                EDITOR_TITLE: 'Heatmap Editor',
                MAIN_FEATURE: 'Selecteer het type feature',
                PROPERTIES: 'Selecteer de eigenschappen',
                RESOLUTION: 'Resolutie',
                INTENSITY_SCALE: 'Intensiteitsschaal',
                TITLE: 'Titel... *',
                TITLE_TAG: 'Titel',
                TOGGLE_SPARKLINE: 'Toon of verberg de histogram en score functie.',
                SCALE_MIN_TITLE: '[Schaal max]',
                SCALE_MAX_TITLE: '[Schaal min]',
                MIN_MAX_ZOOM: 'Min./Max. zoom',
                AT_LOCATION_VALUE: '[Waarde op locatie]',
                DISTANCE_MAX_VALUE: '[Ideale afstand]',
                LOST_INTEREST_VALUE: '[Negeer vanaf afstand]',
                LINEAR_ASC_DESC: 'Linear toenemende, dan afnemende functie.',
                ADD_HEATMAP: 'Maak een nieuwe heatmap.',
                DELETE_HEATMAP: 'Verwijder de heatmap.',
                EDIT_HEATMAP: 'Bewerk de heatmap.',
                EXPORT_HEATMAP: 'Exporteer de heatmap.'
            },
            MCA: {
                NAME: 'Multi-Criteria Analyse (MCA)',
                DESCRIPTION: '<h4>Toelichting MCA</h4><div style="text-align: left; margin-left:5px;"><p>Multi-Criteria Analysis (MCA) is een methode die verschillende eigenschappen van een locatie of gebied op de kaart combineerd tot een nieuwe eigenschap. Dit gaat als volgt: <ol><li>Schaal iedere eigenschap tussen 0 (geen waarde) en 1 (maximum waarde).</li><li>Weeg iedere eigenschap relatief t.o.v. de andere gekozen eigenschappen, waar een gewicht onder 0 betekent dat je de eigenschap wil vermijden, 0 wordt genegeerd, en een waarde groter dan 0 betekent dat je dit wil bereiken.</li></ol>Met andere woorden, het is een vorm van lineare regressie.</p></div>',
                INFO: 'Momenteel zijn er geen kaartlagen geopend die multi-criteria analyses bevatten. Open hiervoor een andere kaartlaag.',
                INFO_EXPERT: 'Momenteel zijn er geen kaartlagen geopend die multi-criteria analyses bevatten. Open een kaartlaag en maak een nieuwe MCA aan met behulp van de wizard.',
                SHOW_FEATURE_MSG: 'Selecteer een feature op de kaart om de Multi-Criteria Analyse (MCA) resultaten in detail te bekijken.',
                TOTAL_RESULT: 'Gecombineerd resultaat',
                DELETE_MSG: 'Verwijder "{0}"',
                DELETE_MSG2: 'Weet u het zeker?',
                HAS_CATEGORY: '  Specificeer categorie? ',
                EDITOR_TITLE: 'MCA Editor',
                MAIN_FEATURE: 'Selecteer het type feature',
                PROPERTIES: 'Selecteer de eigenschappen',
                INCLUDE_RANK: '  Toon een rangorde? ',
                RANK_TITLE: '[Titel voor de rangorde]',
                TITLE: 'Titel... *',
                CATEGORY_MSG: '[Categorie...]',
                TOGGLE_SPARKLINE: 'Toon of verberg de histogram en score functie.',
                SCALE_MIN_TITLE: '[Schaal max]',
                SCALE_MAX_TITLE: '[Schaal min]',
                MIN_VALUE: '[Ondergrens (\u03BC-2\u03C3)]',
                MAX_VALUE: '[Bovengrens (\u03BC+2\u03C3)]',
                MIN_CUTOFF_VALUE: '[Niet meewegen onder]',
                MAX_CUTOFF_VALUE: '[Niet meewegen boven]',
                LINEAR: 'Linear toenemende functie tussen onder- en bovengrens.',
                SIGMOID: 'Tangentieel toenemende functie tussen onder- en bovengrens.',
                GAUSSIAN: 'Normale verdeling tussen onder- en bovengrens.',
                ADD_MCA: 'Maak een nieuwe MCA.',
                DELETE_MCA: 'Verwijder de MCA.',
                EDIT_MCA: 'Bewerk de MCA.',
                SET_STYLE: 'Activeer stijl'
            },
            PROJECTSETTINGS: {
                TITLE: 'Project instellingen',
                DESCRIPTION: 'Instellingen'
            },
            CHOOSE_CATEGORY: 'Kies categorie...',
            SHOW5: 'Toon 5 regels',
            SHOW10: 'Toon 10 regels',
            SHOW15: 'Toon 15 regels',
            SHOW20: 'Toon 20 regels',
            SHOW25: 'Toon 25 regels',
            SHOW30: 'Toon 30 regels',
            SHOW35: 'Toon 35 regels',
            SHOW40: 'Toon 40 regels',
            RISK_DIAGRAM_FOR: 'Risicodiagram voor een ',
            SAVE_FEATURE_DEPENDENCIES: 'Sla de afhankelijkheden op alléén voor het geselecteerde object',
            SAVE_FEATURETYPE_DEPENDENCIES: 'Sla de afhankelijkheden op voor alle object van dit type',
            SAVE_MARVEL: 'Bewaar ',
            SAVE_EVERY_MARVEL: 'Bewaar ieder ',
            MARVEL_WATER_LEVEL: 'Waterniveau [m]',
            MARVEL_UPS_DURATION: 'Noodstroom duur [min]',
            MARVEL_FEATURE_DEP: 'Afhankelijk van',
            STATE: 'Status',
            EVENT_INFO: 'Toon lijst van gebeurtenissen',
            CLEAR_EVENTS: 'Lijst leegmaken',
            SEARCH_PLACEHOLDER: 'Gemeente, adres, ...'
        };
        return Dutch;
    }());
    Translations.Dutch = Dutch;
})(Translations || (Translations = {}));
//# sourceMappingURL=locale-nl.js.map
var Accessibility;
(function (Accessibility) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Accessibility.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Accessibility.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    Accessibility.myModule.directive('accessibility', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Accessibility/Accessibility.tpl.html',
                replace: true,
                transclude: true,
                controller: Accessibility.AccessibilityCtrl
            };
        }
    ]);
})(Accessibility || (Accessibility = {}));
//# sourceMappingURL=Accessibility.js.map
var Accessibility;
(function (Accessibility) {
    var AccessibilityModel = (function () {
        function AccessibilityModel() {
            this.id = 'accessibilityActions';
        }
        AccessibilityModel.prototype.stop = function () { };
        AccessibilityModel.prototype.addFeature = function (feature) { };
        AccessibilityModel.prototype.removeFeature = function (feature) { };
        AccessibilityModel.prototype.selectFeature = function (feature) {
            console.log('accessibility:feature selected');
        };
        AccessibilityModel.prototype.getLayerActions = function (layer) {
            return null;
        };
        AccessibilityModel.prototype.addLayer = function (layer) { };
        AccessibilityModel.prototype.removeLayer = function (layer) { };
        AccessibilityModel.prototype.getFeatureActions = function (feature) {
            var accessibilityOption1 = {
                title: 'Show accessibility'
            };
            accessibilityOption1.callback = this.showAccessibility;
            var accessibilityOption2 = {
                title: 'Remove accessibility'
            };
            accessibilityOption2.callback = this.removeAccessibility;
            var accessibilityOption3 = {
                title: 'Plan route from'
            };
            accessibilityOption3.callback = this.planRouteFrom;
            var accessibilityOption4 = {
                title: 'Plan route to'
            };
            accessibilityOption4.callback = this.planRouteTo;
            return [accessibilityOption1, accessibilityOption2, accessibilityOption3, accessibilityOption4];
        };
        AccessibilityModel.prototype.getFeatureHoverActions = function (feature) { return []; };
        AccessibilityModel.prototype.deselectFeature = function (feature) { };
        AccessibilityModel.prototype.updateFeature = function (feature) { };
        AccessibilityModel.prototype.showAccessibility = function (feature, layerService) {
            console.log('accessibility:showAccessibility');
            var accessibilityLayer = layerService.findLayer('accessibility');
            if (accessibilityLayer) {
                var urlParams = accessibilityLayer.url.split('&');
                var locationIndex = -1;
                urlParams.some(function (param, index) {
                    if (param.substring(0, 9) === 'fromPlace') {
                        locationIndex = index;
                        return true;
                    }
                    return false;
                });
                if (feature.geometry.type !== 'Point') {
                    console.log('Can only create accessibility layer from a Point');
                    return;
                }
                urlParams[locationIndex] = 'fromPlace=' + feature.geometry.coordinates[1] + '%2C' + feature.geometry.coordinates[0];
                accessibilityLayer.url = urlParams.join('&');
                if (!accessibilityLayer.enabled) {
                    layerService.addLayer(accessibilityLayer);
                    var rpt = csComp.Helpers.createRightPanelTab('rightpanel', 'accessibility', accessibilityLayer, 'Accessibility options');
                    layerService.$messageBusService.publish('rightpanel', 'activate', rpt);
                }
                else {
                    if (accessibilityLayer.layerSource)
                        accessibilityLayer.layerSource.refreshLayer(accessibilityLayer);
                }
            }
        };
        AccessibilityModel.prototype.removeAccessibility = function (feature, layerService) {
            console.log('accessibility:removeAccessibility');
            var accessibilityLayer = layerService.findLayer('accessibility');
            if (accessibilityLayer) {
                var wasRightPanelVisible = layerService.visual.rightPanelVisible;
                if (accessibilityLayer.enabled) {
                    layerService.removeLayer(accessibilityLayer);
                }
                delete accessibilityLayer.data;
                layerService.visual.rightPanelVisible = wasRightPanelVisible;
            }
        };
        AccessibilityModel.planRoute = function (feature, layerService, destinationKey) {
            var routeLayer = layerService.findLayer('tripplanner');
            if (routeLayer) {
                var urlParams = csComp.Helpers.parseUrlParameters(routeLayer.url, '?', '&', '=');
                urlParams[destinationKey] = feature.geometry.coordinates[1] + '%2C' + feature.geometry.coordinates[0];
                routeLayer.url = csComp.Helpers.joinUrlParameters(urlParams, '?', '&', '=');
                if (!routeLayer.enabled) {
                    layerService.addLayer(routeLayer);
                }
                else {
                    if (routeLayer.layerSource)
                        routeLayer.layerSource.refreshLayer(routeLayer);
                }
                var rpt = csComp.Helpers.createRightPanelTab('rightpanel', 'tripplanner', routeLayer, 'Route planner');
                layerService.$messageBusService.publish('rightpanel', 'activate', rpt);
            }
            else {
            }
        };
        AccessibilityModel.prototype.planRouteFrom = function (feature, layerService) {
            console.log('accessibility:planRouteFrom');
            AccessibilityModel.planRoute(feature, layerService, 'fromPlace');
        };
        AccessibilityModel.prototype.planRouteTo = function (feature, layerService) {
            console.log('accessibility:planRouteTo');
            AccessibilityModel.planRoute(feature, layerService, 'toPlace');
        };
        AccessibilityModel.prototype.init = function (layerService) {
            var _this = this;
            console.log('init AccessibilityActionService');
            this.layerService = layerService;
            this.layerService.$messageBusService.serverSubscribe('accessibility', 'msg', function (title, mcb) {
                if (mcb['data'] === 'restart') {
                    _this.layerService.$messageBusService.notify('restarting server', 'restarting', csComp.Services.NotifyLocation.TopRight);
                    location.reload();
                }
                //
                // var layer = this.layerService.findLayer('demo');
                // layer.layerSource.refreshLayer(layer);
                //console.log(title);
            });
        };
        return AccessibilityModel;
    }());
    Accessibility.AccessibilityModel = AccessibilityModel;
    var AccessibilityCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function AccessibilityCtrl($scope, $http, $mapService, $layerService, $messageBusService, $dashboardService) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.urlKeys = ['arriveBy', 'fromPlace', 'date', 'time', 'mode', 'walkSpeed', 'bikeSpeed',
                'precisionMeters', 'cutoffSec'];
            this.scope = $scope;
            $scope.vm = this;
            this.layer = $scope.$parent['data'];
            this.cutoffTimes = [];
            this.urlParameters = {};
            this.bikeSpeedKm;
            this.walkSpeedKm;
            this.urlKeys.forEach(function (key) { _this.urlParameters[key] = 0; });
            this.transportModes = {};
            this.transportModes['Walking'] = 'WALK';
            this.transportModes['Biking'] = 'BICYCLE';
            //this.transportModes['Car'] = 'CAR';
        }
        AccessibilityCtrl.prototype.refreshAccessibility = function () {
            if (this.$layerService.lastSelectedFeature) {
                var lsf = this.$layerService.lastSelectedFeature;
                if (lsf.geometry && lsf.geometry.type === 'Point') {
                    this.urlParameters['fromPlace'] = lsf.geometry.coordinates[1] + '%2C' + lsf.geometry.coordinates[0];
                }
            }
            this.urlParameters['mode'] = this.transportMode;
            this.urlParameters['time'] = encodeURIComponent(this.time);
            if (this.walkSpeedKm)
                this.urlParameters['walkSpeed'] = csComp.Helpers.GeoExtensions.convertKmToMile(this.walkSpeedKm);
            if (this.bikeSpeedKm)
                this.urlParameters['bikeSpeed'] = csComp.Helpers.GeoExtensions.convertKmToMile(this.bikeSpeedKm);
            var url = this.urlAddress + '?';
            for (var key in this.urlParameters) {
                if (this.urlParameters.hasOwnProperty(key) && key !== 'cutoffSec') {
                    url = url + key + '=' + this.urlParameters[key] + '&';
                }
            }
            this.cutoffTimes.forEach(function (co) {
                url = url + '&cutoffSec=' + (co * 60);
            });
            //url = url.substring(0, url.length - 1);
            console.log(url);
            this.layer.url = url;
            if (!this.layer.enabled) {
                this.$layerService.addLayer(this.layer);
            }
            else {
                if (this.layer.layerSource)
                    this.layer.layerSource.refreshLayer(this.layer);
            }
            this.$layerService.visual.rightPanelVisible = true;
        };
        AccessibilityCtrl.prototype.parseUrl = function () {
            var _this = this;
            this.urlParameters = {};
            this.urlAddress = this.layer.url.split('?')[0];
            var croppedUrl = this.layer.url.split('?')[1]; // Remove the address of the url, keep the parameters
            var splittedUrl = croppedUrl.split('&');
            splittedUrl.forEach(function (param) {
                var keyValue = param.split('=');
                if (keyValue[0] === 'cutoffSec') {
                    _this.cutoffTimes.push((+keyValue[1]) / 60);
                }
                _this.urlParameters[keyValue[0]] = (isNaN(+keyValue[1])) ? keyValue[1] : +keyValue[1];
            });
            var d = new Date(Date.now());
            this.time = ('0' + d.getHours()).slice(-2) + ':' + ('0' + d.getMinutes()).slice(-2);
            this.urlParameters['date'] = (d.getMonth() + 1) + '-' + d.getDate() + '-' + d.getFullYear();
            this.transportMode = this.urlParameters['mode'];
            if (this.urlParameters.hasOwnProperty('walkSpeed'))
                this.walkSpeedKm = +csComp.Helpers.GeoExtensions.convertMileToKm(this.urlParameters['walkSpeed']).toFixed(2);
            if (this.urlParameters.hasOwnProperty('bikeSpeed'))
                this.bikeSpeedKm = +csComp.Helpers.GeoExtensions.convertMileToKm(this.urlParameters['bikeSpeed']).toFixed(2);
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        AccessibilityCtrl.prototype.addCutoffTime = function () {
            this.cutoffTimes.push(0);
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        AccessibilityCtrl.prototype.removeCutoffTime = function (index) {
            if (index < this.cutoffTimes.length && index > -1) {
                this.cutoffTimes.splice(index, 1);
            }
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        AccessibilityCtrl.$inject = [
            '$scope',
            '$http',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return AccessibilityCtrl;
    }());
    Accessibility.AccessibilityCtrl = AccessibilityCtrl;
})(Accessibility || (Accessibility = {}));
//# sourceMappingURL=AccessibilityCtrl.js.map
var BaseMapList;
(function (BaseMapList) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        BaseMapList.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        BaseMapList.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    BaseMapList.myModule.directive('baseMapList', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                //template  : html,   // I use gulp automatian to compile the FeatureProperties.tpl.html to a simple TS file, FeatureProperties.tpl.ts, which contains the html as string. The advantage is that you can use HTML intellisence in the html file.
                templateUrl: 'directives/BaseMapList/BaseMapList.tpl.html',
                //compile : el          => {    // I need to explicitly compile it in order to use interpolation like {{xxx}}
                //    var fn                        = $compile(el);
                //    return scope                  => {
                //        fn(scope);
                //    };
                //},
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: true,
                transclude: true,
                controller: BaseMapList.BaseMapListCtrl
            };
        }
    ]);
})(BaseMapList || (BaseMapList = {}));
//# sourceMappingURL=BaseMapList.js.map
var BaseMapList;
(function (BaseMapList) {
    var BaseMapListCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function BaseMapListCtrl($scope, $layerService, $mapService, $messageBusService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            $scope.vm = this;
        }
        BaseMapListCtrl.prototype.selectBaseLayer = function (key) {
            var layer = this.$layerService.$mapService.getBaselayer(key);
            this.$layerService.activeMapRenderer.changeBaseLayer(layer);
            this.$layerService.$mapService.changeBaseLayer(key);
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        BaseMapListCtrl.$inject = [
            '$scope',
            'layerService',
            'mapService',
            'messageBusService',
        ];
        return BaseMapListCtrl;
    }());
    BaseMapList.BaseMapListCtrl = BaseMapListCtrl;
})(BaseMapList || (BaseMapList = {}));
//# sourceMappingURL=BaseMapListCtrl.js.map
var Charts;
(function (Charts) {
    'use strict';
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Charts.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Charts.myModule = angular.module(moduleName, []);
    }
    Charts.myModule.directive('barChart', ['$filter',
        function ($filter) {
            return {
                terminal: true,
                restrict: 'EA',
                scope: {
                    data: '=',
                    update: '='
                },
                link: function (scope, element, attrs) {
                    //in D3, any selection[0] contains the group
                    //selection[0][0] is the DOM node
                    //but we won't need that this time
                    var chart = d3.select(element[0]);
                    chart.append("div").attr("class", "chart")
                        .selectAll('div')
                        .data(scope.data).enter().append("div")
                        .transition().ease("elastic")
                        .style("width", function (d) { return d + "%"; })
                        .text(function (d) { return d + "%"; });
                    //to our original directive markup bars-chart
                    //we add a div with out chart stling and bind each
                    //data entry to the chart
                }
            };
        }
    ]);
})(Charts || (Charts = {}));
//# sourceMappingURL=BarChart.js.map
var Charts;
(function (Charts) {
    'use strict';
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Charts.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Charts.myModule = angular.module(moduleName, []);
    }
    Charts.myModule.directive('bulletChart', ['$filter',
        function ($filter) {
            var demoData = [{
                    title: "Drop outs",
                    subtitle: "%",
                    ranges: [150, 225, 300],
                    measures: [220, 270],
                    markers: [250]
                }];
            function doDraw(scope, element) {
                if (scope.data) {
                    var doBullet = d3.bullet()
                        .width(scope.width)
                        .height(scope.height);
                    //bullet expects de following data
                    /**
                    title :
                    subtitle :

                    ranges : array of context ranges (absolute, not relative)
                    measures : array of values shown (absolute, not relative)
                    markers : (absolute, not relative)
                    */
                    //
                    $(element[0]).empty();
                    var chart = d3.select(element[0]);
                    var parsedData = [];
                    if (scope.data) {
                        parsedData = JSON.parse(scope.data);
                    }
                    ;
                    var svg = chart.append("div").attr("class", "chart")
                        .selectAll('div')
                        .data(parsedData)
                        .enter().append("svg")
                        .attr("class", "bullet")
                        .attr("width", scope.width + 15)
                        .attr("height", +scope.height + 40)
                        .append("g")
                        .attr("transform", "translate(7,20)")
                        .call(doBullet, false);
                    var title = svg.append("g")
                        .style("text-anchor", "begin")
                        .attr("transform", "translate(0,-5)");
                    title.append("text")
                        .attr("class", "title")
                        .text(function (d) { return d.title; });
                    title.append("text")
                        .attr("class", "subtitle")
                        .attr("dy", "1em")
                        .text(function (d) { return d.subtitle; });
                }
                ;
            }
            return {
                terminal: true,
                restrict: 'EA',
                scope: {
                    //data: '=',
                    data: '=',
                    update: '=',
                    width: '=',
                    height: '@',
                    margin: '@'
                },
                link: function (scope, element, attrs) {
                    //in D3, any selection[0] contains the group
                    //selection[0][0] is the DOM node
                    //but we won't need that this time
                    doDraw(scope, element);
                    scope.$watch("data", function () {
                        doDraw(scope, element);
                    });
                    scope.$watch("update", function () {
                        doDraw(scope, element);
                    });
                }
            };
        }
    ]);
})(Charts || (Charts = {}));
//# sourceMappingURL=bulletChart.js.map
var Charts;
(function (Charts) {
    'use strict';
    var ChartHelpers = (function () {
        function ChartHelpers() {
        }
        /**
        * Returns the index and value of the maximum.
        */
        ChartHelpers.max = function (arr) {
            var max = arr[0];
            var maxIndex = 0;
            for (var i = 1; i < arr.length; i++) {
                if (arr[i] > max) {
                    maxIndex = i;
                    max = arr[i];
                }
            }
            return { maxIndex: maxIndex, max: max };
        };
        /**
        * Returns the index and value of the minimum.
        */
        ChartHelpers.min = function (arr) {
            var min = arr[0];
            var minIndex = 0;
            for (var i = 1; i < arr.length; i++) {
                if (arr[i] < min) {
                    minIndex = i;
                    min = arr[i];
                }
            }
            return { minIndex: minIndex, min: min };
        };
        /**
        * Convert a timestamp to string.
        */
        ChartHelpers.timestampToString = function (ts) {
            var date = new Date(ts);
            var dateString = String.format("{0}-{1:00}-{2:00}", date.getFullYear(), date.getUTCMonth() + 1, date.getUTCDate());
            //if (date.getUTCHours() > 0 || date.getUTCMinutes() > 0)
            //    dateString += String.format(" {0:00}:{1:00}", date.getUTCHours(), date.getUTCMinutes());
            return dateString;
        };
        ChartHelpers.timestampToTimeString = function (ts) {
            var date = new Date(ts);
            var dateString = String.format("{0}:{2:00}:{2:00}", date.getHours(), date.getMinutes() + 1, date.getSeconds());
            //if (date.getUTCHours() > 0 || date.getUTCMinutes() > 0)
            //    dateString += String.format(" {0:00}:{1:00}", date.getUTCHours(), date.getUTCMinutes());
            return dateString;
        };
        // Easy way to bind multiple functions to window.onresize
        // TODO: give a way to remove a function after its bound, other than removing all of them
        ChartHelpers.windowResize = function (fun) {
            if (fun === undefined)
                return;
            var oldresize = window.onresize;
            window.onresize = function (e) {
                if (typeof oldresize == 'function')
                    oldresize(e);
                fun(e);
            };
        };
        ChartHelpers.initializeMargin = function (scope, attrs) {
            var margin = scope.$eval(attrs.margin) || {
                left: 50,
                top: 50,
                bottom: 50,
                right: 50
            };
            if (typeof margin !== 'object') {
                // we were passed a vanilla int, convert to full margin object
                margin = {
                    left: margin,
                    top: margin,
                    bottom: margin,
                    right: margin
                };
            }
            scope.margin = margin;
        };
        ChartHelpers.getD3Selector = function (attrs, element) {
            if (!attrs.id) {
                //if an id is not supplied, create a random id.
                var dataAttributeChartID;
                if (!attrs['data-chartid']) {
                    dataAttributeChartID = 'chartid' + Math.floor(Math.random() * 1000000001);
                    angular.element(element).attr('data-chartid', dataAttributeChartID);
                }
                else {
                    dataAttributeChartID = attrs['data-chartid'];
                }
                return '[data-chartid=' + dataAttributeChartID + ']';
            }
            else {
                return '#' + attrs.id;
            }
        };
        ChartHelpers.initializeLegendMargin = function (scope, attrs) {
            var margin = (scope.$eval(attrs.legendmargin) || {
                left: 0,
                top: 5,
                bottom: 5,
                right: 0
            });
            if (typeof (margin) !== 'object') {
                // we were passed a vanilla int, convert to full margin object
                margin = {
                    left: margin,
                    top: margin,
                    bottom: margin,
                    right: margin
                };
            }
            scope.legendmargin = margin;
        };
        ChartHelpers.defaultColor = function () {
            var colors = d3.scale.category20().range();
            return function (d, i) { return d.color || colors[i % colors.length]; };
        };
        ChartHelpers.configureLegend = function (chart, scope, attrs) {
            if (chart.legend && attrs.showlegend && (attrs.showlegend === 'true')) {
                ChartHelpers.initializeLegendMargin(scope, attrs);
                chart.legend.margin(scope.legendmargin);
                chart.legend.width(attrs.legendwidth === undefined ? 400 : (+attrs.legendwidth));
                chart.legend.height(attrs.legendheight === undefined ? 20 : (+attrs.legendheight));
                chart.legend.key(attrs.legendkey === undefined ? function (d) {
                    return d.key;
                } : scope.legendkey());
                chart.legend.color(attrs.legendcolor === undefined ? ChartHelpers.defaultColor() : scope.legendcolor());
                chart.legend.align(attrs.legendalign === undefined ? true : (attrs.legendalign === 'true'));
                chart.legend.rightAlign(attrs.legendrightalign === undefined ? true : (attrs.legendrightalign === 'true'));
                chart.legend.updateState(attrs.legendupdatestate === undefined ? true : (attrs.legendupdatestate === 'true'));
                chart.legend.radioButtonMode(attrs.legendradiobuttonmode === undefined ? false : (attrs.legendradiobuttonmode === 'true'));
            }
        };
        ChartHelpers.checkElementID = function (scope, attrs, element, chart, data) {
            //ChartHelpers.configureXaxis(chart, scope, attrs);
            //ChartHelpers.configureX2axis(chart, scope, attrs);
            //ChartHelpers.configureYaxis(chart, scope, attrs);
            //ChartHelpers.configureY1axis(chart, scope, attrs);
            //ChartHelpers.configureY2axis(chart, scope, attrs);
            ChartHelpers.configureLegend(chart, scope, attrs);
            //ChartHelpers.processEvents(chart, scope);
            var d3Select = ChartHelpers.getD3Selector(attrs, element);
            if (angular.isArray(data) && data.length === 0) {
                d3.select(d3Select + ' svg').remove();
            }
            if (d3.select(d3Select + ' svg').empty()) {
                d3.select(d3Select).append('svg');
            }
            d3.select(d3Select + ' svg').attr('viewBox', '0 0 ' + scope.width + ' ' + scope.height).datum(data).transition().duration(attrs.transitionduration === undefined ? 250 : +attrs.transitionduration).call(chart);
        };
        ChartHelpers.updateDimensions = function (scope, attrs, element, chart) {
            if (chart) {
                chart.width(scope.width).height(scope.height);
                var d3Select = ChartHelpers.getD3Selector(attrs, element);
                d3.select(d3Select + ' svg').attr('viewBox', '0 0 ' + scope.width + ' ' + scope.height);
                ChartHelpers.windowResize(chart);
                scope.chart.update();
            }
        };
        return ChartHelpers;
    }());
    Charts.ChartHelpers = ChartHelpers;
})(Charts || (Charts = {}));
//# sourceMappingURL=ChartHelpers.js.map
var Charts;
(function (Charts) {
    'use strict';
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Charts.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Charts.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to create a sparkline chart.
      *
      * @seealso: http://odiseo.net/angularjs/proper-use-of-d3-js-with-angular-directives
      * @seealso: http://cmaurer.github.io/angularjs-nvd3-directives/sparkline.chart.html
      * @seealso: http://www.tnoda.com/blog/2013-12-19
      */
    Charts.myModule
        .directive('circularChart', [
        function () {
            return {
                terminal: true,
                restrict: 'EA',
                scope: {
                    value: '=',
                    max: '=',
                    title: '=',
                    update: '=',
                    valueString: '=',
                    color: '=',
                    valueClass: '@',
                    titleClass: '@',
                    animationDuration: '@',
                    width: '@',
                    height: '@',
                    margin: '@'
                },
                //controller: [
                //    '$scope',
                //    '$element',
                //    '$attrs',
                //    function ($scope, $element, $attrs) {
                //        $scope.d3Call    = function (data, chart) {
                //            ChartHelpers.checkElementID($scope, $attrs, $element, chart, data);
                //        };
                //    }
                //],
                link: function (scope, element, attrs) {
                    var doDraw = (function () {
                        if (scope.value != null && scope.max != null) {
                            var margin = scope.margin || { top: 15, right: 5, bottom: 0, left: 10 };
                            var width = scope.width || 100;
                            var height = scope.height || 70;
                            var c = scope.color || "purple";
                            var animationDuration = scope.animationDuration || 0;
                            var cursorTextHeight = 12; // + (showAxis ? 5 : 0); // leave room for the cursor text (timestamp | measurement)
                            $(element[0]).empty();
                            var dataset = {
                                hddrives: [scope.value, scope.max - scope.value],
                            };
                            var width = scope.width, height = scope.height, radius = Math.min(width, height) / 2;
                            var color = d3.scale.ordinal()
                                .range([c, "lightgray"]);
                            var pie = d3.layout.pie()
                                .sort(null);
                            var arc = d3.svg.arc()
                                .innerRadius(radius - 100)
                                .outerRadius(radius - 80);
                            var svg = d3.select(element[0]).append("svg")
                                .attr("width", width)
                                .attr("height", height)
                                .append("g")
                                .attr("transform", "translate(" + width / 3 + "," + height / 3 + ")");
                            var path = svg.selectAll("path")
                                .data(pie(dataset.hddrives))
                                .enter().append("path")
                                .attr("class", "arc")
                                .attr("fill", function (d, i) { return color(i); })
                                .transition().delay(function (d, i) { return i * animationDuration; }).duration(animationDuration)
                                .attrTween("d", function (d) {
                                var i = d3.interpolate(d.startAngle + 0.1, d.endAngle);
                                return function (t) {
                                    d.endAngle = i(t);
                                    return arc(d);
                                };
                            });
                            svg.append("text")
                                .attr("dy", "-0.25em")
                                .style("text-anchor", "middle")
                                .attr("class", scope.valueClass)
                                .text(function (d) { return scope.valueString; });
                            svg.append("text")
                                .attr("dy", "1em")
                                .style("text-anchor", "middle")
                                .attr("class", scope.titleClass)
                                .text(function (d) { return scope.title; });
                        }
                    });
                    doDraw();
                    scope.$watch("value", function () {
                        doDraw();
                    });
                    scope.$watch("color", function () {
                        doDraw();
                    });
                    scope.$watch("update", function () {
                        doDraw();
                    });
                    //scope.closed = true;
                }
            };
        }]);
})(Charts || (Charts = {}));
//# sourceMappingURL=CircularChart.js.map
var Charts;
(function (Charts) {
    'use strict';
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Charts.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Charts.myModule = angular.module(moduleName, []);
    }
    Charts.myModule.directive('singlevalueChart', ['$filter',
        function ($filter) {
            return {
                terminal: true,
                restrict: 'EA',
                scope: {
                    data: '=',
                },
                link: function (scope, element, attrs) {
                    //in D3, any selection[0] contains the group
                    //selection[0][0] is the DOM node
                    //but we won't need that this time
                    var chart = d3.select(element[0]);
                    chart.append("div").attr("class", "chart")
                        .selectAll('div')
                        .data(scope.value).enter().append("div")
                        .transition().ease("elastic")
                        .style("width", function (d) { return d + "%"; })
                        .text(function (d) { return d + "%"; });
                    //to our original directive markup bars-chart
                    //we add a div with out chart stling and bind each
                    //data entry to the chart
                }
            };
        }
    ]);
})(Charts || (Charts = {}));
//# sourceMappingURL=SingleValue.js.map
var Charts;
(function (Charts) {
    'use strict';
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Charts.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Charts.myModule = angular.module(moduleName, []);
    }
    Charts.myModule
        .directive('sparklineChart', ['$filter',
        function ($filter) {
            return {
                terminal: true,
                restrict: 'EA',
                scope: {
                    timestamps: '=',
                    sensor: '=',
                    property: '=',
                    update: '=',
                    focusTime: '=',
                    showaxis: '=',
                    closed: '=',
                    smooth: '=',
                    width: '@',
                    height: '@',
                    margin: '@'
                },
                // controller: [
                //    '$scope',
                //    '$element',
                //    '$attrs',
                //
                //    function ($scope, $element, $attrs, messageBusService) {
                //
                //    }
                // ],
                link: function (scope, element, attrs) {
                    var doDraw = (function () {
                        if (scope.timestamps != null && scope.sensor != null && scope.timestamps.length > 0) {
                            var margin = scope.margin || { top: 15, right: 5, bottom: 0, left: 10 };
                            var width = scope.width || 100;
                            var height = scope.height || 70;
                            console.log('heigth:' + height);
                            var showAxis = typeof scope.showaxis !== 'undefined' && scope.showaxis;
                            var closed = typeof scope.closed !== 'undefined' && scope.closed;
                            var smooth = typeof scope.smooth !== 'undefined' && scope.smooth;
                            var cursorTextHeight = 12; // + (showAxis ? 5 : 0); // leave room for the cursor text (timestamp | measurement)
                            $(element[0]).empty();
                            var chart = d3.select(element[0])
                                .append('svg:svg')
                                .attr('width', width)
                                .attr('height', height);
                            var marginAxis = showAxis
                                ? { top: 0, right: 0, bottom: 20, left: 10 }
                                : { top: 0, right: 0, bottom: 0, left: 0 };
                            var x = d3.scale.linear().range([margin.left + marginAxis.left, width - margin.left - margin.right - marginAxis.left - marginAxis.right]);
                            var y = d3.scale.linear().range([height - margin.bottom - marginAxis.bottom, margin.top + marginAxis.top + cursorTextHeight]);
                            var bisect = d3.bisector(function (d) { return d.time; }).left;
                            var line = d3.svg.line()
                                .interpolate((smooth) ? "cardinal" : "linear")
                                .x(function (d) { return x(d.time); })
                                .y(function (d) { return y(d.measurement); });
                            var data = [];
                            //data.push({time:scope.timestamps[0],measurement:0});
                            for (var i = 0; i < scope.timestamps.length; i++) {
                                var m = scope.property ? scope.property : 'value';
                                var me = $.isArray(scope.sensor[i]) ? scope.sensor[i][m] : scope.sensor[i];
                                data.push({ time: scope.timestamps[i], measurement: me });
                            }
                            //data.push({time:scope.timestamps[scope.timestamps.length-1],measurement:0});
                            x.domain(d3.extent(data, function (d) { return d.time; }));
                            y.domain(d3.extent(data, function (d) { return d.measurement; }));
                            var s = [];
                            if (closed && data.length > 0)
                                s.push({ time: data[0].time, measurement: 0 });
                            data.forEach(function (d) { return s.push(d); });
                            if (closed && data.length > 0)
                                s.push({ time: data[data.length - 1].time, measurement: 0 });
                            var path = chart.append("svg:path")
                                .attr("d", line(s))
                                .attr('class', 'sparkline-path')
                                .style('fill', (closed) ? 'steelblue' : 'none');
                            // draw a circle around the max and min value
                            var measurements = data.map(function (d) { return d.measurement; });
                            var min = Charts.ChartHelpers.min(measurements);
                            var max = Charts.ChartHelpers.max(measurements);
                            chart.append('circle')
                                .attr('class', 'sparkcircle-max')
                                .attr('cx', x(data[max.maxIndex].time))
                                .attr('cy', y(max.max))
                                .attr('r', 4);
                            chart.append('circle')
                                .attr('class', 'sparkcircle-min')
                                .attr('cx', x(data[min.minIndex].time))
                                .attr('cy', y(min.min))
                                .attr('r', 4);
                            if (showAxis) {
                                //var xAxis = d3.svg.axis()
                                //    .scale(x)
                                //    .orient("bottom")
                                //    .ticks(d3.time.months, 2);  //Set rough # of ticks
                                //chart.append("g")
                                //    .attr("class", "sparkline-axis")
                                //    .attr("transform", "translate(0," + (height - margin.bottom - marginAxis.bottom) + ")")
                                //    .call(xAxis);
                                var strokeLength = 6;
                                // Draw min/max at x and y axis
                                var xbor = d3.min(x.range()), //margin.left + marginAxis.left,
                                xmin = xbor - strokeLength, xmax = d3.max(x.range()), // width - margin.right - marginAxis.right,
                                ybor = d3.max(y.range()), //height - margin.bottom - marginAxis.bottom,
                                ymin = d3.min(y.range()), //margin.top + marginAxis.top,
                                ymax = ybor + strokeLength;
                                // y-axis, max
                                chart.append('line')
                                    .attr("x1", xmin)
                                    .attr("y1", ymin)
                                    .attr("x2", xbor)
                                    .attr("y2", ymin)
                                    .attr("stroke", "black");
                                chart.append("text")
                                    .attr("x", xmin - 2)
                                    .attr("y", ymin)
                                    .attr("dy", ".35em")
                                    .style("text-anchor", "end")
                                    .text();
                                // y-axis, min
                                chart.append('line')
                                    .attr("x1", xmin)
                                    .attr("y1", ybor)
                                    .attr("x2", xbor)
                                    .attr("y2", ybor)
                                    .attr("stroke", "black");
                                chart.append("text")
                                    .attr("x", xmin - 2)
                                    .attr("y", ybor)
                                    .attr("dy", ".35em")
                                    .style("text-anchor", "end")
                                    .text(d3.min(y.domain()));
                                // x-axis, min
                                chart.append('line')
                                    .attr("x1", xbor)
                                    .attr("y1", ymax)
                                    .attr("x2", xbor)
                                    .attr("y2", ybor)
                                    .attr("stroke", "black");
                                chart.append("text")
                                    .attr("x", xbor)
                                    .attr("y", ymax + 9)
                                    .attr("dy", ".35em")
                                    .style("text-anchor", "start")
                                    .text(Charts.ChartHelpers.timestampToString(d3.min(x.domain())));
                                // x-axis, max
                                chart.append('line')
                                    .attr("x1", xmax)
                                    .attr("y1", ymax)
                                    .attr("x2", xmax)
                                    .attr("y2", ybor)
                                    .attr("stroke", "black");
                                chart.append("text")
                                    .attr("x", xmax)
                                    .attr("y", ymax + 9)
                                    .attr("dy", ".35em")
                                    .style("text-anchor", "end")
                                    .text(Charts.ChartHelpers.timestampToString(d3.max(x.domain())));
                            }
                            // draw a line at the current cursor position
                            var cursor = chart.append("line")
                                .attr("x1", 0)
                                .attr("y1", 0)
                                .attr("x2", 0)
                                .attr("y2", 0)
                                .attr("opacity", 0)
                                .attr("stroke", "black");
                            var timestampText = chart.append("text")
                                .attr("x", 0)
                                .attr("y", 0)
                                .attr("dy", ".35em")
                                .attr("opacity", 0)
                                .style("text-anchor", "end")
                                .text("");
                            var timestampTimeText = chart.append("text")
                                .attr("x", 0)
                                .attr("y", 16)
                                .attr("dy", ".35em")
                                .attr("opacity", 0)
                                .style("text-anchor", "end")
                                .text("");
                            var measurementText = chart.append("text")
                                .attr("x", 0)
                                .attr("y", 0)
                                .attr("dy", ".35em")
                                .attr("opacity", 0)
                                .text("");
                            var pathEl = path.node();
                            var pathLength = pathEl.getTotalLength();
                            chart
                                .on("mouseover", function () { })
                                .on("mouseout", function () {
                                cursor.attr("opacity", 0);
                                timestampText.attr("opacity", 0);
                                measurementText.attr("opacity", 0);
                            })
                                .on("mousemove", function () {
                                var offsetLeft = element[0].getBoundingClientRect().left;
                                var xpos = d3.event.clientX - offsetLeft;
                                var beginning = xpos, end = pathLength, target;
                                while (true) {
                                    target = Math.floor((beginning + end) / 2);
                                    var pos = pathEl.getPointAtLength(target);
                                    if ((target === end || target === beginning) && pos.x !== xpos) {
                                        break;
                                    }
                                    if (pos.x > xpos)
                                        end = target;
                                    else if (pos.x < xpos)
                                        beginning = target;
                                    else
                                        break; //position found
                                }
                                // using the x scale, in this case a d3 time scale
                                // use the .invert() function to interpolate a date along the scale
                                // given the x-coordinates of the mouse
                                var t0 = x.invert(d3.mouse(this)[0]);
                                // using the interpolated date, find an index in the sorted data
                                // this would be the index suitable for insertion
                                var i = bisect(data, t0, 1);
                                if (0 < i && i < data.length) {
                                    // now that we know where in the data the interpolated date would "fit"
                                    // between two values, pull them both back as temporaries
                                    var d0 = data[i - 1];
                                    var d1 = data[i];
                                    // now, examine which of the two dates we are "closer" to
                                    // to do this, compare the delta values
                                    var d = t0 - d0.time > d1.time - t0 ? d1 : d0;
                                }
                                else if (i <= 0)
                                    d = data[0];
                                else
                                    d = data[data.length - 1];
                                xpos = x(d.time);
                                // draw
                                cursor
                                    .attr("x1", xpos)
                                    .attr("y1", 0)
                                    .attr("x2", xpos)
                                    .attr("y2", d3.max(y.range()) + (strokeLength || 0))
                                    .attr("opacity", 1);
                                timestampText
                                    .attr("x", xpos - 6)
                                    .attr("y", 8)
                                    .attr("dy", ".35em")
                                    .attr("opacity", 1)
                                    .text((d === data[0]) ? '' : Charts.ChartHelpers.timestampToString(d.time)); //Don't show timestamp for the first measurement, as it does not fit. Other option is to print it underneath the measurement value.
                                timestampTimeText
                                    .attr("x", xpos - 6)
                                    .attr("y", 16)
                                    .attr("dy", ".35em")
                                    .attr("opacity", 1)
                                    .text((d === data[0]) ? '' : Charts.ChartHelpers.timestampToTimeString(d.time)); //Don't show timestamp for the first measurement, as it does not fit. Other option is to print it underneath the measurement value.
                                measurementText
                                    .attr("x", xpos + 6)
                                    .attr("y", 8)
                                    .attr("dy", ".35em")
                                    .attr("opacity", 1)
                                    .text(d.measurement);
                            });
                        }
                    });
                    doDraw();
                    scope.$watchCollection("sensor", function () { doDraw(); });
                    scope.$watch("update", function () {
                        doDraw();
                    });
                    //scope.closed = true;
                }
            };
        }]);
})(Charts || (Charts = {}));
//# sourceMappingURL=SparklineChart.js.map
var Directives;
(function (Directives) {
    var Clock;
    (function (Clock) {
        /**
         * Config
         */
        var moduleName = "csComp";
        try {
            Clock.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Clock.myModule = angular.module(moduleName, []);
        }
        /**
          * Directive to show the time.
          */
        Clock.myModule.directive('clock', ['dateFilter', function (dateFilter) {
                return {
                    restrict: 'E',
                    scope: {
                        time: '@',
                        format: '@'
                    },
                    link: function (scope, element, attrs) {
                        function updateTime() {
                            element.html(dateFilter(scope.time, scope.format));
                        }
                        scope.$watch('time', function (value) {
                            updateTime();
                        });
                    }
                };
            }]);
    })(Clock = Directives.Clock || (Directives.Clock = {}));
})(Directives || (Directives = {}));
//# sourceMappingURL=Clock.js.map
var Helpers;
(function (Helpers) {
    var ContextMenu;
    (function (ContextMenu) {
        /**
         * Config
         */
        var moduleName = 'csComp';
        try {
            ContextMenu.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            ContextMenu.myModule = angular.module(moduleName, []);
        }
        /**
          * Directive to resize an element by settings its width or height,
          * for example to make sure that the scrollbar appears.
          * Typical usage:
          * <div style="overflow-y: auto; overflow-x: hidden" resize resize-x="20" resize-y="250">...</div>
          * Load the directive in your module, e.g.
          * angular.module('myWebApp', ['csWeb.resize'])
          */
        ContextMenu.myModule.directive('contextMenu', function ($parse) {
            var renderContextMenu = function ($scope, event, options) {
                if (!$) {
                    var $ = angular.element;
                }
                $(event.currentTarget).addClass('context');
                var $contextMenu = $('<div>');
                $contextMenu.addClass('dropdown clearfix');
                var $ul = $('<ul>');
                $ul.addClass('dropdown-menu');
                $ul.attr({ 'role': 'menu' });
                $ul.css({
                    display: 'block',
                    position: 'absolute',
                    left: event.pageX + 'px',
                    top: event.pageY + 'px'
                });
                angular.forEach(options, function (item, i) {
                    var $li = $('<li>');
                    if (item === null) {
                        $li.addClass('divider');
                    }
                    else {
                        var $a = $('<a>');
                        $a.attr({ tabindex: '-1', href: '#' });
                        $a.text(typeof item[0] == 'string' ? item[0] : item[0].call($scope, $scope));
                        $li.append($a);
                        $li.on('click', function ($event) {
                            $event.preventDefault();
                            $scope.$apply(function () {
                                $(event.currentTarget).removeClass('context');
                                $contextMenu.remove();
                                item[1].call($scope, $scope);
                            });
                        });
                    }
                    $ul.append($li);
                });
                $contextMenu.append($ul);
                var height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);
                $contextMenu.css({
                    width: '100%',
                    height: height + 'px',
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    zIndex: 9999
                });
                $(document).find('body').append($contextMenu);
                $contextMenu.on("mousedown", function (e) {
                    if ($(e.target).hasClass('dropdown')) {
                        $(event.currentTarget).removeClass('context');
                        $contextMenu.remove();
                    }
                }).on('contextmenu', function (event) {
                    $(event.currentTarget).removeClass('context');
                    event.preventDefault();
                    $contextMenu.remove();
                });
            };
            return function ($scope, element, attrs) {
                element.on('contextmenu', function (event) {
                    $scope.$apply(function () {
                        event.preventDefault();
                        var options = $scope.$eval(attrs.contextMenu);
                        if (options instanceof Array) {
                            renderContextMenu($scope, event, options);
                        }
                        else {
                            throw '"' + attrs.contextMenu + '" not an array';
                        }
                    });
                });
            };
        });
    })(ContextMenu = Helpers.ContextMenu || (Helpers.ContextMenu = {}));
})(Helpers || (Helpers = {}));
//# sourceMappingURL=ContextMenu.js.map
var DataTable;
(function (DataTable) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        DataTable.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        DataTable.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso : http://plnkr.co/edit/HyBP9d?p=preview
      */
    DataTable.myModule.directive('datatable', ['$compile',
        function ($compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/DataTable/DataTable.tpl.html',
                replace: true,
                transclude: true,
                controller: DataTable.DataTableCtrl
            };
        }
    ]);
})(DataTable || (DataTable = {}));
//# sourceMappingURL=DataTable.js.map
var DataTable;
(function (DataTable) {
    /**
     * Represents a field in the table.
     * The value is the actual displayValue shown, the type is the propertyType type (e.g. number or text, useful when aligning the data), and the header is used for sorting.
     */
    var TableField = (function () {
        function TableField(displayValue, originalValue, type, header) {
            this.displayValue = displayValue;
            this.originalValue = originalValue;
            this.type = type;
            this.header = header;
        }
        return TableField;
    }());
    DataTable.TableField = TableField;
    var DataTableCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function DataTableCtrl($scope, $http, $sce, $translate, $timeout, $layerService, $localStorageService, $messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.$sce = $sce;
            this.$translate = $translate;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$localStorageService = $localStorageService;
            this.$messageBusService = $messageBusService;
            this.mapLabel = 'map';
            this.numberOfItems = 10;
            this.layerOptions = [];
            this.propertyTypes = [];
            this.headers = [];
            this.rows = [];
            // 'vm' stands for 'view model'. We're adding a reference to the controller to the scope
            // for its methods to be accessible from view / HTML
            $scope.vm = this;
            if (this.layerOptions && this.layerOptions.length > 0) {
                $translate('MAP_FEATURES').then(function (translation) {
                    _this.layerOptions[0].title = translation;
                });
            }
            this.bindToStorage('vm.numberOfItems', 10);
            this.numberOfItems = $localStorageService.get('vm.numberOfItems');
            this.bindToStorage('vm.selectedLayerId', this.mapLabel);
            if (this.$layerService.project == null || this.$layerService.project.groups == null)
                return;
            this.updateLayerOptions();
            this.loadLayer();
            this.selectAllBool = false;
            $translate('SELECT_ALL').then(function (translation) {
                _this.selectAllText = translation;
            });
        }
        /**
         * Add a label to local storage and bind it to the scope.
         */
        DataTableCtrl.prototype.bindToStorage = function (label, defaultValue) {
            if (this.$localStorageService.get(label) === null)
                this.$localStorageService.set(label, defaultValue); // You first need to set the key
            this.$localStorageService.bind(this.$scope, label);
        };
        /**
         * Create a list of layer options and select the one used previously.
         */
        DataTableCtrl.prototype.updateLayerOptions = function () {
            var _this = this;
            var chooseLayerOption = {
                'group': '',
                'id': this.mapLabel,
                'title': '' //this.$translate('CHOOSE_CATEGORY')//this.mapFeatureTitle
            };
            this.layerOptions.push(chooseLayerOption);
            this.$translate('CHOOSE_CATEGORY').then(function (translation) {
                chooseLayerOption.title = translation;
            });
            if (this.$layerService.project == null || this.$layerService.project.groups == null)
                return;
            this.$layerService.project.groups.forEach(function (group) {
                group.layers.forEach(function (layer) {
                    _this.layerOptions.push({
                        'group': group.title,
                        'id': layer.id,
                        'title': layer.title
                    });
                });
            });
            for (var layerKey in this.$layerService.loadedLayers) {
                if (this.selectedLayerId == null) {
                    return;
                }
                var layer = this.$layerService.loadedLayers[layerKey];
                if (layer.enabled) {
                    this.selectedLayerId = layer.id;
                }
            }
            ;
            //this.selectedLayerId =  //this.$localStorageService.get('vm.selectedLayerId');
        };
        DataTableCtrl.prototype.loadLayer = function () {
            var _this = this;
            if (!this.selectedLayerId || this.selectedLayerId === this.mapLabel)
                return this.loadMapLayers();
            var selectedLayer = this.findLayerById(this.selectedLayerId);
            if (selectedLayer == null)
                return this.loadMapLayers();
            async.series([
                function (callback) {
                    if (selectedLayer.typeUrl != null) {
                        _this.$layerService.loadTypeResources(selectedLayer.typeUrl, true, function () { return callback(); });
                    }
                    else {
                        callback();
                    }
                },
                function (callback) {
                    _this.$http.get(selectedLayer.url).
                        success(function (data) {
                        _this.processData(selectedLayer, data, callback);
                    }).error(function (data, status, headers, config) {
                        _this.$messageBusService.notify('ERROR opening ' + selectedLayer.title, 'Could not get the data.');
                        if (selectedLayer && selectedLayer.data && selectedLayer.data.features) {
                            _this.processData(selectedLayer, selectedLayer.data, callback);
                        }
                        else {
                            callback();
                        }
                    });
                }
            ]);
        };
        DataTableCtrl.prototype.processData = function (selectedLayer, data, callback) {
            var _this = this;
            this.dataset = data;
            if (data.featureTypes == null)
                data.featureTypes = {};
            if (data.features) {
                data.features.forEach(function (f) {
                    if (f.properties.hasOwnProperty('featureTypeId')) {
                        f.featureTypeName = selectedLayer.typeUrl + '#' + f.properties['featureTypeId'];
                    }
                    else if (selectedLayer.defaultFeatureType != null && selectedLayer.defaultFeatureType !== '') {
                        if (selectedLayer.defaultFeatureType.indexOf('#') > -1) {
                            f.featureTypeName = selectedLayer.defaultFeatureType;
                        }
                        else {
                            f.featureTypeName = selectedLayer.typeUrl + '#' + selectedLayer.defaultFeatureType;
                        }
                    }
                    if (!(f.featureTypeName in data.featureTypes))
                        data.featureTypes[f.featureTypeName] = _this.$layerService.getFeatureType(f);
                });
                this.updatePropertyType(data, selectedLayer);
            }
            callback();
        };
        /**
         * Load the features as visible on the map.
         */
        DataTableCtrl.prototype.loadMapLayers = function () {
            var _this = this;
            this.selectedLayerId = this.mapLabel;
            var data = {
                type: '',
                features: [],
                featureTypes: {}
            };
            // If we are filtering, load the filter results
            this.$layerService.project.groups.forEach(function (group) {
                if (group.filterResult != null)
                    group.filterResult.forEach(function (f) { return data.features.push(f); });
            });
            // Otherwise, take all loaded features
            if (data.features.length === 0)
                data.features = this.$layerService.project.features;
            data.features.forEach(function (f) {
                if (!(f.featureTypeName in data.featureTypes))
                    data.featureTypes[f.featureTypeName] = _this.$layerService.getFeatureType(f);
            });
            this.dataset = data;
            this.updatePropertyType(data);
        };
        DataTableCtrl.prototype.addPropertyType = function (mis, nameLabel, ptd) {
            if (nameLabel === ptd.label) {
                mis.splice(0, 0, ptd);
            }
            else {
                mis.push(ptd);
            }
        };
        DataTableCtrl.prototype.updatePropertyType = function (data, layer) {
            var _this = this;
            this.propertyTypes = [];
            this.headers = [];
            this.rows = [];
            var titles = [], mis = [], featureType, nameLabel;
            for (var key in data.featureTypes) {
                featureType = data.featureTypes[key];
                nameLabel = featureType.style.nameLabel;
                if (featureType._propertyTypeData && featureType._propertyTypeData.length > 0) {
                    featureType._propertyTypeData.forEach(function (ptd) { return _this.addPropertyType(mis, nameLabel, ptd); });
                }
                else if (featureType.propertyTypeKeys) {
                    var keys = featureType.propertyTypeKeys.split(/[,;]+/);
                    keys.forEach(function (k) {
                        var ptd;
                        if (k in _this.$layerService.propertyTypeData) {
                            ptd = _this.$layerService.propertyTypeData[k];
                        }
                        else if (featureType._propertyTypeData) {
                            var result = $.grep(featureType._propertyTypeData, function (e) { return e.label === k; });
                            if (result.length >= 1)
                                ptd = result[0];
                        }
                        if (ptd) {
                            _this.addPropertyType(mis, nameLabel, ptd);
                        }
                    });
                }
                else if (layer && data.features && data.features.length > 0) {
                    var feature = data.features[0];
                    feature.layer = layer;
                    for (var key in feature.properties) {
                        var ptd = this.$layerService.getPropertyType(feature, key);
                        if (ptd) {
                            this.addPropertyType(mis, nameLabel, ptd);
                        }
                    }
                }
                mis.forEach(function (mi) {
                    if ((mi.visibleInCallOut || mi.label === 'Name') && titles.indexOf(mi.title) < 0) {
                        titles.push(mi.title);
                        _this.propertyTypes.push(mi);
                    }
                });
            }
            // Add lat-lon coordinates for point features
            this.propertyTypes.push(csComp.Helpers.GeoExtensions.createPropertyType('Lat'));
            this.propertyTypes.push(csComp.Helpers.GeoExtensions.createPropertyType('Lon'));
            // Select the first couple of headers
            var nmbrOfDefaultSelectedHeaders = 3;
            for (var i = 0; i < nmbrOfDefaultSelectedHeaders; i++) {
                this.headers.push(titles[i]);
            }
            this.rows = this.getRows();
        };
        DataTableCtrl.prototype.toggleSelection = function (propertyTypeTitle) {
            var idx = this.headers.indexOf(propertyTypeTitle);
            if (idx > -1) {
                this.headers.splice(idx, 1);
            }
            else {
                this.headers.push(propertyTypeTitle);
            }
            this.rows = this.getRows();
        };
        DataTableCtrl.prototype.findLayerById = function (id) {
            for (var i = 0; i < this.$layerService.project.groups.length; i++) {
                var group = this.$layerService.project.groups[i];
                for (var j = 0; j < group.layers.length; j++) {
                    var layer = group.layers[j];
                    if (layer.id !== id)
                        continue;
                    return layer;
                }
            }
            return null;
        };
        /**
         * Returns the data rows that are relevant for the current selection.
         */
        DataTableCtrl.prototype.getRows = function () {
            var _this = this;
            var meta = [this.headers.length];
            this.propertyTypes.forEach(function (mi) {
                // Keep headers and mi in the right order
                var index = _this.headers.indexOf(mi.title);
                if (index >= 0)
                    meta[index] = mi;
            });
            var props = [];
            var displayValue;
            if (this.dataset && this.dataset.features) {
                this.dataset.features.forEach(function (f) {
                    var row = [];
                    var text;
                    meta.forEach(function (mi) {
                        if (mi.label === 'Lat') {
                            (f.geometry.type === 'Point') ? displayValue = f.geometry.coordinates[1] : displayValue = '';
                            text = displayValue;
                        }
                        else if (mi.label === 'Lon') {
                            (f.geometry.type === 'Point') ? displayValue = f.geometry.coordinates[0] : displayValue = '';
                            text = displayValue;
                        }
                        else {
                            text = f.properties[mi.label];
                            displayValue = csComp.Helpers.convertPropertyInfo(mi, text);
                        }
                        //if (!text)
                        //    text = ' ';
                        //else if (!$.isNumeric(text))
                        //    text = text.replace(/&amp;/g, '&');
                        //switch (mi.type) {
                        //    case "bbcode":
                        //        displayValue = XBBCODE.process({ text: text }).html;
                        //        break;
                        //    case "number":
                        //        if (!$.isNumeric(text)) displayValue ='??';
                        //        else if (!mi.stringFormat)
                        //            displayValue = text.toString();
                        //        else
                        //            displayValue = String.format(mi.stringFormat, parseFloat(text));
                        //        break;
                        //    default:
                        //        displayValue = text;
                        //        break;
                        //}
                        row.push(new TableField(displayValue, text, mi.type, mi.title));
                    });
                    props.push(row);
                });
            }
            return props;
        };
        /**
         * Generate a font awesome class based on the order.
         */
        DataTableCtrl.prototype.sortOrderClass = function (headerIndex, reverseOrder) {
            var t;
            return (reverseOrder != null && headerIndex === this.sortingColumn)
                ? 'fa fa-sort-' + (reverseOrder ? 'desc' : 'asc')
                : 'fa fa-sort';
            // if (reverseOrder != null && headerIndex === this.sortingColumn) {
            //     t = ('fa fa-sort-' + ((reverseOrder) ? 'desc' : 'asc'));
            // } else {
            //     t = 'fa fa-sort';
            // }
            // return t;
        };
        /**
         * Order the rows based on the header index and the order.
         */
        DataTableCtrl.prototype.orderBy = function (headerIndex, reverseOrder) {
            this.sortingColumn = headerIndex;
            this.rows = this.rows.sort(function (a, b) {
                var order; // Original sort order
                if (a[headerIndex].type === 'number' || a[headerIndex].type === 'date') {
                    order = a[headerIndex].originalValue > b[headerIndex].originalValue;
                }
                else {
                    order = a[headerIndex].originalValue.toLowerCase() > b[headerIndex].originalValue.toLowerCase();
                }
                return order === reverseOrder
                    ? 1
                    : -1;
            });
        };
        DataTableCtrl.prototype.downloadGeoJson = function () {
            var _this = this;
            var geoJsonString = '{"type": "FeatureCollection",' +
                '"featureTypes": ' +
                JSON.stringify(this.dataset.featureTypes, function (key, val) { return (key === '$$hashKey') ? undefined : val; });
            //geoJsonString += ', "features" : [';
            geoJsonString += ', "features": [';
            this.dataset.features.forEach(function (f) {
                var cleanFeature = new csComp.Services.Feature();
                cleanFeature.type = f.type;
                cleanFeature.properties = f.properties;
                cleanFeature.geometry = f.geometry;
                geoJsonString += JSON.stringify(cleanFeature) + ',';
            });
            geoJsonString = geoJsonString.substring(0, geoJsonString.length - 1) + ']}';
            var filename = this.mapLabel;
            if (this.selectedLayerId !== this.mapLabel) {
                var layer = this.findLayerById(this.selectedLayerId);
                if (layer)
                    filename = layer.title.replace(' ', '_');
            }
            this.$timeout(function () {
                var data = _this.$layerService.project.serialize();
                //console.log(data);
                console.log('Save settings: ');
                csComp.Helpers.saveData(geoJsonString, filename, 'json');
            }, 0);
        };
        DataTableCtrl.prototype.downloadCsv = function () {
            var _this = this;
            var csvRows = [];
            csvRows.push(this.headers.join(';'));
            for (var i = 0; i < this.rows.length; i++) {
                csvRows.push(this.rows[i].map(function (f) { return f.originalValue; }).join(';'));
            }
            var csvString = csvRows.join('\r\n');
            var filename = this.mapLabel;
            if (this.selectedLayerId !== this.mapLabel) {
                var layer = this.findLayerById(this.selectedLayerId);
                if (layer)
                    filename = layer.title.replace(' ', '_');
            }
            //this.saveData(csvString, filename + '.csv');
            this.$timeout(function () {
                var data = _this.$layerService.project.serialize();
                //console.log(data);
                console.log('Save settings: ');
                csComp.Helpers.saveData(csvString, filename, 'csv');
            }, 0);
        };
        // private saveData(csvData: string, filename: string) {
        //     if (navigator.msSaveBlob) {
        //         // IE 10+
        //         var link: any = document.createElement('a');
        //         link.addEventListener("click", event => {
        //             var blob = new Blob([csvData], {"type": "text/csv;charset=utf-8;"});
        //             navigator.msSaveBlob(blob, filename);
        //         }, false);
        //         document.body.appendChild(link);
        //         link.click();
        //         document.body.removeChild(link);
        //     } else if (!csComp.Helpers.supportsDataUri()) {
        //         // Older versions of IE: show the data in a new window
        //         var popup = window.open('', 'csv', '');
        //         popup.document.body.innerHTML = '<pre>' + csvData + '</pre>';
        //     } else {
        //         // Support for browsers that support the data uri.
        //         var a: any = document.createElement('a');
        //         document.body.appendChild(a);
        //         a.href = 'data:text/csv;charset=utf-8,' + encodeURI(csvData);
        //         a.target = '_blank';
        //         a.download = filename;
        //         a.click();
        //         document.body.removeChild(a);
        //     }
        // }
        DataTableCtrl.prototype.selectAll = function () {
            var _this = this;
            if (this.selectAllBool) {
                this.$translate('SELECT_ALL').then(function (translation) {
                    _this.selectAllText = translation;
                });
                this.propertyTypes.forEach(function (mi) {
                    var idx = _this.headers.indexOf(mi.title);
                    if (idx > -1) {
                        _this.headers.splice(idx, 1);
                    }
                });
                this.rows = this.getRows();
            }
            else {
                this.$translate('DESELECT_ALL').then(function (translation) {
                    _this.selectAllText = translation;
                });
                this.propertyTypes.forEach(function (mi) {
                    if (_this.headers.indexOf(mi.title) <= -1) {
                        _this.headers.push(mi.title);
                    }
                });
                this.rows = this.getRows();
            }
            this.selectAllBool = !this.selectAllBool;
        };
        /**
         * Convert to trusted html string.
         */
        DataTableCtrl.prototype.toTrusted = function (html) {
            try {
                if (html === undefined || html === null)
                    return this.$sce.trustAsHtml(html);
                return this.$sce.trustAsHtml(html.toString());
            }
            catch (e) {
                console.log(e + ': ' + html);
                return '';
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        DataTableCtrl.$inject = [
            '$scope',
            '$http',
            '$sce',
            '$translate',
            '$timeout',
            'layerService',
            'localStorageService',
            'messageBusService'
        ];
        return DataTableCtrl;
    }());
    DataTable.DataTableCtrl = DataTableCtrl;
})(DataTable || (DataTable = {}));
//# sourceMappingURL=DataTableCtrl.js.map
var EventTab;
(function (EventTab) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        EventTab.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        EventTab.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    EventTab.myModule.directive('eventtab', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/EventTab/EventTab.tpl.html',
                replace: true,
                transclude: true,
                controller: EventTab.EventTabCtrl
            };
        }
    ]);
})(EventTab || (EventTab = {}));
//# sourceMappingURL=EventTab.js.map
var EventTab;
(function (EventTab) {
    var EventTabCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function EventTabCtrl($scope, $location, $sce, $mapService, $layerService, $messageBusService, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$location = $location;
            this.$sce = $sce;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$translate = $translate;
            /**
             * Callback function
             * @see {http://stackoverflow.com/questions/12756423/is-there-an-alias-for-this-in-typescript}
             * @see {http://stackoverflow.com/questions/20627138/typescript-this-scoping-issue-when-called-in-jquery-callback}
             * @todo {notice the strange syntax using a fat arrow =>, which is to preserve the this reference in a callback!}
             */
            this.sidebarMessageReceived = function (title) {
                switch (title) {
                    case 'toggle':
                        _this.$scope.showMenu = !_this.$scope.showMenu;
                        break;
                    case 'show':
                        _this.$scope.showMenu = true;
                        break;
                    case 'hide':
                        _this.$scope.showMenu = false;
                        break;
                    default:
                        break;
                }
                // NOTE EV: You need to call apply only when an event is received outside the angular scope.
                // However, make sure you are not calling this inside an angular apply cycle, as it will generate an error.
                if (_this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest') {
                    _this.$scope.$apply();
                }
            };
            this.scope = $scope;
            $scope.vm = this;
            $scope.showMenu = false;
            var columnFilter = {
                layerId: 'eventlayerid',
                prio: 1,
                roles: [],
                tags: []
            };
            var column = {
                title: 'Log',
                showFeatureTags: true,
                id: 'eventtab',
                filters: columnFilter,
                roles: [],
                fields: { 'title': 'Name', 'updated': 'updated', 'prio': 'prio', 'description': 'description' },
                propertyTags: ['layerTitle', 'state'],
                timeReference: 'timeline',
                orderBy: 'Updated',
                actions: null,
                canShare: false
            };
            this.kanban = {
                featureTypesToAdd: [],
                columns: [column],
                canAdd: false
            };
            // Don't flood the messagebus, but cache all items and send them together after a second
            this.debounceSendItems = _.debounce(this.sendTimelineItems, 1000);
            this.tlItems = [];
            this.newItems = [];
            this.tlGroups = [];
            this.$messageBusService.subscribe('eventtab', function (topic, value) {
                if (!value || !topic)
                    return;
                switch (topic) {
                    case 'updated':
                        _this.addEvent(value);
                        break;
                    case 'added':
                        _this.addEvent(value);
                        break;
                    case 'reset':
                        _this.reset();
                        break;
                    case 'zoomto':
                        _this.zoomTo(value);
                        break;
                    default:
                        console.log('EventTab: Event type not found');
                }
            });
            this.init();
        }
        /**
         * Initialize an eventTab. Create a layer that contains all messages (features)
         */
        EventTabCtrl.prototype.init = function () {
            var l = new csComp.Services.ProjectLayer();
            l.url = '';
            l.id = 'eventlayerid';
            l.title = 'EventLayer';
            l.enabled = false;
            l.type = 'geojson';
            l.data = {};
            l.data.features = [];
            l.isDynamic = false;
            this.layer = l;
        };
        EventTabCtrl.prototype.reset = function () {
            this.tlItems = [];
            this.newItems = [];
            this.tlGroups = [];
            this.sendTimelineItems();
            this.sendTimelineGroups();
            this.layer.data.features = [];
        };
        EventTabCtrl.prototype.addUpdateEvent = function (f) {
            var foundFeature;
            this.layer.data.features.some(function (sf) {
                if (sf.id === f.id) {
                    foundFeature = sf;
                    return true;
                }
                return false;
            });
            foundFeature.properties['updated'] = new Date();
        };
        /**
         * Add a card-item to the event list. Provide a feature, and optionally some property-keys of data you want to display.
         */
        EventTabCtrl.prototype.addEvent = function (data) {
            var f = data.feature;
            var config = data.config;
            var titleKey = (!config.titleKey) ? 'Name' : config.titleKey;
            var descriptionKey = (!config.descriptionKey) ? 'state' : config.descriptionKey;
            var dateKey = (!config.dateKey) ? 'timeline' : config.dateKey;
            //Create event feature
            var newF = new csComp.Services.Feature();
            newF.layer = this.layer;
            newF.geometry = f.geometry;
            newF.fType = f.fType;
            newF.effectiveStyle = f.effectiveStyle;
            newF.type = f.type;
            newF.id = csComp.Helpers.getGuid();
            newF._gui = f._gui;
            newF.properties = f.properties;
            // Try to find propertytype for description label
            var pts = csComp.Helpers.getPropertyTypes(f.fType, {});
            var descrText;
            pts.some(function (p) {
                if (p.hasOwnProperty && p.hasOwnProperty('label') && p.label === descriptionKey && p.hasOwnProperty('options')) {
                    descrText = p.options[newF.properties[descriptionKey]];
                    return true;
                }
                return false;
            });
            // Set the item date
            if (dateKey === 'timeline') {
                newF.properties['date'] = new Date(this.$layerService.project.timeLine.focus);
                newF.properties['updated'] = new Date(this.$layerService.project.timeLine.focus);
            }
            else {
                newF.properties['date'] = new Date(newF.properties[dateKey]);
                newF.properties['updated'] = new Date(newF.properties[dateKey]);
            }
            newF.properties['layerTitle'] = (f.layer) ? f.layer.id : '';
            if (!newF.properties.hasOwnProperty('tags'))
                newF.properties['tags'] = [];
            this.kanban.columns[0].propertyTags.forEach(function (tag) {
                if (newF.properties.hasOwnProperty(tag)) {
                    pts.some(function (p) {
                        if (p.hasOwnProperty && p.hasOwnProperty('label') && p.label === descriptionKey) {
                            newF.properties['tags'].push(csComp.Helpers.convertPropertyInfo(p, newF.properties[tag]));
                            return true;
                        }
                        return false;
                    });
                }
            });
            newF.properties['description'] = (descrText ? descrText : newF.properties[descriptionKey]);
            newF.layerId = 'eventlayerid';
            this.addTimelineItem(newF);
            this.layer.data.features.push(newF);
        };
        EventTabCtrl.prototype.addTimelineItem = function (f) {
            var timelineItem = {
                start: f.properties['updated'],
                content: f.properties['Name'],
                id: f.id,
                group: f.fType.name
            };
            // Check if group exists on timeline, otherwise create it
            if (!this.tlGroups.some(function (g) { return timelineItem.group === g.title; })) {
                var timelineGroup = {
                    content: f.fType.name,
                    id: f.fType.name,
                    title: f.fType.name
                };
                this.tlGroups.push(timelineGroup);
                this.sendTimelineGroups();
            }
            this.newItems.push(timelineItem);
            this.debounceSendItems();
        };
        EventTabCtrl.prototype.mergeItems = function () {
            var _this = this;
            //Sort items per group
            var changedGroups = {};
            this.newItems.forEach(function (i) {
                if (changedGroups.hasOwnProperty(i.group)) {
                    changedGroups[i.group].push(i);
                }
                else {
                    changedGroups[i.group] = [i];
                }
            });
            Object.keys(changedGroups).forEach(function (key) {
                if (changedGroups[key].length === 1) {
                    // If there is 1 item, send the raw item
                    _this.tlItems.push(changedGroups[key][0]);
                }
                else if (changedGroups[key].length > 1) {
                    // else merge items
                    var mergedItem = changedGroups[key][0];
                    mergedItem['content'] = changedGroups[key].length.toString() + ' ' + changedGroups[key][0].group + ' updates';
                    _this.tlItems.push(mergedItem);
                }
            });
            this.newItems = [];
        };
        EventTabCtrl.prototype.sendTimelineItems = function () {
            this.mergeItems();
            this.$messageBusService.publish('timeline', 'setItems', this.tlItems);
        };
        EventTabCtrl.prototype.sendTimelineGroups = function () {
            this.$messageBusService.publish('timeline', 'setGroups', this.tlGroups);
        };
        EventTabCtrl.prototype.zoomTo = function (data) {
            if (!data.hasOwnProperty('id'))
                return;
            var foundFeature;
            this.layer.data.features.some(function (f) {
                if (f.id === data.id) {
                    foundFeature = f;
                    return true;
                }
                return false;
            });
            if (foundFeature) {
                this.$mapService.zoomTo(foundFeature, this.$mapService.map.getZoom());
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        EventTabCtrl.$inject = [
            '$scope',
            '$location',
            '$sce',
            'mapService',
            'layerService',
            'messageBusService',
            '$translate'
        ];
        return EventTabCtrl;
    }());
    EventTab.EventTabCtrl = EventTabCtrl;
})(EventTab || (EventTab = {}));
//# sourceMappingURL=EventTabCtrl.js.map
var ExpertMode;
(function (ExpertMode) {
    /**
  * Config
  */
    var moduleName = 'csComp';
    try {
        ExpertMode.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ExpertMode.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to set the expert mode, so we can determine what the user should see (degree of difficulty).
      * The expert mode can either be set manually, e.g. using this directive, or by setting the expertMode property in the
      * project.json file. In neither are set, we assume that we are dealing with an expert, so all features should be enabled.
      *
      * Precedence:
      * - when a declaration is absent, assume Expert.
      * - when the mode is set in local storage, take that value.
      * - when the mode is set in the project.json file, take that value.
      *
      * As we want the expertMode to be always available, we have added it to the MapService service.
      */
    ExpertMode.myModule
        .directive('expertMode', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/ExpertMode/ExpertMode.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                //link: function (scope, element, attrs) {
                //     // Since we are wrapping the rating directive in this directive, I couldn't use transclude,
                //     // so I copy the existing attributes manually.
                //     var attributeString = '';
                //     for (var key in attrs) {
                //         if (key.substr(0, 1) !== '$' && attrs.hasOwnProperty(key)) attributeString += key + '="' + attrs[key] + '" ';
                //     }
                //     var html = '<rating ng-model="expertMode" '
                //         + attributeString
                //         + 'tooltip-html-unsafe="{{\'EXPERTMODE.EXPLANATION\' | translate}}" tooltip-placement="bottom" tooltip-trigger="mouseenter" tooltip-append-to-body="false"'
                //         + 'max="3"></rating>';
                //     var e = $compile(html)(scope);
                //     element.replaceWith(e);
                // },
                replace: true,
                transclude: true,
                controller: ExpertMode.ExpertModeCtrl
            };
        }
    ]);
})(ExpertMode || (ExpertMode = {}));
//# sourceMappingURL=ExpertMode.js.map
var ExpertMode;
(function (ExpertMode) {
    var Expertise = csComp.Services.Expertise;
    var ExpertModeCtrl = (function () {
        function ExpertModeCtrl($scope, $localStorageService, $layerService, $mapService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$localStorageService = $localStorageService;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBus = $messageBus;
            $scope.vm = this;
            $scope.expertMode = $mapService.expertMode;
            $messageBus.subscribe('expertMode', function (title, mode) {
                if (title !== 'newExpertise')
                    return;
                $scope.expertMode = mode;
            });
            $messageBus.subscribe('project', function (action, value) {
                if (_this.$layerService.project)
                    _this.$scope.enabled = _this.$layerService.project.exportModeSelectionEnabled;
            });
            $scope.$watch('expertMode', function () {
                _this.setExpertMode($scope.expertMode);
            });
        }
        /**
        * Get the CSS class to render the mode.
        */
        ExpertModeCtrl.prototype.getCssClass = function () {
            switch (this.$mapService.expertMode) {
                case Expertise.Beginner:
                    return 'beginnerUserIcon';
                case Expertise.Intermediate:
                    return 'intermediateUserIcon';
                case Expertise.Expert:
                    return 'expertUserIcon';
                case Expertise.Admin:
                    return 'adminExpertUserIcon';
            }
        };
        /**
        * Set the expert mode: although we assume that each directive is responsible for managing it by listening
        * to the expertMode.newExpertise message, we already set some common options here.
        * This is to reduce the dependency on this directive.
        */
        ExpertModeCtrl.prototype.setExpertMode = function (expertMode) {
            this.$messageBus.publish('expertMode', 'newExpertise', expertMode);
        };
        ExpertModeCtrl.$inject = [
            '$scope',
            'localStorageService',
            'layerService',
            'mapService',
            'messageBusService'
        ];
        return ExpertModeCtrl;
    }());
    ExpertMode.ExpertModeCtrl = ExpertModeCtrl;
})(ExpertMode || (ExpertMode = {}));
//# sourceMappingURL=ExpertModeCtrl.js.map
var FeatureList;
(function (FeatureList) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        FeatureList.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FeatureList.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    FeatureList.myModule.directive('featureList', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/FeatureList/FeatureList.tpl.html',
                //compile             : el          => {    // I need to explicitly compile it in order to use interpolation like {{xxx}}
                //    var fn                        = $compile(el);
                //    return scope                  => {
                //        fn(scope);
                //    };
                //},
                // Directives that want to modify the DOM typically use the link option.link takes a function with the following signature, function link(scope, element, attrs) { ... } where:
                // scope is an Angular scope object.
                // element is the jqLite - wrapped element that this directive matches.
                // attrs is a hash object with key - value pairs of normalized attribute names and their corresponding attribute values.
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: true,
                transclude: true,
                controller: FeatureList.FeatureListCtrl
            };
        }
    ]).directive('bsPopover', function () {
        return function (scope, element, attrs) {
            element.find("a[rel=popover]").popover({ placement: 'right', html: 'true' });
        };
    });
})(FeatureList || (FeatureList = {}));
//# sourceMappingURL=FeatureList.js.map
var FeatureList;
(function (FeatureList) {
    var FeatureListCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function FeatureListCtrl($scope, $layerService, $mapService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            $scope.vm = this;
            $scope.numberOfItems = 10; // This is being reset in the directive upon receiving a resize.
        }
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        FeatureListCtrl.$inject = [
            '$scope',
            'layerService',
            'mapService'
        ];
        return FeatureListCtrl;
    }());
    FeatureList.FeatureListCtrl = FeatureListCtrl;
})(FeatureList || (FeatureList = {}));
//# sourceMappingURL=FeatureListCtrl.js.map
var FeatureProps;
(function (FeatureProps) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        FeatureProps.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FeatureProps.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    FeatureProps.myModule.directive('featureprops', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/FeatureProps/FeatureProps.tpl.html',
                replace: true,
                transclude: true,
                controller: FeatureProps.FeaturePropsCtrl
            };
        }
    ]);
})(FeatureProps || (FeatureProps = {}));
//# sourceMappingURL=FeatureProps.js.map
var FeatureProps;
(function (FeatureProps) {
    var FeaturePropsOptions = (function () {
        function FeaturePropsOptions(position) {
            this.position = position;
            this.closeButton = true;
            this.autoPan = true;
        }
        return FeaturePropsOptions;
    }());
    var CallOutProperty = (function () {
        function CallOutProperty(key, value, property, canFilter, canStyle, canShowStats, feature, isFilter, isSensor, description, propertyType, timestamps, sensor, isDraft) {
            this.key = key;
            this.value = value;
            this.property = property;
            this.canFilter = canFilter;
            this.canStyle = canStyle;
            this.canShowStats = canShowStats;
            this.feature = feature;
            this.isFilter = isFilter;
            this.isSensor = isSensor;
            this.description = description;
            this.propertyType = propertyType;
            this.timestamps = timestamps;
            this.sensor = sensor;
            this.isDraft = isDraft;
            this.cors = {};
            this._id = csComp.Helpers.getGuid();
        }
        return CallOutProperty;
    }());
    FeatureProps.CallOutProperty = CallOutProperty;
    var CallOutSection = (function () {
        function CallOutSection(sectionIcon) {
            this.propertyTypes = {};
            this.properties = [];
            this.sectionIcon = sectionIcon;
        }
        CallOutSection.prototype.showSectionIcon = function () { return !csComp.StringExt.isNullOrEmpty(this.sectionIcon); };
        CallOutSection.prototype.addProperty = function (key, value, property, canFilter, canStyle, canShowStats, feature, isFilter, description, propertyType, isDraft) {
            var isSensor = feature.sensors && feature.sensors.hasOwnProperty(property);
            if (isSensor) {
                this.properties.push(new CallOutProperty(key, value, property, canFilter, canStyle, canShowStats, feature, isFilter, isSensor, description
                    ? description
                    : null, propertyType, feature.timestamps, feature.sensors[property], isDraft));
            }
            else {
                this.properties.push(new CallOutProperty(key, value, property, canFilter, canStyle, canShowStats, feature, isFilter, isSensor, description
                    ? description
                    : null, propertyType, null, null, isDraft));
            }
        };
        CallOutSection.prototype.hasProperties = function () {
            return this.properties != null && this.properties.length > 0;
        };
        return CallOutSection;
    }());
    FeatureProps.CallOutSection = CallOutSection;
    var CallOut = (function () {
        function CallOut(type, feature, propertyTypeData, layerservice, mapservice) {
            var _this = this;
            this.type = type;
            this.feature = feature;
            this.propertyTypeData = propertyTypeData;
            this.layerservice = layerservice;
            this.mapservice = mapservice;
            this.sections = {};
            this.sectionKeys = [];
            this.hasInfoSection = false;
            //if (type == null) this.createDefaultType();
            this.setTitle();
            this.setIcon(feature);
            var infoCallOutSection = new CallOutSection('fa-info');
            //var searchCallOutSection = new CallOutSection('fa-filter');
            var linkCallOutSection = new CallOutSection('fa-link');
            var displayValue;
            if (type != null) {
                var missing;
                //var propertyTypes = csComp.Helpers.getPropertyTypes(type, propertyTypeData);
                //if (propertyTypes.length === 0) { for (var pt in layerservice.propertyTypeData) propertyTypes.push(layerservice.propertyTypeData[pt]); };
                // if (type.showAllProperties || this.mapservice.isAdminExpert) {
                //     missing = csComp.Helpers.getMissingPropertyTypes(feature);
                //     // missing.forEach((pt: csComp.Services.IPropertyType) => {
                //     //     if (!propertyTypes.some(((p: csComp.Services.IPropertyType) => p.label === pt.label))) {
                //     //         propertyTypes.push(pt);
                //     //     }
                //     // });
                // }
                // if feature type has propertyTypeKeys defined use these to show the order of the properties
                if (feature.fType.propertyTypeKeys) {
                    feature.fType._propertyTypeData.forEach(function (mi) {
                        if (feature.properties.hasOwnProperty(mi.label) || mi.type === 'relation') {
                            if (mi.visibleInCallOut)
                                _this.addProperty(mi, feature, infoCallOutSection, linkCallOutSection);
                        }
                    });
                    if (feature.fType.showAllProperties || this.mapservice.isAdminExpert) {
                        for (var key in feature.properties) {
                            var mi = csComp.Helpers.getPropertyType(feature, key);
                            this.addProperty(mi, feature, infoCallOutSection, linkCallOutSection, true);
                        }
                    }
                }
                else {
                    for (var key in feature.properties) {
                        var mi = layerservice.getPropertyType(feature, key);
                        if (mi) {
                            this.addProperty(mi, feature, infoCallOutSection, linkCallOutSection);
                        }
                        else if (feature.fType.showAllProperties || this.mapservice.isAdminExpert) {
                            var prop = csComp.Helpers.getPropertyType(feature, key);
                            this.addProperty(prop, feature, infoCallOutSection, linkCallOutSection, true);
                        }
                    }
                }
            }
            if (infoCallOutSection.properties.length > 0) {
                this.hasInfoSection = true;
                this.sections['Aaa Info'] = infoCallOutSection; // The AAA is added as the sections are sorted alphabetically (not anymore in angular 1.4!!!)
                this.sectionKeys.push('Aaa Info');
            }
            else {
                this.hasInfoSection = false;
            }
            if (linkCallOutSection.properties.length > 0) {
                this.sections['linkedfeatures'] = linkCallOutSection;
                this.sectionKeys.push('linkedfeatures');
            }
            //if (searchCallOutSection.properties.length > 0) {this.sections['zzz Search'] = searchCallOutSection; this.sectionKeys.push('zzz Search');}
            this.sectionKeys = this.sectionKeys.sort();
        }
        CallOut.prototype.addProperty = function (mi, feature, infoCallOutSection, linkCallOutSection, isDraft) {
            if (isDraft === void 0) { isDraft = false; }
            var callOutSection = this.getOrCreateCallOutSection(mi.section) || infoCallOutSection;
            if (callOutSection.propertyTypes.hasOwnProperty(mi.label))
                return; // Prevent duplicate properties in the same  section
            callOutSection.propertyTypes[mi.label] = mi;
            var text = feature.properties[mi.label];
            if (mi.type === 'relation' && mi.visibleInCallOut && feature._gui && feature._gui['relations']) {
                if (feature._gui['relations'].hasOwnProperty(mi.label)) {
                    var results = feature._gui['relations'][mi.label];
                    var fPropType = { type: 'feature', label: 'relatedfeature' };
                    results.forEach(function (res) {
                        fPropType.title = mi.title;
                        linkCallOutSection.addProperty(res.id, csComp.Helpers.getFeatureTitle(res), fPropType.label, false, false, false, res, false, mi.description, fPropType);
                    });
                }
            }
            var displayValue = csComp.Helpers.convertPropertyInfo(mi, text);
            // Skip empty, non-editable values
            if (!mi.canEdit && csComp.StringExt.isNullOrEmpty(displayValue))
                return;
            var canFilter = (mi.type === 'number' || mi.type === 'text' || mi.type === 'options' || mi.type === 'date' || mi.type === 'boolean');
            if (mi.filterType)
                canFilter = mi.filterType.toLowerCase() !== 'none';
            var canStyle = (mi.type === 'number' || mi.type === 'options' || mi.type === 'color');
            if (mi.styleType)
                canStyle = mi.styleType.toLowerCase() !== 'none';
            var canShowStats = (typeof mi.canShowStats === 'undefined') || mi.canShowStats;
            if (mi.visibleInCallOut) {
                callOutSection.addProperty(mi.title, displayValue, mi.label, canFilter, canStyle, canShowStats, feature, false, mi.description, mi, isDraft);
            }
            //searchCallOutSection.addProperty(mi.title, displayValue, mi.label, canFilter, canStyle, feature, false, mi.description);
        };
        CallOut.prototype.sectionCount = function () {
            return this.sectionKeys.length;
        };
        CallOut.prototype.firstSection = function () {
            var first = this.sections[this.sectionKeys[0]];
            return first;
        };
        CallOut.prototype.lastSection = function () {
            var last = this.sections[this.sectionKeys[this.sectionKeys.length - 1]];
            return last;
        };
        CallOut.prototype.getOrCreateCallOutSection = function (sectionTitle) {
            if (!sectionTitle) {
                return null;
            }
            if (sectionTitle in this.sections)
                return this.sections[sectionTitle];
            this.sections[sectionTitle] = new CallOutSection();
            this.sectionKeys.push(sectionTitle);
            return this.sections[sectionTitle];
        };
        /**
         * Set the title of the callout to the title of the feature.
         */
        CallOut.prototype.setTitle = function () {
            this.title = csComp.Helpers.featureTitle(this.type, this.feature);
        };
        CallOut.prototype.setIcon = function (feature) {
            this.icon = (this.type == null || this.type.style == null || !this.type.style.hasOwnProperty('iconUri') || this.type.style.iconUri.toLowerCase().indexOf('_media') >= 0)
                ? ''
                : this.type.style.iconUri.indexOf('{') >= 0
                    ? csComp.Helpers.convertStringFormat(feature, this.type.style.iconUri)
                    : this.type.style.iconUri;
        };
        return CallOut;
    }());
    FeatureProps.CallOut = CallOut;
    var FeaturePropsCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function FeaturePropsCtrl($scope, $location, $sce, $mapService, $layerService, $messageBusService, $translate, $compile) {
            var _this = this;
            this.$scope = $scope;
            this.$location = $location;
            this.$sce = $sce;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$translate = $translate;
            this.$compile = $compile;
            // list of active stats/charts properties, used when switching between features to keep active stats open
            this.showMore = [];
            this.showChart = [];
            this.updateAllStatsDelay = _.debounce(this.updateAllStats, 500);
            this.updateStatsDelay = function (prop) { _.debounce(_this.getPropStats, 500, true); };
            /**
             * Callback function
             * @see {http://stackoverflow.com/questions/12756423/is-there-an-alias-for-this-in-typescript}
             * @see {http://stackoverflow.com/questions/20627138/typescript-this-scoping-issue-when-called-in-jquery-callback}
             * @todo {notice the strange syntax using a fat arrow =>, which is to preserve the this reference in a callback!}
             */
            this.sidebarMessageReceived = function (title) {
                //console.log('sidebarMessageReceived');
                switch (title) {
                    case 'toggle':
                        _this.$scope.showMenu = !_this.$scope.showMenu;
                        break;
                    case 'show':
                        _this.$scope.showMenu = true;
                        break;
                    case 'hide':
                        _this.$scope.showMenu = false;
                        break;
                    default:
                }
                // NOTE EV: You need to call apply only when an event is received outside the angular scope.
                // However, make sure you are not calling this inside an angular apply cycle, as it will generate an error.
                if (_this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest') {
                    _this.$scope.$apply();
                }
            };
            this.featureMessageReceived = function (title, feature) {
                var callApply = true;
                switch (title) {
                    case 'onFeatureDeselect':
                        if (_this.$layerService.selectedFeatures.length === 0) {
                            _this.$layerService.visual.rightPanelVisible = false;
                        }
                        else {
                            _this.updateAllStats();
                        }
                        break;
                    case 'onFeatureSelect':
                        callApply = false;
                        _this.displayFeature(feature);
                        _this.$scope.feature = _this.$layerService.lastSelectedFeature;
                        //this.$layerService.visual.rightPanelVisible = true;
                        _this.updateAllStats();
                        if (_this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest') {
                            _this.$scope.$root.$apply();
                        }
                        break;
                    case 'onRelationsUpdated':
                        _this.setShowSimpleTimeline();
                        _this.displayFeature(feature);
                        _this.updateHierarchyLinks(feature);
                        _this.$scope.feature = feature;
                        _this.$scope.autocollapse(true);
                        break;
                    case 'onFeatureUpdated':
                        _this.displayFeature(_this.$layerService.lastSelectedFeature);
                        _this.$scope.feature = _this.$layerService.lastSelectedFeature;
                        break;
                    case 'onFeatureRemoved':
                        if (feature === _this.$layerService.lastSelectedFeature)
                            _this.$messageBusService.publish('rightpanel', 'deactiveContainer', 'featureprops');
                        break;
                }
                if (callApply && _this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest') {
                    _this.$scope.$root.$apply();
                }
            };
            this.timestamps = new Array();
            this.setDropdownTitle();
            //this.$layerService.addLayer();
            this.scope = $scope;
            $scope.vm = this;
            $scope.showMenu = false;
            $scope.featureTabActivated = function (sectionTitle, section) {
                $messageBusService.publish('FeatureTab', 'activated', { sectionTitle: sectionTitle, section: section });
            };
            //$messageBusService.subscribe('sidebar', this.sidebarMessageReceived);
            console.log('init featurepropsctrl');
            $messageBusService.subscribe('feature', this.featureMessageReceived);
            var widthOfList = function () {
                var itemsWidth = 0;
                $('#featureTabs>li').each(function () {
                    var itemWidth = $(this).outerWidth();
                    itemsWidth += itemWidth;
                });
                return itemsWidth;
            };
            $scope.autocollapse = function (initializeTabPosition) {
                if (initializeTabPosition === void 0) { initializeTabPosition = false; }
                var tabs = $('#featureTabs');
                if (tabs.outerWidth() < widthOfList() || parseFloat(tabs.css('margin-left')) < 0) {
                    $('#leftArr').show();
                    $('#rightArr').show();
                    if (initializeTabPosition) {
                        tabs.animate({ 'margin-left': '20px' }, 'slow');
                    }
                }
                else {
                    $('#leftArr').hide();
                    $('#rightArr').hide();
                    if (initializeTabPosition) {
                        tabs.animate({ 'margin-left': '0px' }, 'slow');
                    }
                }
            };
            $scope.autocollapse(true); // when document first loads
            $scope.tabs = $('#featureTabs');
            $scope.tabScrollDelta = $scope.tabs.outerWidth();
            this.displayFeature(this.$layerService.lastSelectedFeature);
            this.$scope.feature = this.$layerService.lastSelectedFeature;
            this.$messageBusService.subscribe('timeline', function (action, value) {
                if (action === 'updateFeatures' && _this.$scope.callOut) {
                    _this.updateAllStatsDelay();
                }
            });
        }
        FeaturePropsCtrl.prototype.updateAllStats = function () {
            var _this = this;
            if (!this.$scope.callOut)
                return;
            for (var s in this.$scope.callOut.sections) {
                var section = this.$scope.callOut.sections[s];
                section.properties.forEach(function (prop) {
                    if (prop.showMore) {
                        _this.updateStatsDelay(prop);
                    }
                });
            }
        };
        FeaturePropsCtrl.prototype.saveFeatureType = function () {
            var resource = this.$layerService.findResourceByFeature(this.$scope.feature);
            if (resource) {
                this.$layerService.saveResource(resource);
            }
        };
        FeaturePropsCtrl.prototype.savePropertyType = function (item) {
            var propType = item.propertyType;
            console.log('saving property');
            console.log(propType);
            var resource = this.$layerService.findResourceByFeature(this.$scope.feature);
            if (item.isDraft) {
                var key = csComp.Helpers.getPropertyKey(item.feature.fType.propertyTypeKeys, item.property);
                resource.propertyTypeData[key] = propType;
                item.feature.fType.propertyTypeKeys += ';' + key;
                item.isDraft = false;
                this.$layerService.propertyTypeData[key] = propType;
            }
            this.$layerService.saveResource(resource);
            this.displayFeature(this.$scope.feature);
        };
        FeaturePropsCtrl.prototype.selectProperty = function (prop, $event) {
            this.lastSelectedProperty = prop;
            $event.stopPropagation();
        };
        FeaturePropsCtrl.prototype.openImage = function (img) {
            window.open(img, 'mywindow', 'width=600');
        };
        FeaturePropsCtrl.prototype.saveFeature = function () {
            this.$layerService.unlockFeature(this.$scope.feature);
            this.$layerService.saveFeature(this.$scope.feature, true);
            this.$layerService.updateFeature(this.$scope.feature);
            this.displayFeature(this.$layerService.lastSelectedFeature);
        };
        FeaturePropsCtrl.prototype.startEditFeature = function () {
            this.$scope.feature._gui['editMode'] = true;
            this.$layerService.updateFeature(this.$scope.feature);
        };
        FeaturePropsCtrl.prototype.editFeature = function () {
            var rpt = csComp.Helpers.createRightPanelTab('featuretype', 'featuretype', this.$layerService.lastSelectedFeature, 'Edit group');
            this.$messageBusService.publish('rightpanel', 'activate', rpt);
            this.$layerService.updateFeature(this.$layerService.lastSelectedFeature);
        };
        FeaturePropsCtrl.prototype.setFilter = function (item, $event) {
            this.$layerService.setPropertyFilter(item);
            $event.stopPropagation();
        };
        FeaturePropsCtrl.prototype.toTrusted = function (html) {
            try {
                if (html === undefined || html === null)
                    return this.$sce.trustAsHtml(html);
                return this.$sce.trustAsHtml(html.toString());
            }
            catch (e) {
                console.log(e + ': ' + html);
                return '';
            }
        };
        FeaturePropsCtrl.prototype.openLayer = function (property) {
            if (property.feature != null && property.feature.properties.hasOwnProperty(property.propertyType.label)) {
                var link = property.feature.properties[property.propertyType.label];
            }
        };
        FeaturePropsCtrl.prototype.setCorrelation = function (item, $event) {
            $event.stopPropagation();
            var values = this.$layerService.getPropertyValues(item.feature.layer, item.property);
            for (var s in this.$scope.callOut.sections) {
                var sec = this.$scope.callOut.sections[s];
                sec.properties.forEach(function (p) {
                    if (p.property !== item.property) {
                        var c = vg.util.cor(values, item.property, p.property);
                        p.cors[item.property] = {
                            property: item.property,
                            value: c
                        };
                    }
                });
            }
        };
        FeaturePropsCtrl.prototype.addSparkline = function (item) {
            var ch = $('#featurepropchart_' + item._id);
            ch.empty();
            if (this.showChart.indexOf(item.property) < 0)
                this.showChart.push(item.property);
            var ns = this.$scope;
            ns.item = item;
            // create sparkline
            try {
                var chartElement = this.$compile('<sparkline-chart timestamps="item.timestamps" smooth="false" closed="false" sensor="item.sensor" width="320" height="100" showaxis="true"></sparkline-chart>')(ch.scope());
                ch.append(chartElement);
            }
            catch (e) {
                console.log('Error adding sparkline');
            }
        };
        FeaturePropsCtrl.prototype.createSparkLineChart = function (item) {
            item.showChart = !item.showChart;
            if (item.showChart) {
                this.addSparkline(item);
            }
            else {
                var ch = $('#featurepropchart_' + item._id);
                ch.empty();
            }
        };
        FeaturePropsCtrl.prototype.getPropStats = function (item) {
            if (item.showMore) {
                //console.log('stats: calc stats for ' + item.property);
                if (this.showMore.indexOf(item.property) < 0)
                    this.showMore.push(item.property);
                var values = this.$layerService.getPropertyValues(item.feature.layer, item.property);
                var d = item.property;
                var res = vg.util.summary(values, [item.property]);
                item.stats = res[0];
                item.stats.sum = item.stats.count * item.stats.mean;
            }
            else {
                if (this.showMore.indexOf(item.property) >= 0)
                    this.showMore = this.showMore.filter(function (s) { return s !== item.property; });
            }
        };
        FeaturePropsCtrl.prototype.displayFeature = function (feature) {
            var _this = this;
            if (!feature)
                return;
            this.featureType = feature.fType;
            //this.featureType.id
            // If we are dealing with a sensor, make sure that the feature's timestamps are valid so we can add it to a chart
            if (typeof feature.sensors !== 'undefined' && typeof feature.timestamps === 'undefined')
                feature.timestamps = this.$layerService.findLayer(feature.layerId).timestamps;
            this.$scope.callOut = new CallOut(this.featureType, feature, this.$layerService.propertyTypeData, this.$layerService, this.$mapService);
            if (this.showMore.length > 0 || this.showChart.length > 0) {
                for (var s in this.$scope.callOut.sections) {
                    var sec = this.$scope.callOut.sections[s];
                    sec.properties.forEach(function (p) {
                        p.showMore = _this.showMore.indexOf(p.property) >= 0;
                        p.showChart = _this.showChart.indexOf(p.property) >= 0;
                        if (p.showChart)
                            _this.addSparkline(p);
                        if (p.showMore)
                            _this.getPropStats(p);
                    });
                }
            }
        };
        FeaturePropsCtrl.prototype.removeFeature = function () {
            this.$layerService.removeFeature(this.$scope.feature, true);
        };
        FeaturePropsCtrl.prototype.updateHierarchyLinks = function (feature) {
            var _this = this;
            if (!feature)
                return;
            // Add properties defined inside of layers to the project-wide properties.
            this.$layerService.project.groups.forEach(function (group) {
                group.layers.forEach(function (l) {
                    if (l.type === 'hierarchy' && l.enabled) {
                        if ((l.data) && (l.data).features) {
                            (l.data).features[0].fType.propertyTypeData.forEach(function (pt) {
                                if (pt.type === 'hierarchy') {
                                    if (pt.targetlayer === feature.layerId) {
                                        var featureType = _this.$layerService.getFeatureType(feature);
                                        var propertyTypes = csComp.Helpers.getPropertyTypes(feature.fType, _this.$layerService.propertyTypeData);
                                        var found = false;
                                        propertyTypes.forEach(function (p) {
                                            if (p.label === pt.label) {
                                                found = true;
                                            }
                                        });
                                        if (!found)
                                            featureType._propertyTypeData.push(pt);
                                    }
                                }
                            });
                        }
                    }
                });
            });
            //csComp.Helpers.getPropertyTypes
        };
        FeaturePropsCtrl.prototype.showSensorData = function (property) {
            //console.log(property);
        };
        FeaturePropsCtrl.prototype.setShowSimpleTimeline = function () {
            if (this.$mapService.timelineVisible
                || typeof this.$layerService.lastSelectedFeature === 'undefined'
                || this.$layerService.lastSelectedFeature == null) {
                this.showSimpleTimeline = false;
                return;
            }
            var feature = this.$layerService.lastSelectedFeature;
            this.showSimpleTimeline = (typeof feature.sensors !== 'undefined' && feature.sensors !== null);
            if (this.showSimpleTimeline)
                this.setTimestamps();
        };
        FeaturePropsCtrl.prototype.setTimestamps = function () {
            var feature = this.$layerService.lastSelectedFeature;
            var layer = this.$layerService.findLayer(feature.layerId);
            if ((typeof layer.timestamps === 'undefined' || layer.timestamps == null) &&
                (typeof feature.timestamps === 'undefined' || feature.timestamps == null))
                return [];
            var time = this.timestamps = new Array();
            (layer.timestamps || feature.timestamps).forEach(function (ts) {
                var date = new Date(ts);
                var dateString = String.format('{0}-{1:00}-{2:00}', date.getFullYear(), date.getUTCMonth() + 1, date.getUTCDate());
                if (date.getUTCHours() > 0 || date.getUTCMinutes() > 0)
                    dateString += String.format(' {0:00}:{1:00}', date.getUTCHours(), date.getUTCMinutes());
                time.push({ title: dateString, timestamp: ts });
            });
            // Set focus time
            var focus = this.$layerService.project.timeLine.focus;
            if (focus > time[time.length - 1].timestamp) {
                this.focusTime = time[time.length - 1].title;
                this.setTime(time[time.length - 1]);
            }
            else if (focus < time[0].timestamp) {
                this.focusTime = time[0].title;
                this.setTime(time[0]);
            }
            else {
                for (var i = 1; i < time.length; i++) {
                    if (focus > time[i].timestamp)
                        continue;
                    this.focusTime = time[i].title;
                    this.setTime(time[i]);
                    break;
                }
            }
            return time;
        };
        FeaturePropsCtrl.prototype.zoomToDate = function (date) {
            var d = new Date(date.toString());
            this.$layerService.project.timeLine.isLive = false;
            this.$layerService.project.timeLine.setFocus(d);
            this.$messageBusService.publish('timeline', 'setFocus', d);
        };
        FeaturePropsCtrl.prototype.selectFeature = function (feature) {
            if (!feature)
                return;
            this.$layerService.selectFeature(feature);
        };
        FeaturePropsCtrl.prototype.setTime = function (time) {
            this.focusTime = time.title;
            this.$layerService.project.timeLine.setFocus(new Date(time.timestamp));
            this.$messageBusService.publish('timeline', 'focusChange', time.timestamp);
        };
        FeaturePropsCtrl.prototype.getFormattedDate = function (fp, pt) {
            if (!fp)
                return;
            var format;
            if (pt && pt.hasOwnProperty('stringFormat')) {
                format = pt.stringFormat;
            }
            else {
                return moment(fp).calendar();
            }
            if (moment(fp).format(format) === 'Invalid date') {
                return moment(fp, 'YYYYMMDD').format(format);
            }
            else {
                return moment(fp).format(format);
            }
        };
        //When a feature has multiple sections, a dropdown list is created with the title defined in the language entry 'CHOOSE_DROPDOWN' (e.g. 'Choose...' or 'Data...')
        FeaturePropsCtrl.prototype.setDropdownTitle = function () {
            var _this = this;
            this.$translate('CHOOSE_DROPDOWN').then(function (translation) {
                if (typeof translation === 'string' && translation.length > 0) {
                    _this.defaultDropdownTitle = translation;
                }
                else {
                    _this.defaultDropdownTitle = '...';
                }
            });
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        FeaturePropsCtrl.$inject = [
            '$scope',
            '$location',
            '$sce',
            'mapService',
            'layerService',
            'messageBusService',
            '$translate',
            '$compile'
        ];
        return FeaturePropsCtrl;
    }());
    FeatureProps.FeaturePropsCtrl = FeaturePropsCtrl;
})(FeatureProps || (FeatureProps = {}));
//# sourceMappingURL=FeaturePropsCtrl.js.map
var FeatureRelations;
(function (FeatureRelations) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        FeatureRelations.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FeatureRelations.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's relations in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    FeatureRelations.myModule.directive('featurerelations', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/FeatureRelations/FeatureRelations.tpl.html',
                replace: true,
                transclude: true,
                controller: FeatureRelations.FeatureRelationsCtrl
            };
        }
    ]);
})(FeatureRelations || (FeatureRelations = {}));
//# sourceMappingURL=FeatureRelations.js.map
var FeatureRelations;
(function (FeatureRelations) {
    var FeaturePropsOptions = (function () {
        function FeaturePropsOptions(position) {
            this.position = position;
            this.closeButton = true;
            this.autoPan = true;
        }
        return FeaturePropsOptions;
    }());
    var RelationGroup = (function () {
        function RelationGroup() {
            this.relations = [];
        }
        return RelationGroup;
    }());
    FeatureRelations.RelationGroup = RelationGroup;
    var Relation = (function () {
        function Relation() {
        }
        return Relation;
    }());
    FeatureRelations.Relation = Relation;
    var FeatureRelationsCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function FeatureRelationsCtrl($scope, $location, $sce, $mapService, $layerService, $messageBusService, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$location = $location;
            this.$sce = $sce;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$translate = $translate;
            this.relations = [];
            /**
             * Callback function
             * @see {http://stackoverflow.com/questions/12756423/is-there-an-alias-for-this-in-typescript}
             * @see {http://stackoverflow.com/questions/20627138/typescript-this-scoping-issue-when-called-in-jquery-callback}
             * @todo {notice the strange syntax using a fat arrow =>, which is to preserve the this reference in a callback!}
             */
            this.sidebarMessageReceived = function (title) {
                switch (title) {
                    case 'toggle':
                        _this.$scope.showMenu = !_this.$scope.showMenu;
                        break;
                    case 'show':
                        _this.$scope.showMenu = true;
                        break;
                    case 'hide':
                        _this.$scope.showMenu = false;
                        break;
                    default:
                        break;
                }
                // NOTE EV: You need to call apply only when an event is received outside the angular scope.
                // However, make sure you are not calling this inside an angular apply cycle, as it will generate an error.
                if (_this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest') {
                    _this.$scope.$apply();
                }
            };
            this.featureMessageReceived = function (title, feature) {
                //console.log("FPC: featureMessageReceived");
                switch (title) {
                    case 'onFeatureSelect':
                        _this.initRelations();
                        _this.$messageBusService.publish('feature', 'onRelationsUpdated', feature);
                        break;
                    default:
                        break;
                }
                if (_this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest') {
                    _this.$scope.$apply();
                }
            };
            this.scope = $scope;
            $scope.vm = this;
            $scope.showMenu = false;
            //$messageBusService.subscribe("sidebar", this.sidebarMessageReceived);
            //$messageBusService.subscribe("feature", this.featureMessageReceived);
            this.initRelations();
        }
        FeatureRelationsCtrl.prototype.selectRelation = function (relation) {
            this.$layerService.selectFeature(relation.target);
            this.$mapService.zoomTo(relation.target);
        };
        // Create a relation to the nearest 10 features that are within the extent
        FeatureRelationsCtrl.prototype.createNearbyRelation = function (f) {
            var rgr = new RelationGroup();
            var mapZoom = this.$layerService.activeMapRenderer.getZoom();
            if (mapZoom < 11)
                return rgr; //Disable when zoom level is too low
            this.$translate('NEARBY_FEATURES').then(function (translation) {
                rgr.title = translation;
            });
            rgr.id = csComp.Helpers.getGuid();
            rgr.relations = [];
            var mapBounds = this.$mapService.map.getBounds();
            var tooManyFeatures = false;
            this.$layerService.project.features.every(function (feature) {
                if (feature.id !== f.id) {
                    if ((feature.geometry.type === 'Point' && mapBounds.contains(new L.LatLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0])))
                        || (feature.geometry.type === 'Polygon'
                            && mapBounds.contains(new L.LatLng(feature.geometry.coordinates[0][0][1], feature.geometry.coordinates[0][0][0])))) {
                        //TODO: Get center point of polygon, instead of its first point.
                        var rl = new Relation();
                        rl.subject = f;
                        rl.target = feature;
                        rl.title = csComp.Helpers.featureTitle(feature.fType, feature);
                        rl.icon = (!feature.fType || !feature.fType.style || !feature.fType.style.hasOwnProperty('iconUri')
                            || feature.fType.style.iconUri.toLowerCase().indexOf('_media') >= 0)
                            ? ''
                            : csComp.Helpers.convertStringFormat(feature, feature.fType.style.iconUri);
                        rgr.relations.push(rl);
                    }
                }
                if (rgr.relations.length > 40) {
                    tooManyFeatures = true;
                    return false; // break out of the some-loop when too many features are nearby
                }
                else {
                    return true;
                }
            });
            if (tooManyFeatures) {
                rgr.relations.length = 0;
                return rgr;
            }
            var fLoc;
            if (f.geometry.type === 'Point') {
                fLoc = new L.LatLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
            }
            else if (f.geometry.type === 'Polygon') {
                fLoc = new L.LatLng(f.geometry.coordinates[0][0][1], f.geometry.coordinates[0][0][0]); //TODO: Get center point of polygon, instead of its first point.
            }
            if (fLoc) {
                rgr.relations.sort(function (rl1, rl2) {
                    var loc1;
                    var loc2;
                    if (rl1.target.geometry.type === 'Point')
                        loc1 = new L.LatLng(rl1.target.geometry.coordinates[1], rl1.target.geometry.coordinates[0]);
                    if (rl1.target.geometry.type === 'Polygon')
                        loc1 = new L.LatLng(rl1.target.geometry.coordinates[0][0][1], rl1.target.geometry.coordinates[0][0][0]);
                    if (rl2.target.geometry.type === 'Point')
                        loc2 = new L.LatLng(rl2.target.geometry.coordinates[1], rl2.target.geometry.coordinates[0]);
                    if (rl2.target.geometry.type === 'Polygon')
                        loc2 = new L.LatLng(rl2.target.geometry.coordinates[0][0][1], rl2.target.geometry.coordinates[0][0][0]);
                    if (loc1 && loc2) {
                        return (fLoc.distanceTo(loc1) - fLoc.distanceTo(loc2));
                    }
                    else {
                        return;
                    }
                });
            }
            if (rgr.relations.length > 10) {
                rgr.relations.splice(10);
            }
            return rgr;
        };
        FeatureRelationsCtrl.prototype.initRelations = function () {
            this.relations = [];
            var f = this.$layerService.lastSelectedFeature;
            if (!f.fType)
                return;
            this.$scope.title = csComp.Helpers.featureTitle(f.fType, f);
            if (!f.fType || !f.fType.style || !f.fType.style.hasOwnProperty('iconUri') ||
                f.fType.style.iconUri.toLowerCase().indexOf('_media') >= 0) {
                this.$scope.icon = '';
            }
            else {
                this.$scope.icon = csComp.Helpers.convertStringFormat(f, f.fType.style.iconUri);
            }
            var propertyTypes = csComp.Helpers.getPropertyTypes(f.fType, this.$layerService.propertyTypeData);
            for (var p in propertyTypes) {
                var pt = propertyTypes[p];
                if (pt.type === 'relation') {
                    var rg = new RelationGroup();
                    rg.title = pt.title;
                    rg.id = csComp.Helpers.getGuid();
                    rg.relations = [];
                    if (pt.target) {
                        this.$layerService.project.features.forEach(function (feature) {
                            if (f.properties.hasOwnProperty(pt.subject) && feature.properties.hasOwnProperty(pt.target)
                                && feature.properties[pt.target] === f.properties[pt.subject] && f.id !== feature.id) {
                                var rel = new Relation();
                                rel.subject = f;
                                rel.target = feature;
                                rel.title = csComp.Helpers.featureTitle(feature.fType, feature);
                                rel.icon = (!feature.fType || !feature.fType.style || !feature.fType.style.hasOwnProperty('iconUri')
                                    || feature.fType.style.iconUri.toLowerCase().indexOf('_media') >= 0)
                                    ? ''
                                    : feature.fType.style.iconUri;
                                rg.relations.push(rel);
                            }
                        });
                        if (rg.relations.length > 0) {
                            pt.count = 0;
                            rg.relations.forEach(function (rl) {
                                if (rl.target.fType.name === f.fType.name)
                                    pt.count += 1;
                            });
                        }
                    }
                    if (rg.relations.length > 0)
                        this.relations.push(rg);
                }
            }
            var nearbyRelGroup = this.createNearbyRelation(f);
            if (nearbyRelGroup.relations.length > 0)
                this.relations.push(nearbyRelGroup);
            this.showRelations = this.relations.length > 0;
            if (this.showRelations) {
                $('#linkedData').show();
            }
            else {
                $('#linkedData').hide();
            }
        };
        FeatureRelationsCtrl.prototype.getRelations = function () {
            return this.relations;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        FeatureRelationsCtrl.$inject = [
            '$scope',
            '$location',
            '$sce',
            'mapService',
            'layerService',
            'messageBusService',
            '$translate'
        ];
        return FeatureRelationsCtrl;
    }());
    FeatureRelations.FeatureRelationsCtrl = FeatureRelationsCtrl;
})(FeatureRelations || (FeatureRelations = {}));
//# sourceMappingURL=FeatureRelationsCtrl.js.map
var FilterList;
(function (FilterList) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        FilterList.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FilterList.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    FilterList.myModule.directive('filterList', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/FilterList/FilterList.tpl.html',
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: false,
                transclude: false,
                controller: FilterList.FilterListCtrl
            };
        }
    ]).directive('bsPopover', function () {
        return function (scope, element, attrs) {
            element.find("a[rel=popover]").popover({ placement: 'right', html: 'true' });
        };
    });
})(FilterList || (FilterList = {}));
//# sourceMappingURL=FilterList.js.map
var FilterList;
(function (FilterList) {
    var FilterListCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function FilterListCtrl($scope, $layerService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            $scope.vm = this;
            this.noFilters = true;
            this.locationFilterActive = false;
            this.$messageBus.subscribe("filters", function (action) {
                console.log('update filters');
                _this.noFilters = true;
                _this.locationFilterActive = false;
                _this.$layerService.project.groups.forEach(function (g) {
                    if (g.filters.length > 0 && _this.noFilters)
                        _this.noFilters = false;
                    g.filters.forEach(function (f) {
                        if (f.filterType === 'location' && _this.locationFilterActive === false)
                            _this.locationFilterActive = true;
                    });
                });
            });
        }
        FilterListCtrl.prototype.setLocationFilter = function (group) {
            if (!this.locationFilterActive) {
                this.$layerService.setLocationFilter(group);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        FilterListCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return FilterListCtrl;
    }());
    FilterList.FilterListCtrl = FilterListCtrl;
})(FilterList || (FilterList = {}));
//# sourceMappingURL=FilterListCtrl.js.map
var Heatmap;
(function (Heatmap) {
    'use strict';
    /**
     * Config
     */
    var moduleName = 'csComp';
    try {
        Heatmap.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Heatmap.myModule = angular.module(moduleName, []);
    }
    /**
     * Directive to display a heatmap control.
     */
    Heatmap.myModule
        .directive('heatmap', [
        '$window', '$compile',
        function ($window, $compile, $templateCache) {
            return {
                terminal: true,
                restrict: 'EA',
                scope: {},
                templateUrl: 'directives/Heatmap/Heatmap.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Heatmap.HeatmapCtrl
            };
        }
    ]);
})(Heatmap || (Heatmap = {}));
//# sourceMappingURL=HeatMap.js.map
var Heatmap;
(function (Heatmap) {
    'use strict';
    var HeatmapCtrl = (function () {
        function HeatmapCtrl($scope, $modal, $translate, $timeout, $localStorageService, $layerService, $mapService, messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$modal = $modal;
            this.$translate = $translate;
            this.$timeout = $timeout;
            this.$localStorageService = $localStorageService;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.messageBusService = messageBusService;
            this.heatmap = L.geoJson([]);
            this.heatmapModels = [];
            this.expertMode = true;
            this.moveListenerInitialized = false;
            this.projLayer = new csComp.Services.ProjectLayer();
            $scope.vm = this;
            messageBusService.subscribe('layer', function (title, layer) {
                switch (title) {
                    case 'deactivate':
                        /* For an explanation to the removing of layers, see the bottom of this file */
                        if (layer.type && layer.type === "heatmap" && layer.id === _this.projLayer.id && layer != _this.projLayer) {
                            _this.$layerService.removeLayer(_this.projLayer);
                            delete (_this.heatmapModel);
                            _this.initializeHeatmap();
                        }
                        break;
                    case 'activated':
                        if (layer.type && layer.type === "heatmap")
                            _this.updateAvailableHeatmaps();
                        if (layer.type && layer.type === "geojson") {
                            // When the final, required feature layer is loaded, update the heatmap
                            if (_this.heatmapModel && _this.heatmapModel.heatmapSettings.referenceList.length > 0) {
                                if (layer.reference && layer.reference == _this.heatmapModel.heatmapSettings.referenceList[_this.heatmapModel.heatmapSettings.referenceList.length - 1]) {
                                    _this.updateHeatmap();
                                }
                            }
                        }
                        break;
                }
            });
            messageBusService.subscribe('project', function (title) {
                switch (title) {
                    case 'loaded':
                        _this.expertMode = $layerService.project != null
                            && $layerService.project.hasOwnProperty('userPrivileges')
                            && $layerService.project.userPrivileges.hasOwnProperty('heatmap')
                            && $layerService.project.userPrivileges.heatmap.hasOwnProperty('expertMode')
                            && $layerService.project.userPrivileges.heatmap.expertMode;
                        _this.updateAvailableHeatmaps();
                        _this.initializeHeatmap();
                        break;
                }
            });
            $translate('HEATMAP.DELETE_MSG').then(function (translation) {
                HeatmapCtrl.confirmationMsg1 = translation;
            });
            $translate('HEATMAP.DELETE_MSG2').then(function (translation) {
                HeatmapCtrl.confirmationMsg2 = translation;
            });
        }
        HeatmapCtrl.prototype.updateAvailableHeatmaps = function () {
            var _this = this;
            if (!this.heatmapModel) {
                this.heatmapModels = [];
                if (this.$layerService.project.groups) {
                    this.$layerService.project.groups.forEach(function (group) {
                        group.layers.forEach(function (layer) {
                            if (layer.type === "heatmap") {
                                var hm = new Heatmap.HeatmapModel(layer.title);
                                hm.deserialize(layer);
                                _this.heatmapModels.push(hm);
                                if (layer.enabled)
                                    _this.heatmapModel = hm;
                            }
                        });
                    });
                }
            }
            else {
                for (var index = 0; index < this.heatmapModels.length; index++) {
                    if (this.heatmapModel.id == this.heatmapModels[index].id) {
                        this.heatmapModels.splice(index, 1);
                        break;
                    }
                }
                this.heatmapModels.push(this.heatmapModel);
            }
        };
        HeatmapCtrl.prototype.createHeatmap = function () {
            this.heatmapModel = new Heatmap.HeatmapModel('Heatmap');
            if (this.projLayer.data)
                this.$layerService.removeLayer(this.projLayer);
            //Create projectlayer for the heatmap
            this.projLayer.type = "heatmap";
            this.projLayer.renderType = "heatmap";
            this.projLayer.enabled = true;
            this.projLayer.group = new csComp.Services.ProjectGroup();
            this.projLayer.group.oneLayerActive = true;
            this.projLayer.group.layers = [];
            this.projLayer.group.filters = [];
            this.projLayer.group.styles = [];
            this.projLayer.group.markers = [];
            this.projLayer.heatmapSettings = new Heatmap.HeatmapSettings();
            this.projLayer.heatmapItems = [];
            this.projLayer.id = csComp.Helpers.getGuid();
            this.projLayer.quickRefresh = false;
            this.heatmap = L.geoJson([]);
            this.showHeatmapEditor(this.heatmapModel);
            //this.$layerService.addLayer(this.projLayer);
        };
        HeatmapCtrl.prototype.editHeatmap = function (heatmap) {
            this.showHeatmapEditor(heatmap);
        };
        HeatmapCtrl.prototype.exportHeatmap = function (heatmap) {
            var _this = this;
            /* Add active feature layer reference to the referencelist (TODO: find reference layer through enabled features) */
            this.heatmapModel.heatmapSettings.referenceList = [];
            this.heatmapModel.heatmapItems.forEach(function (hi) {
                if (hi.isSelected) {
                    _this.$layerService.project.groups.forEach(function (group) {
                        if (group.title == "Features") {
                            group.layers.forEach(function (l) {
                                if (l.enabled) {
                                    _this.heatmapModel.heatmapSettings.addReference(l.reference);
                                }
                            });
                        }
                    });
                }
            });
            /* Print the heatmap settings to the console in json format */
            console.log("\n-----------------\n" + "Exported heatmap starts here: \n");
            console.log(heatmap.serialize());
            console.log("\n-----------------\n" + "Exported heatmap ends here. \n");
            this.messageBusService.notify('Heatmap exported successfully', 'Your heatmap was exported to the console successfully.', csComp.Services.NotifyLocation.TopLeft);
        };
        HeatmapCtrl.prototype.removeHeatmap = function (heatmap) {
            var _this = this;
            if (!heatmap)
                return;
            var title = String.format(HeatmapCtrl.confirmationMsg1, heatmap.title);
            this.messageBusService.confirm(title, HeatmapCtrl.confirmationMsg2, function (result) {
                if (!result)
                    return;
                _this.$timeout(function () {
                    _this.deleteHeatmap(heatmap);
                    _this.updateAvailableHeatmaps();
                    //if (this.heatmap) this.updateHeatmap();
                    //if (this.heatmap) this.$mapService.map.removeLayer(this.heatmap);
                }, 0);
            });
            this.scopeApply();
        };
        HeatmapCtrl.prototype.deleteHeatmap = function (heatmap) {
            var _this = this;
            if (!heatmap)
                return;
            var index = this.heatmapModels.indexOf(heatmap);
            if (index >= 0)
                this.heatmapModels.splice(index, 1);
            this.$layerService.removeLayer(this.projLayer);
            // If the current heatmaplayer was a projectlayer, disable that one too
            if (this.$layerService.project.groups) {
                this.$layerService.project.groups.forEach(function (group) {
                    group.layers.forEach(function (layer) {
                        if (layer.type === "heatmap" && layer.id === _this.projLayer.id) {
                            _this.$layerService.removeLayer(layer);
                        }
                    });
                });
            }
            delete (this.heatmapModel);
            delete (this.projLayer);
            this.projLayer = new csComp.Services.ProjectLayer();
            this.initializeHeatmap();
        };
        /**
         * Show the heat map editor in a modal.
         */
        HeatmapCtrl.prototype.showHeatmapEditor = function (heatmap) {
            var _this = this;
            var modalInstance = this.$modal.open({
                templateUrl: 'directives/Heatmap/HeatmapEditorView.tpl.html',
                controller: Heatmap.HeatmapEditorCtrl,
                resolve: {
                    heatmap: function () { return heatmap; }
                }
            });
            modalInstance.result.then(function (heatmap) {
                _this.heatmapModel = heatmap;
                var i = _this.heatmapModels.indexOf(heatmap);
                if (i >= 0)
                    _this.heatmapModels.splice(i, 1);
                _this.heatmapModels.push(heatmap);
                _this.updateHeatmap();
                console.log('Updated heatmap');
            }, function () {
                console.log('Modal dismissed at: ' + new Date());
                delete (_this.heatmapModel);
            });
        };
        HeatmapCtrl.prototype.scopeApply = function () {
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        HeatmapCtrl.prototype.getVotingClass = function (hi) {
            if (hi == null || this.heatmapModel == null || hi.userWeight === 0 || hi.userWeight < -5 || hi.userWeight > 5)
                return 'disabledHeatmap';
            return hi.userWeight > 0 ? 'prefer' : 'avoid';
        };
        HeatmapCtrl.prototype.weightUpdated = function () {
            if (!this.heatmapModel)
                return;
            this.heatmapModel.updateWeights();
            this.projLayer.quickRefresh = true;
            this.$layerService.addLayer(this.projLayer);
        };
        HeatmapCtrl.prototype.intensityScaleUpdated = function () {
            if (!this.heatmapModel)
                return;
            //this.heatmapModel.updateWeights();
            //this.updateHeatmap();
            this.updateHeatmapWithoutRerendering();
        };
        HeatmapCtrl.prototype.resolutionUpdated = function () {
            if (!this.heatmapModel)
                return;
            this.updateHeatmap();
        };
        HeatmapCtrl.prototype.updateHeatmapWithoutRerendering = function () {
            this.projLayer.quickRefresh = true;
            this.$layerService.addLayer(this.projLayer);
        };
        /**
         * Update the available pre-set heatmaps.
         */
        HeatmapCtrl.prototype.updateHeatmap = function () {
            var _this = this;
            if (this.heatmapModel) {
                // If the current heatmapmodel comes from a projectlayer, disable that layer
                if (this.$layerService.project.groups) {
                    this.$layerService.project.groups.forEach(function (group) {
                        group.layers.forEach(function (layer) {
                            if (layer.type === "heatmap" && layer.id === _this.heatmapModel.id && layer.mapLayer) {
                                _this.$layerService.map.map.removeLayer(layer.mapLayer);
                                layer.enabled = true;
                            }
                        });
                    });
                }
                this.projLayer.quickRefresh = false;
                this.projLayer.heatmapItems = this.heatmapModel.heatmapItems;
                this.projLayer.heatmapSettings = this.heatmapModel.heatmapSettings;
                this.projLayer.id = this.heatmapModel.id;
                var currentZoom = this.$mapService.getMap().getZoom();
                if (currentZoom < this.heatmapModel.heatmapSettings.minZoom || currentZoom > this.heatmapModel.heatmapSettings.maxZoom) {
                    console.log("Heatmap is not supported for the current zoom level.");
                    this.$layerService.loadRequiredLayers(this.projLayer); // Make sure to load the required layers even if heatmap is not yet being drawn
                    return;
                }
                else {
                }
                this.$layerService.removeLayer(this.projLayer);
                this.$layerService.addLayer(this.projLayer);
            }
        };
        ///**
        //* Add a heatmap layer to the map.
        //*/
        HeatmapCtrl.prototype.initializeHeatmap = function () {
            var _this = this;
            this.projLayer.type = "heatmap";
            this.projLayer.renderType = "heatmap";
            this.projLayer.enabled = false;
            this.projLayer.group = new csComp.Services.ProjectGroup();
            this.projLayer.group.oneLayerActive = true;
            this.projLayer.group.layers = [];
            this.projLayer.group.filters = [];
            this.projLayer.group.styles = [];
            this.projLayer.group.markers = [];
            this.projLayer.mapLayer = new L.LayerGroup();
            this.projLayer.heatmapSettings = new Heatmap.HeatmapSettings();
            this.projLayer.heatmapItems = [];
            this.projLayer.data = JSON;
            this.projLayer.id = "";
            this.projLayer.quickRefresh = false;
            if (!this.moveListenerInitialized) {
                this.$layerService.map.map.addEventListener('moveend', function (event) {
                    _this.updateHeatmap();
                });
                this.moveListenerInitialized = true;
            }
        };
        HeatmapCtrl.$inject = [
            '$scope',
            '$uibModal',
            '$translate',
            '$timeout',
            'localStorageService',
            'layerService',
            'mapService',
            'messageBusService'
        ];
        return HeatmapCtrl;
    }());
    Heatmap.HeatmapCtrl = HeatmapCtrl;
})(Heatmap || (Heatmap = {}));
/* Heatmap layers:
 * ---------------
 * Two layers are used for the heatmaps, which are both very similar but different in an important way. The difference
 * lies in the fact that one layer comes directly from the project.json file. This layer is parsed and added to the layerservice
 * directly when it is enabled in the 'Layers' panel. The second layer is 'this.projLayer', which looks almost identical to
 * the parsed projectLayer, but it is generated programmatically. When a new heatmap is created, or a predefined heatmap is edited,
 * this.projLayer will be added to the layerservice. Very importantly, the MoveListener is connected to this.projLayer. That means
 * that every time the map is moved, 'this.projLayer' will contain the current heatmap, even when it was added from project.json.
 * Therefore, when one layer is being disabled, it needs to be checked whether the other layer is present in the layerservice,
 * and if so, it should be removed too.
 */
//# sourceMappingURL=HeatMapCtrl.js.map
var Heatmap;
(function (Heatmap) {
    'use strict';
    var HeatmapEditorCtrl = (function () {
        function HeatmapEditorCtrl($scope, $modalInstance, $layerService, $translate, messageBusService, heatmap) {
            var _this = this;
            this.$scope = $scope;
            this.$modalInstance = $modalInstance;
            this.$layerService = $layerService;
            this.$translate = $translate;
            this.messageBusService = messageBusService;
            this.heatmap = heatmap;
            this.scoringFunctions = [];
            $scope.vm = this;
            this.scoringFunctions.push(new Heatmap.ScoringFunction(Heatmap.ScoringFunctionType.LinearAscendingDescending));
            $translate('HEATMAP.LINEAR_ASC_DESC').then(function (translation) {
                _this.scoringFunctions[0].title = translation;
            });
            this.dataset = csComp.Helpers.loadMapLayers($layerService);
            if (!heatmap)
                heatmap = new Heatmap.HeatmapModel('Heatmap');
            for (var k in this.dataset.featureTypes) {
                if (this.dataset.featureTypes.hasOwnProperty(k)) {
                    var ft = this.dataset.featureTypes[k];
                    heatmap.addHeatmapItem(new Heatmap.HeatmapItem(ft.name, ft));
                    var propertyTypeData;
                    if (!ft._propertyTypeData)
                        continue;
                    ft._propertyTypeData.forEach(function (pt) {
                        if (pt.type == 'options') {
                            var i = 0;
                            for (var oo in pt.options) {
                                var o = pt.options[oo];
                                var hi = new Heatmap.HeatmapItem(o, ft);
                                hi.propertyLabel = pt.label;
                                hi.propertyTitle = pt.title;
                                hi.optionIndex = i++;
                                heatmap.addHeatmapItem(hi);
                            }
                        }
                    });
                }
            }
        }
        HeatmapEditorCtrl.prototype.save = function () {
            this.$modalInstance.close(this.heatmap);
        };
        HeatmapEditorCtrl.prototype.cancel = function () {
            this.$modalInstance.dismiss('cancel');
        };
        HeatmapEditorCtrl.prototype.toggleItemDetails = function (index) {
            this.showItem = this.showItem == index ? -1 : index;
            console.log("Toggle item");
        };
        HeatmapEditorCtrl.$inject = [
            '$scope',
            '$modalInstance',
            'layerService',
            '$translate',
            'messageBusService',
            'heatmap'
        ];
        return HeatmapEditorCtrl;
    }());
    Heatmap.HeatmapEditorCtrl = HeatmapEditorCtrl;
})(Heatmap || (Heatmap = {}));
//# sourceMappingURL=HeatmapEditorCtrl.js.map
var Heatmap;
(function (Heatmap) {
    var HeatmapItem = (function () {
        function HeatmapItem(title, featureType, weight, userWeight, isSelected, idealityMeasure, propertyTitle, propertyLabel, optionIndex) {
            if (weight === void 0) { weight = 0; }
            if (userWeight === void 0) { userWeight = 1; }
            if (isSelected === void 0) { isSelected = false; }
            if (idealityMeasure === void 0) { idealityMeasure = new Heatmap.IdealityMeasure(); }
            this.title = title;
            this.featureType = featureType;
            this.weight = weight;
            this.userWeight = userWeight;
            this.isSelected = isSelected;
            this.idealityMeasure = idealityMeasure;
            this.propertyTitle = propertyTitle;
            this.propertyLabel = propertyLabel;
            this.optionIndex = optionIndex;
            this.heatspots = [];
            // TODO Needs improvement based on actual location
            this.setScale(52);
        }
        /**
         * Returns an object which contains all the data that must be serialized.
         */
        HeatmapItem.serializeableData = function (i) {
            return {
                title: i.title,
                featureType: i.featureType,
                propertyTitle: i.propertyTitle,
                propertyLabel: i.propertyLabel,
                optionIndex: i.optionIndex,
                userWeight: i.userWeight,
                weight: i.weight,
                idealityMeasure: i.idealityMeasure,
                isSelected: i.isSelected
            };
        };
        HeatmapItem.prototype.calculateHeatspots = function (feature, cellWidth, cellHeight, horizCells, vertCells, mapBounds, paddingRatio) {
            // right type?
            if (!this.isSelected || this.featureType.name.replace('_Default', '') !== feature.fType.name)
                return null;
            if (this.heatspots.length === 0)
                this.calculateHeatspot(cellWidth, cellHeight);
            // create heatspot solely based on feature type?
            if (!this.propertyLabel) {
                return this.pinHeatspotToGrid(feature, horizCells, vertCells, mapBounds, paddingRatio);
            }
            // create heatspot based on the preferred option?
            if (feature.properties.hasOwnProperty(this.propertyLabel)
                && feature.properties[this.propertyLabel] === this.optionIndex) {
                return this.pinHeatspotToGrid(feature, horizCells, vertCells, mapBounds, paddingRatio);
            }
            return null;
        };
        /**
        * Calculate the intensity around the location.
        * NOTE We are performing a relative computation around location (0,0) in a rectangular grid.
        */
        HeatmapItem.prototype.calculateHeatspot = function (cellWidth, cellHeight) {
            var maxRadius = this.idealityMeasure.lostInterestDistance;
            var horizCells = Math.floor(maxRadius / cellWidth);
            var vertCells = Math.floor(maxRadius / cellHeight);
            var sCellSize = cellWidth * cellHeight;
            var arrayLength = horizCells * vertCells;
            this.heatspots = new Array(arrayLength);
            this.heatspots.push(new Heatmap.Heatspot(0, 0, this.idealityMeasure.atLocation));
            for (var i = -vertCells; i <= vertCells; i++) {
                for (var j = -horizCells; j <= horizCells; j++) {
                    var radius = Math.sqrt(i * i * sCellSize + j * j * sCellSize);
                    var intensity = this.idealityMeasure.computeIdealityAtDistance(radius);
                    if (!(i == 0 && j == 0) && intensity != 0) {
                        this.heatspots.push(new Heatmap.Heatspot(i, j, intensity));
                    }
                }
            }
            //var latRadius = radius * HeatmapItem.meterToLatDegree;
            //var lonRadius = radius * HeatmapItem.meterToLonDegree;
            //for (var lat = -latRadius; lat < latRadius; lat += deltaLatDegree) {
            //    for (var lon = -lonRadius; lat < lonRadius; lat += deltaLonDegree) {
            //        // TODO Compute radius
            //        var intensity = this.idealityMeasure.computeIdealityAtDistance(radius);
            //        this.heatspots.push(new Heatspot(lat, lon, this.weight * intensity.ideality));
            //    }
            //}
            //var count = 0;
            //while (count++ < 200) {
            //    var radius    = Math.random() * this.idealityMeasure.lostInterestDistance;
            //    var latRadius = radius * HeatmapItem.meterToLatDegree;
            //    var lonRadius = radius * HeatmapItem.meterToLonDegree;
            //    var angleRad  = Math.random() * HeatmapItem.twoPi;
            //    var lat       = Math.sin(angleRad) * latRadius;
            //    var lon       = Math.cos(angleRad) * lonRadius;
            //    var intensity = this.idealityMeasure.computeIdealityAtDistance(radius);
            //    this.heatspots.push(new Heatspot(lat, lon, this.weight * intensity.ideality, intensity.radius));
            //}
            //var twoPi: number = Math.PI * 2;
            //var lat = 0,
            //    lon = 0;
            //// add start point
            //this.heatspots.push(new Heatspot(lat, lon, this.weight * this.idealityMeasure.atLocation));
            //// halfway between start and ideal location
            //var stepSize  = Math.PI / 2;
            //var radius    = this.idealityMeasure.idealDistance / 2;
            //var latRadius = radius * HeatmapItem.meterToLatDegree;
            //var lonRadius = radius * HeatmapItem.meterToLonDegree;
            //var itensity  = 0.5 * this.weight;
            //for (var i = Math.PI / 4; i < twoPi; i += stepSize) {
            //    lat = Math.sin(i) * latRadius;
            //    lon = Math.cos(i) * lonRadius;
            //    this.heatspots.push(new Heatspot(lat, lon, itensity));
            //}
            //// At ideal distance
            //stepSize /= 2;
            //radius = this.idealityMeasure.idealDistance;
            //latRadius = radius * HeatmapItem.meterToLatDegree;
            //lonRadius = radius * HeatmapItem.meterToLonDegree;
            //itensity = this.weight;
            //for (var i = 0; i < twoPi; i += stepSize) {
            //    lat = Math.sin(i) * latRadius;
            //    lon = Math.cos(i) * lonRadius;
            //    this.heatspots.push(new Heatspot(lat, lon, itensity));
            //}
            //// At ring halfway between ideal distance and no interest
            //stepSize /= 2;
            //radius   += (this.idealityMeasure.lostInterestDistance - this.idealityMeasure.idealDistance) / 2;
            //latRadius = radius * HeatmapItem.meterToLatDegree;
            //lonRadius = radius * HeatmapItem.meterToLonDegree;
            //itensity = this.weight / 2;
            //for (var i = Math.PI / 8; i < twoPi; i += stepSize) {
            //    lat = Math.sin(i) * latRadius;
            //    lon = Math.cos(i) * lonRadius;
            //    this.heatspots.push(new Heatspot(lat, lon, itensity));
            //}
        };
        /**
        * Translate the heatspot (at (0,0)) to the actual location.
        */
        HeatmapItem.prototype.pinHeatspotToGrid = function (feature, horizCells, vertCells, mapBounds, paddingRatio) {
            if (feature.geometry.type !== 'Point')
                return null;
            var latlong = new L.LatLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]);
            //TODO add a padding that takes the current zoom into account
            var paddedBounds = mapBounds.pad(paddingRatio);
            if (!paddedBounds.contains(latlong))
                return null; //Only draw features that are visible in the map
            var actualHeatspots = [];
            //Find the indices of the feature in the grid
            var hCell = Math.floor(((latlong.lng - mapBounds.getNorthWest().lng) / (mapBounds.getNorthEast().lng - mapBounds.getNorthWest().lng)) * horizCells);
            var vCell = Math.floor(((latlong.lat - mapBounds.getSouthWest().lat) / (mapBounds.getNorthWest().lat - mapBounds.getSouthWest().lat)) * vertCells);
            this.heatspots.forEach(function (hs) {
                actualHeatspots.push(hs.AddLocation(hCell, vCell, feature.properties['Name'])); // + ': ' + hs.intensity.toFixed(3)));
            });
            return actualHeatspots;
        };
        /**
        * Set the scale to convert a 1x1 meter grid cell to the appropriate number of degrees
        * in vertical and horizontal direction.
        */
        HeatmapItem.prototype.setScale = function (latitude) {
            var latlonlen = csComp.Helpers.GeoExtensions.convertDegreesToMeters(latitude);
            HeatmapItem.meterToLatDegree = 1 / latlonlen.latitudeLength;
            HeatmapItem.meterToLonDegree = 1 / latlonlen.longitudeLength;
        };
        HeatmapItem.prototype.select = function () {
            this.reset();
            this.isSelected = !this.isSelected;
            if (!this.isSelected) {
                this.idealityMeasure = null;
            }
            else {
                switch (this.featureType.style.drawingMode.toLowerCase()) {
                    case 'point':
                    case 'image':
                        this.idealityMeasure = new Heatmap.IdealityMeasure();
                        break;
                    default:
                        //this.idealityMeasure = 1;
                        break;
                }
            }
        };
        HeatmapItem.prototype.reset = function () {
            this.heatspots = [];
        };
        HeatmapItem.prototype.toString = function () {
            return this.propertyTitle
                ? this.propertyTitle + '.' + this.title + ' (' + this.featureType.name + ')'
                : this.title;
        };
        HeatmapItem.twoPi = Math.PI * 2;
        return HeatmapItem;
    }());
    Heatmap.HeatmapItem = HeatmapItem;
})(Heatmap || (Heatmap = {}));
//# sourceMappingURL=HeatmapItem.js.map
var Heatmap;
(function (Heatmap) {
    var HeatmapModel = (function () {
        function HeatmapModel(title) {
            this.title = title;
            this.heatmapItems = [];
            this.id = "";
            this.horizCells = 0;
            this.vertCells = 0;
            this.cellWidth = 0;
            this.cellHeight = 0;
            this.dLat = 0;
            this.dLng = 0;
            this.title = title;
            this.heatmapSettings = new Heatmap.HeatmapSettings();
        }
        /**
         * Calculate the heatmap.
         */
        HeatmapModel.prototype.calculate = function (layerService, mapService, heatmap) {
            var _this = this;
            var time = new Date().getTime();
            console.log('Calculating heatmap');
            var mapBounds = mapService.map.getBounds();
            var NW = mapBounds.getNorthWest();
            var NE = mapBounds.getNorthEast();
            this.SW = mapBounds.getSouthWest();
            var width = NW.distanceTo(NE); //Width of the map as it is currently visible on the screen, including padding
            var height = NW.distanceTo(this.SW); //Height ...
            var heatspots = [];
            // Iterate over all applicable features on the map and find the one with the largest interest distance.
            var dataset = csComp.Helpers.loadMapLayers(layerService);
            var maxInterestDistance = 0;
            //heatmap.clearData();
            dataset.features.forEach(function (f) {
                _this.heatmapItems.forEach(function (hi) {
                    if (hi.idealityMeasure.lostInterestDistance > maxInterestDistance) {
                        maxInterestDistance = hi.idealityMeasure.lostInterestDistance;
                    }
                });
            });
            var widthPaddingRatio = (width + 2 * maxInterestDistance) / width;
            var heigthPaddingRatio = (height + 2 * maxInterestDistance) / height;
            var paddingRatio = Math.max(widthPaddingRatio, heigthPaddingRatio);
            //Calculate a grid based on the maximum number of cells and the map ratio.
            var mapRatio = width / height;
            var maxCellCount;
            switch (this.heatmapSettings.resolution) {
                case 1:
                    maxCellCount = 1000;
                    break;
                case 2:
                    maxCellCount = 4000;
                    break;
                case 3:
                    maxCellCount = 7000;
                    break;
                default:
                    maxCellCount = 4000;
                    break;
            }
            this.horizCells = Math.floor(Math.sqrt(maxCellCount * mapRatio));
            this.vertCells = Math.floor(this.horizCells / mapRatio);
            this.cellWidth = width / this.horizCells;
            this.cellHeight = height / this.vertCells;
            this.dLat = (NE.lat - this.SW.lat) / this.vertCells;
            this.dLng = (NE.lng - this.SW.lng) / this.horizCells;
            var count = 0;
            //var turfgrid = turf.squareGrid([SW.lng, SW.lat, NE.lng, NE.lat], cellWidth / 1000, 'kilometers');
            this.intensityGrid = [];
            this.contributorGrid = [];
            for (var i = 0; i < this.horizCells; i++) {
                this.intensityGrid[i] = [];
                this.contributorGrid[i] = [];
                for (var j = 0; j < this.vertCells; j++) {
                    this.intensityGrid[i][j] = {};
                    this.contributorGrid[i][j] = {};
                }
            }
            // Iterate over all applicable features on the map and create a intensity "stamp" for each feature
            dataset.features.forEach(function (f) {
                _this.heatmapItems.forEach(function (hi) {
                    var heatspot = hi.calculateHeatspots(f, _this.cellWidth, _this.cellHeight, _this.horizCells, _this.vertCells, mapBounds, paddingRatio);
                    if (heatspot) {
                        //heatspots = heatspots.concat(heatspot);
                        //console.log('Created ' + heatspot.length + ' heatspots');
                        heatspot.forEach(function (hs) {
                            //heatmap.addDataPoint(hs.i, hs.j, hs.intensity);
                            if (hs.intensity != 0 &&
                                hs.i >= 0 && hs.i < _this.horizCells && hs.j >= 0 && hs.j < _this.vertCells) {
                                (_this.intensityGrid[hs.i][hs.j].hasOwnProperty(hi.toString())) ? _this.intensityGrid[hs.i][hs.j][hi.toString()] += hs.intensity : _this.intensityGrid[hs.i][hs.j][hi.toString()] = hs.intensity;
                                _this.contributorGrid[hs.i][hs.j][hs.contributor] = hs.intensity;
                                count = count + 1;
                            }
                        });
                    }
                });
            });
            var time2 = new Date().getTime();
            console.log('Created ' + count + ' heatspots in ' + (time2 - time).toFixed(1) + ' ms');
            this.drawIntensityGrid(heatmap);
            var time3 = new Date().getTime();
            console.log('Calculated ' + (i * j) + ' cells in ' + (time3 - time).toFixed(1) + ' ms');
        };
        HeatmapModel.prototype.drawIntensityGrid = function (heatmap) {
            var weightedIntensityScale = ((this.heatmapSettings.intensityScale / 3) * (this.heatmapSettings.intensityScale / 3)); // Convert intensityscale from [1,...,5] to ~[0.1, 0.5, 1, 2, 3]
            heatmap.clearLayers();
            var hiWeights = {};
            this.heatmapItems.forEach(function (hi) {
                hiWeights[hi.toString()] = hi.weight;
            });
            //Draw the intensityGrid
            for (var i = 0; i < this.horizCells; i++) {
                for (var j = 0; j < this.vertCells; j++) {
                    var totalIntensity = 0;
                    for (var hiTitle in this.intensityGrid[i][j]) {
                        if (this.intensityGrid[i][j].hasOwnProperty(hiTitle)) {
                            totalIntensity += (hiWeights[hiTitle] * this.intensityGrid[i][j][hiTitle]);
                        }
                    }
                    if (totalIntensity != 0) {
                        var polyCoord = [[this.SW.lng + this.dLng * i, this.SW.lat + this.dLat * j],
                            [this.SW.lng + this.dLng * (i + 1), this.SW.lat + this.dLat * j],
                            [this.SW.lng + this.dLng * (i + 1), this.SW.lat + this.dLat * (j + 1)],
                            [this.SW.lng + this.dLng * i, this.SW.lat + this.dLat * (j + 1)]];
                        var feature = {
                            "type": "Feature",
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": [polyCoord]
                            },
                            "properties": {
                                "Name": "Heatmap cell (" + i.toString() + ", " + j.toString() + ")",
                                "gridX": i,
                                "gridY": j,
                                "totalIntensity": (totalIntensity * weightedIntensityScale).toFixed(3),
                                "contributors": JSON.stringify(this.contributorGrid[i][j], function (key, intensity) {
                                    return intensity.toFixed ? Number(intensity.toFixed(3)) : intensity;
                                }),
                                "intensities": JSON.stringify(this.intensityGrid[i][j])
                            }
                        };
                        heatmap.addData(feature);
                    }
                }
            }
        };
        /**
         * Update the weights of all heatmap items.
         */
        HeatmapModel.prototype.updateWeights = function () {
            var totalUserWeight = 0;
            this.heatmapItems.forEach(function (hi) {
                if (hi.isSelected)
                    totalUserWeight += Math.abs(hi.userWeight);
            });
            this.heatmapItems.forEach(function (hi) {
                if (hi.isSelected) {
                    if (totalUserWeight != 0) {
                        hi.weight = hi.userWeight / totalUserWeight;
                    }
                    else {
                        hi.weight = 0;
                    }
                }
            });
        };
        /**
        * Add a heatmap item to the list of items only in case we don't have it yet.
        */
        HeatmapModel.prototype.addHeatmapItem = function (heatmapItem) {
            var ft = heatmapItem.featureType;
            var title = heatmapItem.title;
            for (var i = 0; i < this.heatmapItems.length; i++) {
                var hi = this.heatmapItems[i];
                if (hi.featureType.name === ft.name && hi.title === title)
                    return;
            }
            this.heatmapItems.push(heatmapItem);
        };
        HeatmapModel.prototype.deserialize = function (layer) {
            var _this = this;
            this.id = layer.id;
            var hs = layer.heatmapSettings;
            this.heatmapSettings = new Heatmap.HeatmapSettings(hs.referenceList, hs.minZoom, hs.maxZoom, hs.intensityScale, hs.resolution);
            this.heatmapItems = [];
            var heatmapitems = layer.heatmapItems;
            heatmapitems.forEach(function (hi_info) {
                var im = new Heatmap.IdealityMeasure(hi_info.idealityMeasure.idealDistance, hi_info.idealityMeasure.atLocation, hi_info.idealityMeasure.lostInterestDistance);
                if (hi_info.propertyTitle) {
                    var hi = new Heatmap.HeatmapItem(hi_info.title, hi_info.featureType, hi_info.weight, hi_info.userWeight, hi_info.isSelected, im, hi_info.propertyTitle, hi_info.propertyLabel, hi_info.optionIndex);
                }
                else {
                    var hi = new Heatmap.HeatmapItem(hi_info.title, hi_info.featureType, hi_info.weight, hi_info.userWeight, hi_info.isSelected, im);
                }
                _this.addHeatmapItem(hi);
            });
        };
        HeatmapModel.prototype.serialize = function () {
            var minimizedHeatmapItems = [];
            this.heatmapItems.forEach(function (hi) {
                if (hi.isSelected) {
                    hi.reset();
                    if (hi.propertyTitle) {
                        var hi_new = new Heatmap.HeatmapItem(hi.title, { name: hi.featureType.name }, hi.weight, hi.userWeight, hi.isSelected, hi.idealityMeasure, hi.propertyTitle, hi.propertyLabel, hi.optionIndex);
                    }
                    else {
                        var hi_new = new Heatmap.HeatmapItem(hi.title, { name: hi.featureType.name }, hi.weight, hi.userWeight, hi.isSelected, hi.idealityMeasure);
                    }
                    minimizedHeatmapItems.push(hi_new);
                }
            });
            var output = "{\"id\": \"ID\",\n" +
                "\"reference\": \"REFERENCE\",\n" +
                "\"languages\": {\n" +
                "\"nl\": {\"title\": ";
            output += JSON.stringify(this.title);
            output += ",\n\"description\": \"BESCHRIJVING\"\n},\n" +
                "\"en\": {\"title\": ";
            output += JSON.stringify(this.title);
            output += ",\n\"description\": \"DESCRIPTION\"\n}\n" +
                "},\n" +
                "\"description\": \"DESCRIPTION\",\n";
            output += "\"type\":\"Heatmap\"";
            output += ",\n\"heatmapSettings\":" + JSON.stringify(this.heatmapSettings, null, ' ');
            output += ",\n\"heatmapItems\":";
            output += JSON.stringify(minimizedHeatmapItems, null, ' ');
            output += ",\n\"enabled\":";
            output += JSON.stringify(false);
            output += ",\n\"opacity\":";
            output += JSON.stringify(100);
            output += "\n}";
            return output;
        };
        return HeatmapModel;
    }());
    Heatmap.HeatmapModel = HeatmapModel;
})(Heatmap || (Heatmap = {}));
//# sourceMappingURL=HeatMapModel.js.map
var Heatmap;
(function (Heatmap) {
    var HeatmapSettings = (function () {
        function HeatmapSettings(referenceList, minZoom, maxZoom, intensityScale, resolution) {
            if (referenceList === void 0) { referenceList = []; }
            if (minZoom === void 0) { minZoom = 10; }
            if (maxZoom === void 0) { maxZoom = 15; }
            if (intensityScale === void 0) { intensityScale = 3; }
            if (resolution === void 0) { resolution = 2; }
            this.referenceList = referenceList;
            this.minZoom = minZoom;
            this.maxZoom = maxZoom;
            this.intensityScale = intensityScale;
            this.resolution = resolution;
        }
        HeatmapSettings.prototype.addReference = function (reference) {
            // Add unique reference layers only
            if (this.referenceList.indexOf(reference) < 0) {
                this.referenceList.push(reference);
            }
        };
        return HeatmapSettings;
    }());
    Heatmap.HeatmapSettings = HeatmapSettings;
})(Heatmap || (Heatmap = {}));
//# sourceMappingURL=HeatmapSettings.js.map
var Heatmap;
(function (Heatmap) {
    /**
     * A heat spot represents a point on the map with a certain intensity.
     */
    var Heatspot = (function () {
        function Heatspot(i, j, intensity, contributor) {
            this.i = i;
            this.j = j;
            this.intensity = intensity;
            this.contributor = contributor;
        }
        Heatspot.prototype.AddLocation = function (i, j, contributor) {
            return new Heatspot(this.i + i, this.j + j, this.intensity, contributor);
        };
        return Heatspot;
    }());
    Heatmap.Heatspot = Heatspot;
})(Heatmap || (Heatmap = {}));
//# sourceMappingURL=HeatSpot.js.map
var Heatmap;
(function (Heatmap) {
    (function (ScoringFunctionType) {
        ScoringFunctionType[ScoringFunctionType["LinearAscendingDescending"] = 0] = "LinearAscendingDescending";
    })(Heatmap.ScoringFunctionType || (Heatmap.ScoringFunctionType = {}));
    var ScoringFunctionType = Heatmap.ScoringFunctionType;
    var ScoringFunction = (function () {
        function ScoringFunction(scoringFunctionType) {
            if (typeof scoringFunctionType != 'undefined' && scoringFunctionType != null)
                this.type = scoringFunctionType;
            this.title = ScoringFunctionType[scoringFunctionType].toString();
        }
        Object.defineProperty(ScoringFunction.prototype, "cssClass", {
            get: function () {
                return ScoringFunctionType[this.type].toLowerCase();
            },
            enumerable: true,
            configurable: true
        });
        return ScoringFunction;
    }());
    Heatmap.ScoringFunction = ScoringFunction;
    var ScoringFunctions = (function () {
        function ScoringFunctions() {
        }
        return ScoringFunctions;
    }());
    Heatmap.ScoringFunctions = ScoringFunctions;
    var IdealityMeasure = (function () {
        function IdealityMeasure(idealDistance, atLocation, lostInterestDistance) {
            if (idealDistance === void 0) { idealDistance = 500; }
            if (atLocation === void 0) { atLocation = 0.1; }
            if (lostInterestDistance === void 0) { lostInterestDistance = 2000; }
            this.idealDistance = idealDistance;
            this.atLocation = atLocation;
            this.lostInterestDistance = lostInterestDistance;
        }
        IdealityMeasure.prototype.computeIdealityAtDistance = function (distance) {
            var intensity = 0;
            if (distance < this.idealDistance) {
                if (this.atLocation >= 1) {
                    intensity = 1;
                }
                else {
                    intensity = (this.atLocation + (1 - this.atLocation) * distance / this.idealDistance);
                }
            }
            else if (distance < this.lostInterestDistance) {
                intensity = (1 - (distance - this.idealDistance) / (this.lostInterestDistance - this.idealDistance));
            }
            return intensity;
        };
        return IdealityMeasure;
    }());
    Heatmap.IdealityMeasure = IdealityMeasure;
})(Heatmap || (Heatmap = {}));
//# sourceMappingURL=IdealityMeasure.js.map
var IdvEdit;
(function (IdvEdit) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        IdvEdit.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        IdvEdit.myModule = angular.module(moduleName, []);
    }
    var IdvEditCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function IdvEditCtrl($scope, $mapService, $layerService, $messageBusService) {
            this.$scope = $scope;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.scope = $scope;
            $scope.vm = this;
            this.scan = $scope.$parent.data;
            console.log(this);
        }
        IdvEditCtrl.prototype.toggleChart = function (chart) {
            chart.enabled = !chart.enabled;
        };
        IdvEditCtrl.prototype.update = function () {
            this.scan.updateCharts();
        };
        IdvEditCtrl.prototype.reset = function () {
            alert('reset');
        };
        IdvEditCtrl.$inject = [
            '$scope',
            'mapService',
            'layerService',
            'messageBusService',
        ];
        return IdvEditCtrl;
    }());
    IdvEdit.IdvEditCtrl = IdvEditCtrl;
    /**
    * Directive to display the available map layers.
    */
    IdvEdit.myModule.directive('idvedit', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/IdvHelper/IdvEdit.tpl.html',
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                },
                replace: false,
                transclude: false,
                controller: IdvEditCtrl
            };
        }
    ]);
})(IdvEdit || (IdvEdit = {}));
//# sourceMappingURL=IdvEdit.js.map
var Idv;
(function (Idv_1) {
    var Idv = (function () {
        function Idv() {
            this.defaultWidth = 180;
        }
        Idv.prototype.reduceAddSum = function (properties) {
            return function (p, v) {
                ++p.count;
                properties.forEach(function (pr) {
                    var t = parseFloat(v[pr]);
                    if (t > p.max)
                        p.max = t;
                    p[pr] += t;
                });
                return p;
            };
        };
        Idv.prototype.reduceRemoveSum = function (properties) {
            return function (p, v) {
                --p.count;
                properties.forEach(function (pr) {
                    var t = parseFloat(v[pr]);
                    if (t > p.max)
                        p.max = t;
                    p[pr] -= t;
                });
                //p.avg = p.sum / p.count;
                return p;
            };
        };
        Idv.prototype.reduceInitSum = function (properties) {
            var r = {};
            properties.forEach(function (pr) {
                r[pr] = 0;
            });
            return r;
        };
        Idv.prototype.reduceAddAvg = function (attr) {
            return function (p, v) {
                ++p.count;
                var t = parseFloat(v[attr]);
                if (t > p.max)
                    p.max = t;
                p.sum += t;
                p.avg = p.sum / p.count;
                return p;
            };
        };
        Idv.prototype.reduceRemoveAvg = function (attr) {
            return function (p, v) {
                --p.count;
                p.sum -= parseFloat(v[attr]);
                p.avg = p.sum / p.count;
                return p;
            };
        };
        Idv.prototype.reduceInitAvg = function () {
            return { count: 0, sum: 0, avg: 0, max: 0 };
        };
        Idv.prototype.stop = function () {
            this.ndx = null;
            // this.config.charts.forEach(c=>{
            //     if (c.dimension) c.dimension.remove();
            //     if (c.group) c.group.remove();
            // });
        };
        Idv.prototype.updateCharts = function () {
            var _this = this;
            if (this.gridster) {
                $("#" + this.config.containerId).empty();
                this.gridster.destroy();
            }
            $(".chart-title").css("visibility", "visible");
            function getTops(source_group, count) {
                return {
                    all: function () {
                        return source_group.top(count);
                    }
                };
            }
            var elastic = true;
            this.gridster = $("#" + this.config.containerId).gridster({
                widget_margins: [5, 5],
                widget_base_dimensions: [this.defaultWidth - 20, 125],
                min_cols: 6,
                resize: {
                    enabled: false
                },
                autogrow_cols: true,
                draggable: {
                    handle: 'header'
                }
            }).data('gridster');
            this.ndx = crossfilter(this.data);
            if (this.config.charts) {
                this.config.charts.forEach(function (c) {
                    _this.addChart(c);
                });
            }
            dc.renderAll();
            this.triggerFilter(this.config.charts[0]);
            if (this.scope.$root.$$phase !== '$apply' && this.scope.$root.$$phase !== '$digest') {
                this.scope.$apply();
            }
        };
        Idv.prototype.loadDataSource = function (done) {
            done();
        };
        Idv.prototype.resize = function () {
            $("#g-parent").css("height", $(window).height() - 100);
            $("#g-parent").css("width", $(window).width() - 100);
        };
        Idv.prototype.loadData = function (prepare, done) {
            var _this = this;
            var store = 'records3';
            async.series([
                // get enums
                function (cb) {
                    if (typeof _this.config.config !== 'undefined') {
                        d3.json(_this.config.config, function (error, result) {
                            if (!error)
                                _this.enums = result.Enums;
                            cb();
                        });
                    }
                    else {
                        cb();
                    }
                },
                // get data
                function (cb) {
                    _this.state = "Laden data";
                    if (!window.indexedDB) {
                        window.alert("Deze browser is verouderd. Hierdoor zal de informatie trager laden");
                    }
                    else {
                        if (_this.config.localStorage) {
                            var request = window.indexedDB.open(_this.config.data, 9);
                            request.onerror = (function (e) {
                                window.indexedDB.deleteDatabase(_this.config.data);
                            });
                            request.onsuccess = (function (e) {
                                var db = event.target.result;
                                //if (!db.objectStoreNames.contains(store)) var objStore = db.createObjectStore(store, { autoIncrement : true });
                                if (db.objectStoreNames.contains(store)) {
                                    var experiments = [];
                                    async.series([function (cb) {
                                            db.transaction(store, 'readonly').objectStore(store).openCursor().onsuccess = function (d) {
                                                var r = d.target.result;
                                                if (r) {
                                                    var v = r.value;
                                                    v.data.forEach(function (d) { return experiments.push(d); });
                                                    //r.advance(1);                                        
                                                    r.continue();
                                                }
                                                else {
                                                    cb();
                                                }
                                            };
                                        },
                                        function (cb) {
                                            if (experiments.length > 0) {
                                                _this.parseData(experiments, prepare, done);
                                                cb();
                                            }
                                            else {
                                                _this.state = "Verversen data";
                                                d3.csv(_this.config.data, function (error, experiments) {
                                                    _this.state = "Opslaan data";
                                                    var s = db.transaction(store, "readwrite").objectStore(store);
                                                    var l = [];
                                                    var id = 0;
                                                    experiments.forEach(function (e) {
                                                        l.push(e);
                                                        if (l.length > 100000) {
                                                            s.add({ id: id, data: l });
                                                            l = [];
                                                            id += 1;
                                                        }
                                                    });
                                                    _this.parseData(experiments, prepare, done);
                                                    cb();
                                                });
                                            }
                                        }], function (done) {
                                        cb();
                                    });
                                }
                                else {
                                    db.close();
                                }
                            });
                            request.onupgradeneeded = (function (e) {
                                var db = event.target.result;
                                var objStore = db.createObjectStore(store, { keyPath: "id" });
                            });
                        }
                        else {
                            d3.csv(_this.config.data, function (error, experiments) {
                                _this.parseData(experiments, prepare, done);
                                cb();
                            });
                        }
                    }
                }], function (done) {
            });
        };
        Idv.prototype.initCharts = function (scope, layerService, prepare, done) {
            var _this = this;
            this.layerService = layerService;
            this.scope = scope;
            this.state = "Laden configuratie";
            this.resize();
            if (this.config.refreshTimer) {
                setInterval(function () {
                    _this.loadData(prepare, done);
                }, (this.config.refreshTimer));
            }
            this.loadData(prepare, done);
            $(window).resize(function () {
                _this.resize();
            });
        };
        Idv.prototype.parseData = function (data, prepare, done) {
            this.state = "Verwerken data";
            if (this.scope.$$phase !== '$apply' && this.scope.$$phase !== '$digest') {
                this.scope.$apply();
            }
            this.data = data;
            this.DataLoaded = true;
            prepare(this.enums, data);
            this.updateCharts();
            done();
        };
        Idv.prototype.reset = function (id) {
            var cc = _.findWhere(this.config.charts, { id: id });
            if (!_.isUndefined(cc)) {
                cc.chart.filterAll();
                dc.renderAll();
            }
        };
        Idv.prototype.resetAll = function () {
            this.config.charts.forEach(function (c) {
                if (!_.isUndefined(c.chart))
                    c.chart.filterAll();
            });
            dc.renderAll();
        };
        Idv.prototype.hasFilter = function (id) {
            return true;
        };
        Idv.prototype.addSearchWidget = function (config) {
            var _this = this;
            this.createGridsterItem(config);
            config.dimension = this.ndx.dimension(function (d) {
                if (d.hasOwnProperty(config.property)) {
                    return d[config.property];
                }
                else
                    return null;
            });
            var searchHtml = "<input class='searchbutton' id='#" + config.id + "'></input><div id='data-count'><span class='filter-count'></span> geselecteerd van de <span class='total-count'></span> " + config.record + "</div>";
            $("#" + config.elementId).html(searchHtml);
            $(".searchbutton").keyup(function (e) {
                var id = e.target.id.replace('#', '');
                var filterString = e.target.value;
                if (_.isUndefined(filterString))
                    return;
                var chart = _.findWhere(_this.config.charts, { id: id });
                if (!_.isUndefined(chart)) {
                    chart.dimension.filterFunction(function (d) {
                        if (d != null && typeof d.toLowerCase === 'function')
                            return (d.toLowerCase().indexOf(filterString.toLowerCase()) > -1);
                        return false;
                    });
                    chart.dimension.top(Infinity);
                    dc.redrawAll();
                }
                _this.triggerFilter(config);
            });
            var all = this.ndx.groupAll();
            dc.dataCount("#data-count").dimension(this.ndx).group(all); // set group to ndx.groupAll()  
        };
        Idv.prototype.addSumCompare = function (config) {
            this.createGridsterItem(config);
            var updateChart = function (values) {
                try {
                    var vgspec = {
                        'width': 200,
                        'height': 200,
                        'data': [
                            {
                                'name': 'table',
                                'values': values,
                                'transform': [{ 'type': 'pie', 'field': 'value' }]
                            }
                        ],
                        'scales': [
                            {
                                'name': 'r',
                                'type': 'sqrt',
                                'domain': { 'data': 'table', 'field': 'value' },
                                'range': [20, 100]
                            },
                            {
                                "name": "color",
                                "type": "ordinal",
                                "domain": { "data": "table", "field": "position" },
                                "range": "category20"
                            }
                        ],
                        'marks': [
                            {
                                'type': 'arc',
                                'from': { 'data': 'table' },
                                'properties': {
                                    'enter': {
                                        'x': { 'field': { 'group': 'width' }, 'mult': 0.5 },
                                        'y': { 'field': { 'group': 'height' }, 'mult': 0.5 },
                                        'startAngle': { 'field': 'layout_start' },
                                        'endAngle': { 'field': 'layout_end' },
                                        'innerRadius': { 'value': 20 },
                                        'outerRadius': { 'scale': 'r', 'field': 'value' },
                                        'stroke': { 'value': '#fff' }
                                    },
                                    'update': { 'fill': { "scale": "color", "field": "position" } },
                                    'hover': { 'fill': { 'value': 'pink' } }
                                }
                            },
                            {
                                'type': 'text',
                                'from': { 'data': 'table' },
                                'properties': {
                                    'enter': {
                                        'x': { 'field': { 'group': 'width' }, 'mult': 0.5 },
                                        'y': { 'field': { 'group': 'height' }, 'mult': 0.5 },
                                        'radius': { 'scale': 'r', 'field': 'value', 'offset': 8 },
                                        'theta': { 'field': 'layout_mid' },
                                        'fill': { 'value': '#000' },
                                        'align': { 'value': 'center' },
                                        'baseline': { 'value': 'middle' },
                                        'text': { 'field': 'title' }
                                    }
                                }
                            },
                            {
                                'type': 'text',
                                'from': { 'data': 'table' },
                                'properties': {
                                    'enter': {
                                        'x': { 'field': { 'group': 'width' }, 'mult': 0.5 },
                                        'y': { 'field': { 'group': 'height' }, 'mult': 0.5, 'offset': -10 },
                                        'radius': { 'scale': 'r', 'field': 'value', 'offset': 8 },
                                        'theta': { 'field': 'layout_mid' },
                                        'fill': { 'value': '#000' },
                                        'align': { 'value': 'center' },
                                        'baseline': { 'value': 'middle' },
                                        'text': { 'field': 'value' }
                                    }
                                }
                            }
                        ]
                    };
                    //parse(vgspec);
                    if (vgspec)
                        var res = vg.embed("#" + config.elementId, vgspec, function (view, vega_spec) {
                            config._view = view;
                            $("#" + config.elementId).css("margin-left", "30px");
                            //$('.vega-actions').css("display","none");
                            // Callback receiving the View instance and parsed Vega spec...
                            // The View resides under the '#vis' element
                        });
                }
                catch (e) {
                }
            };
            updateChart([]);
            config.filtered = function (result) {
                var res = {};
                config.properties.forEach(function (p) { return res[p] = 0; });
                result.forEach(function (i) {
                    config.properties.forEach(function (p) { if (i.hasOwnProperty(p))
                        res[p] += Math.round(+i[p]); });
                });
                var values = [];
                var pos = 0;
                for (var i in res) {
                    if (res[i] > 0)
                        values.push({ title: i, value: res[i], position: pos });
                    pos += 1;
                }
                updateChart(values);
            };
        };
        Idv.prototype.addLayerLink = function (config) {
            var _this = this;
            config.dimension = this.ndx.dimension(function (d) { return d[config.property]; });
            config.group = config.dimension.group().reduceCount();
            config.filtered = function (result) {
                if (!_.isUndefined(config.layer)) {
                    var l = _this.layerService.findLayer(config.layer);
                    if (!_.isUndefined(l) && l.enabled) {
                        var mapping = {};
                        l.data.features.forEach(function (f) {
                            if (f.properties.hasOwnProperty(config.featureProperty))
                                mapping[f.properties[config.featureProperty]] = f;
                            delete f.properties[config.featureTargetProperty];
                        });
                        var res = config.group.all();
                        res.forEach(function (r) {
                            if (mapping.hasOwnProperty(r.key)) {
                                var f = mapping[r.key];
                                f.properties[config.featureTargetProperty] = r.value;
                            }
                        });
                        _this.layerService.updateLayerFeatures(l);
                        l.group.styles.forEach(function (s) {
                            _this.layerService.removeStyle(s);
                        });
                        _this.layerService.setStyleForProperty(l, config.featureTargetProperty);
                    }
                }
                console.log('do filter with result');
            };
        };
        Idv.prototype.addChartItem = function (config) {
            var _this = this;
            this.createGridsterItem(config);
            if (!config.stat)
                config.stat = "count";
            switch (config.stat) {
                case "sum":
                    config.dimension = this.ndx.dimension(function (d) { return d[config.property]; });
                    config.group = config.dimension.group().reduceSum(function (d) {
                        return { totaal_mensen_auto: +d[config.property] };
                    });
                    switch (config.type) {
                        case "pie":
                            config.dimension = this.ndx.dimension(function (d) { return d; });
                            config.group = config.dimension.group().reduce(this.reduceAddSum(config.properties), this.reduceRemoveSum(config.properties), this.reduceInitSum(config.properties));
                            break;
                    }
                    break;
                case "average":
                    switch (config.type) {
                        case "row":
                            config.dimension = this.ndx.dimension(function (d) { return d[config.property]; });
                            config.group = config.dimension.group().reduce(this.reduceAddAvg(config.secondProperty), this.reduceRemoveAvg(config.secondProperty), this.reduceInitAvg);
                            break;
                        case "line":
                        case "bar":
                            config.dimension = this.ndx.dimension(function (d) { return d[config.time]; });
                            config.group = config.dimension.group().reduce(this.reduceAddAvg(config.property), this.reduceRemoveAvg(config.property), this.reduceInitAvg);
                        case "time":
                            config.dimension = this.ndx.dimension(function (d) { return d[config.time]; });
                            config.group = config.dimension.group().reduce(this.reduceAddAvg(config.property), this.reduceRemoveAvg(config.property), this.reduceInitAvg);
                            break;
                    }
                    break;
                case "pie":
                    config.dimension = config.dimension;
                    config.group = config.group;
                    break;
                case "scatter":
                    config.dimension = this.ndx.dimension(function (d) {
                        var r = +d[config.property];
                        return r;
                    });
                    config.group = config.dimension.group();
                    break;
                case "time":
                    config.dimension = this.ndx.dimension(function (d) { return d[config.time]; });
                    break;
                case "group":
                    if (!config.bins)
                        config.bins = 20;
                    var n_bins = config.bins;
                    var xExtent = d3.extent(this.data, function (d) { return parseFloat(d[config.property]); });
                    var binWidth = (xExtent[1] - xExtent[0]) / n_bins;
                    config.dimension = this.ndx.dimension(function (d) {
                        var c = Math.floor(parseFloat(d[config.property]) / binWidth) * binWidth;
                        return c;
                    });
                    config.group = config.dimension.group().reduceCount();
                    break;
                case "count":
                    config.dimension = this.ndx.dimension(function (d) { return d[config.property]; });
                    config.group = config.dimension.group().reduceCount();
                    break;
            }
            var width = (config.width * this.defaultWidth) - 25;
            var height = (config.height * 125) - 25;
            switch (config.type) {
                case "table":
                    var c = [];
                    config.columns.forEach(function (ci) {
                        c.push({ label: ci.title, format: function (d) {
                                if (ci.hasOwnProperty("type") && ci["type"] === "number")
                                    return d3.round(d[ci.property], 1);
                                return d[ci.property];
                            }
                        });
                    });
                    config.chart = dc.dataTable("#" + config.elementId);
                    config.chart
                        .width(width)
                        .height(height)
                        .dimension(config.dimension)
                        .group(function (d) {
                        var date = d[config.time];
                        return "";
                    })
                        .size(1000)
                        .columns(c);
                    break;
                case "time":
                    config.chart = dc.lineChart("#" + config.elementId);
                    config.chart
                        .width(width)
                        .height(height)
                        .x(d3.time.scale().domain([new Date(2011, 0, 1), new Date(2016, 11, 31)]))
                        .elasticX(true)
                        .elasticY(true)
                        .mouseZoomable(true)
                        .renderHorizontalGridLines(true)
                        .brushOn(true)
                        .dimension(config.dimension)
                        .group(function (d) {
                        //var format = d3.format('02d');
                        return d[config.time];
                    })
                        .renderHorizontalGridLines(true)
                        .on('renderlet', function (chart) {
                        chart.selectAll('rect').on("click", function (d) {
                            // console.log("click!", d);
                        });
                    });
                    break;
                case "line":
                    config.chart = dc.lineChart("#" + config.elementId);
                    config.chart
                        .width(width)
                        .height(height)
                        .x(d3.scale.linear())
                        .elasticX(true)
                        .elasticY(true)
                        .renderHorizontalGridLines(false)
                        .dimension(config.dimension)
                        .group(config.group)
                        .mouseZoomable(true)
                        .on('renderlet', function (chart) {
                        chart.selectAll('rect').on("click", function (d) {
                            // console.log("click!", d);
                        });
                    });
                    break;
                case "pie":
                    config.chart = dc.pieChart("#" + config.elementId);
                    config.chart
                        .width(width)
                        .height(height)
                        .slicesCap(10)
                        .innerRadius(10)
                        .dimension(config.dimension)
                        .group(config.group);
                    break;
                case "bar":
                    config.chart = dc.barChart("#" + config.elementId);
                    config.chart
                        .width(width)
                        .height(height)
                        .x(d3.scale.linear())
                        .centerBar(true)
                        .xUnits(function () { return 20; })
                        .elasticX(true)
                        .elasticY(true)
                        .renderHorizontalGridLines(true)
                        .dimension(config.dimension)
                        .group(config.group);
                    break;
                case "stackedbar":
                    config.chart = dc.barChart("#" + config.elementId);
                    config.chart
                        .width(width)
                        .height(height)
                        .x(d3.scale.linear())
                        .centerBar(false)
                        .xUnits(function () { return 20; })
                        .elasticX(true)
                        .elasticY(true)
                        .renderHorizontalGridLines(true)
                        .dimension(config.dimension)
                        .group(config.group);
                    break;
                case "scatter":
                    config.chart = dc.scatterPlot("#" + config.elementId);
                    config.chart
                        .width(width)
                        .height(height)
                        .symbolSize(3)
                        .x(d3.scale.linear())
                        .y(d3.scale.linear())
                        .elasticX(true)
                        .elasticY(true)
                        .dimension(config.dimension)
                        .group(config.group);
                    break;
                case "row":
                    config.chart = dc.rowChart("#" + config.elementId);
                    config.chart
                        .width(width)
                        .height(height)
                        .gap(1)
                        .elasticX(true)
                        .dimension(config.dimension)
                        .group(config.group)
                        .xAxis().ticks(4);
                    if (!config.ordering)
                        config.ordering = "value";
                    switch (config.ordering) {
                        case "days":
                            config.chart.ordering(function (d) {
                                return Idv.days.indexOf(d.key);
                            });
                            break;
                        case "months":
                            config.chart.ordering(function (d) {
                                return Idv.months.indexOf(d.key);
                            });
                            break;
                        case "value":
                            config.chart.ordering(function (d) {
                                return -d.value;
                            });
                            break;
                    }
                    if (config.cap)
                        config.chart.cap(config.cap);
                    break;
            }
            if (!_.isUndefined(config.xaxis)) {
                config.chart.xAxisLabel(config.xaxis);
            }
            if (!_.isUndefined(config.yaxis)) {
                config.chart.yAxisLabel(config.yaxis);
            }
            config.chart.on("filtered", function (chart, filter) {
                _this.triggerFilter(config);
            });
            if (config.stat === "average") {
                config.chart.valueAccessor(function (d) {
                    return d.value.avg;
                });
            }
            console.log("Add chart " + config.title);
        };
        Idv.prototype.triggerFilter = function (config) {
            var res = config.dimension.top(Infinity);
            this.config.charts.forEach(function (c) {
                if (!_.isUndefined(c.filtered) && _.isFunction(c.filtered)) {
                    c.filtered(res);
                }
                //this.addChart(c)
            });
        };
        Idv.prototype.createGridsterItem = function (config) {
            var _this = this;
            var html = "<li style='padding:4px'><header class='chart-title'><div class='fa fa-ellipsis-v dropdown-toggle' data-toggle='dropdown'  style='float:right;cursor:pointer' type='button'></div>";
            html += "<ul class='dropdown-menu pull-right'><li class='dropdown-item'><a ng-click=\"resetFilter('" + config.id + "')\"'>reset filter</a></li><li class='dropdown-item'><a ng-click=\"resetAll()\">reset all filters</a></li><li class='dropdown-item'><a ng-click=\"disableFilter('" + config.id + "')\">disable filter</a></li>";
            html += "</ul>" + config.title + "</header><div id='" + config.elementId + "' ></li>";
            this.scope.resetFilter = function (id) {
                _this.reset(id);
            };
            this.scope.resetAll = function () {
                _this.resetAll();
            };
            this.scope.disableFilter = function (id) {
                var c = _.findWhere(_this.config.charts, { id: id });
                if (!_.isUndefined(c)) {
                    c.enabled = false;
                    _this.updateCharts();
                }
            };
            var w = this.layerService.$compile(html)(this.scope);
            this.gridster.add_widget(w, config.width, config.height); //"<li><header class='chart-title'><div class='fa fa-times' style='float:right' ng-click='vm.reset()'></div>" + config.title + "</header><div id='" + config.elementId + "'></li>",config.width,config.height);
        };
        Idv.prototype.addChart = function (config) {
            if (typeof config.enabled === 'undefined')
                config.enabled = true;
            if (!config.enabled)
                return;
            if (!config.id)
                config.id = csComp.Helpers.getGuid();
            if (!config.containerId)
                config.containerId = this.config.containerId;
            config.elementId = "ddchart-" + config.id;
            if (!config.title)
                config.title = config.property;
            if (!config.type)
                config.type = "row";
            switch (config.type) {
                case "search":
                    this.addSearchWidget(config);
                    break;
                case "layer":
                    this.addLayerLink(config);
                    break;
                case "sumcompare":
                    this.addSumCompare(config);
                    break;
                default:
                    this.addChartItem(config);
                    break;
            }
        };
        Idv.days = ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"];
        Idv.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "okt", "nov", "dec"];
        return Idv;
    }());
    Idv_1.Idv = Idv;
})(Idv || (Idv = {}));
//# sourceMappingURL=IdvHelper.js.map
var KanbanBoard;
(function (KanbanBoard) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        KanbanBoard.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        KanbanBoard.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    KanbanBoard.myModule.directive('kanbanboardEdit', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/KanbanBoard/KanbanBoard-edit.tpl.html',
                replace: true,
                transclude: true,
                controller: KanbanBoardEditCtrl
            };
        }
    ]);
    var KanbanBoardEditCtrl = (function () {
        function KanbanBoardEditCtrl($scope, $timeout, $compile, $layerService, $templateCache, $messageBus, $mapService, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$compile = $compile;
            this.$layerService = $layerService;
            this.$templateCache = $templateCache;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.data;
            this.propertyTypes = [];
            var p;
            $scope.data = this.widget.data;
            this.allLayers = $layerService.allLayers();
            if ($scope.data && $scope.data.columns && $scope.data.columns.length > 0)
                $scope.selectedColumn = $scope.data.columns[0];
            console.log($scope.data);
        }
        KanbanBoardEditCtrl.prototype.selectColumn = function () {
            console.log(this.$scope.selectedColumn);
        };
        KanbanBoardEditCtrl.prototype.selectLayer = function () {
            console.log(this.layer);
            this.$messageBus.publish("typesource", "", "");
        };
        //
        // //** select a typesResource collection from the dropdown */
        KanbanBoardEditCtrl.prototype.colorUpdated = function (c, i) {
            i.color = c;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        KanbanBoardEditCtrl.$inject = [
            '$scope',
            '$timeout',
            '$compile',
            'layerService',
            '$templateCache',
            'messageBusService',
            'mapService', 'dashboardService'
        ];
        return KanbanBoardEditCtrl;
    }());
    KanbanBoard.KanbanBoardEditCtrl = KanbanBoardEditCtrl;
})(KanbanBoard || (KanbanBoard = {}));
//# sourceMappingURL=KanbanBoard-edit.js.map
var KanbanColumn;
(function (KanbanColumn) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        KanbanColumn.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        KanbanColumn.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    KanbanColumn.myModule.directive('kanbanboard', [
        function () {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/KanbanBoard/KanbanBoard.tpl.html',
                replace: false,
                transclude: false,
                controller: KanbanColumn.KanbanBoardCtrl
            };
        }
    ]);
})(KanbanColumn || (KanbanColumn = {}));
//# sourceMappingURL=KanbanBoard.js.map
var KanbanColumn;
(function (KanbanColumn) {
    var KanbanConfig = (function () {
        function KanbanConfig() {
        }
        return KanbanConfig;
    }());
    KanbanColumn.KanbanConfig = KanbanConfig;
    var KanbanBoardCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function KanbanBoardCtrl($scope, $layerService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.feeds = [];
            this.featureTypes = {};
            $scope.vm = this;
            var par = $scope.$parent;
            this.kanban = par.widget.data;
            if (!this.kanban.hasOwnProperty('canAdd'))
                this.kanban.canAdd = true;
            this.$messageBus.subscribe("typesource", function (s) {
                _this.initLayer();
            });
            this.initLayer();
        }
        KanbanBoardCtrl.prototype.addFeature = function (key) {
            var f = new csComp.Services.Feature();
            f.properties = {};
            var ft = this.featureTypes[key];
            if (ft.properties) {
                for (var k in ft.properties) {
                    f.properties[k] = JSON.parse(JSON.stringify(ft.properties[k]));
                }
            }
            f.properties["date"] = new Date();
            f.properties["updated"] = new Date();
            f.properties["featureTypeId"] = key;
            if (!f.properties.hasOwnProperty('Name'))
                f.properties['Name'] = ft.name;
            this.layer.data.features.push(f);
            this.$layerService.initFeature(f, this.layer);
            this.$layerService.editFeature(f);
        };
        KanbanBoardCtrl.prototype.initLayer = function () {
            console.log('kanban:loaded project');
            if (this.kanban && this.kanban.columns && this.kanban.columns.length > 0) {
                var layerId = this.kanban.columns[0].filters.layerId;
                this.layer = this.$layerService.findLayer(layerId);
                if (this.layer) {
                    if (this.layer.typeUrl && this.$layerService.typesResources.hasOwnProperty(this.layer.typeUrl)) {
                        if (this.kanban.featureTypesToAdd) {
                            this.featureTypes = {};
                            for (var ft in this.$layerService.typesResources[this.layer.typeUrl].featureTypes) {
                                if (this.kanban.featureTypesToAdd.indexOf(ft) > -1)
                                    this.featureTypes[ft] = this.$layerService.typesResources[this.layer.typeUrl].featureTypes[ft];
                            }
                        }
                        else {
                            this.featureTypes = this.$layerService.typesResources[this.layer.typeUrl].featureTypes;
                        }
                        console.log('feature types');
                    }
                }
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        KanbanBoardCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return KanbanBoardCtrl;
    }());
    KanbanColumn.KanbanBoardCtrl = KanbanBoardCtrl;
})(KanbanColumn || (KanbanColumn = {}));
//# sourceMappingURL=KanbanBoardCtrl.js.map
var KanbanColumn;
(function (KanbanColumn) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        KanbanColumn.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        KanbanColumn.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    KanbanColumn.myModule.directive('kanbanColumn', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {
                    column: '=',
                    layer: '=',
                    providedlayer: '='
                },
                templateUrl: 'directives/KanbanBoard/KanbanColumn.tpl.html',
                replace: false,
                transclude: false,
                controller: KanbanColumn.KanbanColumnCtrl
            };
        }
    ]);
})(KanbanColumn || (KanbanColumn = {}));
//# sourceMappingURL=KanbanColumn.js.map
var KanbanColumn;
(function (KanbanColumn) {
    var ColumnFilter = (function () {
        function ColumnFilter() {
        }
        return ColumnFilter;
    }());
    KanbanColumn.ColumnFilter = ColumnFilter;
    var Column = (function () {
        function Column() {
        }
        return Column;
    }());
    KanbanColumn.Column = Column;
    var KanbanColumnCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function KanbanColumnCtrl($scope, $layerService, $messageBus, mapService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.mapService = mapService;
            this.sortOptions = [];
            $scope.vm = this;
            //var par = <any>$scope.$parent;
            //this.kanban = par.widget.data;
            this.column = $scope.column;
            $scope.fields = this.column.fields;
            this.layer = $scope.layer;
            if ($scope.fields.hasOwnProperty('prio'))
                this.sortOptions = this.sortOptions.concat(['High priority', 'Low Priority']);
            if ($scope.fields.hasOwnProperty('date'))
                this.sortOptions = this.sortOptions.concat(['New', 'Old']);
            if ($scope.fields.hasOwnProperty('updated'))
                this.sortOptions = this.sortOptions.concat(['Updated']);
            this.sortOptions = this.sortOptions.concat(['Title']);
            // check if layers should be enabled
            this.initLayers();
            if (!this.column.hasOwnProperty('canShare'))
                this.column.canShare = true;
            if (this.column.orderBy)
                this.setOrder(this.column.orderBy);
            else
                this.setOrder(this.sortOptions[0]);
            $scope.columnFilter = function (feature) {
                var result = true;
                if (!$scope.column)
                    return false;
                // Check that the layerId is applicable.
                if (result && _this.column.filters.layerId !== feature.layerId)
                    return false;
                // Role filter: is a simple AND filter.
                if (_this.column.filters.roles && _this.column.filters.roles.length > 0 && feature.properties.hasOwnProperty('roles')) {
                    _this.column.filters.roles.forEach(function (r) {
                        if (!_.contains(feature.properties['roles'], r))
                            result = false;
                    });
                }
                // Tag filter: complex filter, combines AND (nothing or +), OR (-), and NOT (~) operations. Based on first character:
                if (result && _this.column.filters.tags && _this.column.filters.tags.length > 0 && _this.column.filters.tags.length > 0) {
                    if (!feature.properties.hasOwnProperty('tags'))
                        return false;
                    var tags = feature.properties['tags'];
                    var or = false;
                    _this.column.filters.tags.some(function (tag) {
                        switch (tag[0]) {
                            case '!':
                            case '~':
                                var t = tag.substr(1, tag.length - 1);
                                if (_.contains(tags, t))
                                    result = false;
                                break;
                            case '-':
                                or = true;
                                break;
                            default:
                                if (!_.contains(tags, tag))
                                    result = false;
                                break;
                        }
                        return !result;
                    });
                    // Add the OR features: if any of the OR tags are true, the result is true
                    if (result && or) {
                        or = false;
                        // Only check if there are OR tags (or === true), and we are still showing this item (result === true).
                        _this.column.filters.tags.some(function (tag) {
                            switch (tag[0]) {
                                case '-':
                                    var t = tag.substr(1, tag.length - 1);
                                    if (_.contains(tags, t))
                                        or = true;
                                    break;
                                default:
                                    break;
                            }
                            return or;
                        });
                    }
                    else {
                        or = true;
                    }
                    result = result && or;
                }
                return result;
            };
            setInterval(function () { _this.updateTime(); }, 1000);
        }
        KanbanColumnCtrl.prototype.getClass = function (feature) {
            if (typeof feature.properties === 'undefined')
                return "";
            if (!feature.properties.hasOwnProperty("question"))
                return "";
            return (feature.properties.hasOwnProperty("answered") && feature.properties["answered"] === true)
                ? "isAnsweredQuestion"
                : "isQuestion";
        };
        KanbanColumnCtrl.prototype.clickPrio = function ($event) {
            // var dropdown: any = $($event.target, "> ul");
            // dropdown.css('top', angular.element($event.target).prop('offsetLeft') + "px");
            // dropdown.css('left', angular.element($event.target).prop('offsetTop') + "px");
        };
        KanbanColumnCtrl.prototype.createForm = function (feature) {
            var _this = this;
            if (feature._gui["questions"]) {
                delete feature._gui["questions"];
                this.$layerService.unlockFeature(feature);
            }
            else if (this.$layerService.lockFeature(feature)) {
                feature._gui["questions"] = [];
                feature.properties[this.column.fields['question']].forEach(function (s) {
                    var pt = _this.$layerService.getPropertyType(feature, s);
                    feature._gui["questions"].push({ property: s, ptype: pt });
                });
            }
        };
        KanbanColumnCtrl.prototype.sendForm = function (feature) {
            feature.properties["answered"] = true;
            delete feature._gui["questions"];
            this.$layerService.unlockFeature(feature);
            this.$layerService.saveFeature(feature, true);
        };
        KanbanColumnCtrl.prototype.saveCategory = function (feature, property, value) {
            feature.properties["answered"] = true;
            feature.properties[property] = value;
            delete feature._gui["questions"];
            this.$layerService.unlockFeature(feature);
            this.$layerService.saveFeature(feature, true);
        };
        KanbanColumnCtrl.prototype.updateTime = function () {
            var _this = this;
            this.$layerService.project.features.forEach(function (feature) {
                if (feature.properties.hasOwnProperty('date')) {
                    // Select a timereference to use, e.g., actual date or the timeline's focusdate
                    if (_this.column.timeReference && _this.column.timeReference.toLowerCase() === 'timeline') {
                        var d = feature.properties['date'];
                        if (!feature.hasOwnProperty('_gui'))
                            feature._gui = {};
                        feature._gui['relativeTime'] = moment(d).from(moment(new Date(_this.$layerService.project.timeLine.focus)));
                    }
                    else {
                        var d = feature.properties['date'];
                        if (!feature.hasOwnProperty('_gui'))
                            feature._gui = {};
                        feature._gui['relativeTime'] = moment(d).fromNow();
                    }
                }
                return "";
            });
        };
        KanbanColumnCtrl.prototype.toggleRole = function (feature, role) {
            if (!feature.properties.hasOwnProperty('roles'))
                feature.properties['roles'] = [];
            if (feature.properties['roles'].indexOf(role) === -1) {
                feature.properties['roles'].push(role);
            }
            else {
                feature.properties['roles'] = feature.properties['roles'].filter(function (s) { return s != role; });
            }
            this.$layerService.saveFeature(feature, true);
        };
        KanbanColumnCtrl.prototype.logFilter = function (feature) {
        };
        KanbanColumnCtrl.prototype.startAction = function (action, feature) {
            this.$messageBus.publish("kanbanaction", action, feature);
        };
        KanbanColumnCtrl.prototype.getPrioColor = function (feature) {
            var colors = ["white", "black", "red", "orange", "blue", "green"];
            if (feature.properties.hasOwnProperty(this.column.fields['prio']))
                return {
                    "background-color": colors[parseInt(feature.properties[this.column.fields['prio']])]
                };
            return { "background-color": "white" };
        };
        KanbanColumnCtrl.prototype.setOrder = function (order) {
            this.$scope.columnOrderTitle = order;
            this.column.orderBy = order;
            switch (order) {
                case 'High priority':
                    this.$scope.columnOrderBy = "properties." + this.$scope.fields['prio'];
                    break;
                case 'Low Priority':
                    this.$scope.columnOrderBy = "-properties." + this.$scope.fields['prio'];
                    break;
                case 'New':
                    this.$scope.columnOrderBy = "-properties." + this.$scope.fields['date'];
                    break;
                case 'Old':
                    this.$scope.columnOrderBy = "properties." + this.$scope.fields['date'];
                    break;
                case 'Updated':
                    this.$scope.columnOrderBy = "-properties." + this.$scope.fields['updated'];
                    break;
                case 'Title':
                    this.$scope.columnOrderBy = "properties." + this.$scope.fields['title'];
                    break;
            }
        };
        KanbanColumnCtrl.prototype.updateFeature = function (feature) {
            this.$layerService.saveFeature(feature, true);
        };
        KanbanColumnCtrl.prototype.selectFeature = function (feature) {
            this.$messageBus.publish('kanban', 'onItemSelect', feature);
            if (feature.properties.hasOwnProperty(this.column.fields['question'])) {
                this.createForm(feature);
            }
            else {
                this.$layerService.selectFeature(feature);
            }
        };
        KanbanColumnCtrl.prototype.editFeature = function (feature) {
            this.$layerService.editFeature(feature);
        };
        KanbanColumnCtrl.prototype.searchFeature = function (feature) {
            this.mapService.zoomTo(feature, 15);
            //this.$mapService.
            //this.$layerService.selectFeature(feature);
        };
        /** make sure all layers/feeds are loaded
        we only use the first one for now
         */
        KanbanColumnCtrl.prototype.initLayers = function () {
            var providedLayer = this.$scope.providedlayer;
            if (providedLayer) {
                this.layer = this.$scope.layer;
                return;
            }
            var c = this.$scope.column;
            var lid = c.filters.layerId;
            this.layer = this.$layerService.findLayer(lid);
            if (this.layer) {
                this.$layerService.addLayer(this.layer, function (t) { });
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        KanbanColumnCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            'mapService'
        ];
        return KanbanColumnCtrl;
    }());
    KanbanColumn.KanbanColumnCtrl = KanbanColumnCtrl;
})(KanbanColumn || (KanbanColumn = {}));
//# sourceMappingURL=KanbanColumnCtrl.js.map
var LanguageSwitch;
(function (LanguageSwitch) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        LanguageSwitch.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        LanguageSwitch.myModule = angular.module(moduleName, []);
    }
    LanguageSwitch.myModule.directive('languageSwitch', ['$compile', function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/LanguageSwitch/LanguageSwitch.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: LanguageSwitch.LanguageSwitchCtrl
            };
        }
    ])
        .provider('$languages', function () {
        this.languages = [];
        this.$get = function () {
            return this.languages;
        };
        this.setLanguages = function (languages) {
            this.languages = languages;
        };
    });
})(LanguageSwitch || (LanguageSwitch = {}));
//# sourceMappingURL=LanguageSwitch.js.map
var LanguageSwitch;
(function (LanguageSwitch) {
    var LanguageSwitchCtrl = (function () {
        function LanguageSwitchCtrl($scope, $translate, $languages, $layerService, $messageBus) {
            this.$scope = $scope;
            this.$translate = $translate;
            this.$languages = $languages;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            $scope.vm = this;
            var prefLanguageIndex = 0;
            for (var i = 0; i < $languages.length; i++) {
                if ($languages[i].key === $translate.preferredLanguage()) {
                    prefLanguageIndex = i;
                    break;
                }
            }
            this.language = $languages[prefLanguageIndex];
        }
        LanguageSwitchCtrl.prototype.switchLanguage = function (language) {
            this.language = language;
            this.$translate.use(language.key);
            this.$messageBus.publish('language', 'newLanguage', language.key);
        };
        LanguageSwitchCtrl.$inject = [
            '$scope',
            '$translate',
            '$languages',
            'layerService',
            'messageBusService'
        ];
        return LanguageSwitchCtrl;
    }());
    LanguageSwitch.LanguageSwitchCtrl = LanguageSwitchCtrl;
})(LanguageSwitch || (LanguageSwitch = {}));
//# sourceMappingURL=LanguageSwitchCtrl.js.map
var LayersDirective;
(function (LayersDirective) {
    'use strict';
    var AddLayerCtrl = (function () {
        function AddLayerCtrl($scope, $http, $modalInstance, layerService, translate, messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.$modalInstance = $modalInstance;
            this.layerService = layerService;
            this.translate = translate;
            this.messageBusService = messageBusService;
            $scope.vm = this;
            this.project = this.layerService.project;
            if (this.project.layerDirectory) {
                $http.get(this.project.layerDirectory)
                    .success(function (result) {
                    _this.layers = result;
                })
                    .error(function () { console.log('AddLayerCtrl: error calling $http'); });
            }
        }
        AddLayerCtrl.prototype.addGroup = function () {
            var _this = this;
            if (!this.layerService.project.groups.some(function (g) { return g.title === _this.groupTitle; })) {
                var gr = new csComp.Services.ProjectGroup();
                gr.title = this.groupTitle;
                gr.description = this.groupDescription;
                this.layerService.project.groups.push(gr);
                this.layerService.initGroup(gr);
                this.done();
            }
        };
        AddLayerCtrl.prototype.selectProjectLayer = function (layer) {
            this.selectedLayer = layer;
        };
        AddLayerCtrl.prototype.addProjectLayer = function () {
            var group = this.layerService.findGroupById(this.layerGroup);
            if (group) {
                this.layerService.initLayer(group, this.selectedLayer);
                group.layers.push(this.selectedLayer);
            }
            this.done();
        };
        AddLayerCtrl.prototype.addLayer = function () {
            var group = this.layerService.findGroupById(this.layerGroup);
            if (group) {
                var l = new csComp.Services.ProjectLayer();
                l.title = this.layerTitle;
                this.layerService.initLayer(group, l);
                group.layers.push(l);
                var rpt = csComp.Helpers.createRightPanelTab('edit', 'layeredit', l, 'Edit layer');
                this.messageBusService.publish('rightpanel', 'activate', rpt);
            }
            this.done();
        };
        AddLayerCtrl.prototype.done = function () {
            this.$modalInstance.close('done');
        };
        AddLayerCtrl.prototype.cancel = function () {
            console.log('cancel');
            this.$modalInstance.dismiss('cancel');
        };
        AddLayerCtrl.$inject = [
            '$scope',
            '$http',
            '$modalInstance',
            'layerService',
            '$translate',
            'messageBusService'
        ];
        return AddLayerCtrl;
    }());
    LayersDirective.AddLayerCtrl = AddLayerCtrl;
})(LayersDirective || (LayersDirective = {}));
//# sourceMappingURL=AddLayerCtrl.js.map
var LayersDirective;
(function (LayersDirective) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        LayersDirective.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        LayersDirective.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    LayersDirective.myModule.directive('layersDirective', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/LayersList/LayersDirective.tpl.html',
                replace: true,
                transclude: true,
                controller: LayersDirective.LayersDirectiveCtrl
            };
        }
    ]);
    LayersDirective.myModule.directive('featureType', ['$compile', 'layerService', function ($compile, layerService) {
            var getTemplate = (function (type) {
                var f = {};
                f.fType = type;
                f.featureTypeName = f.fType.name;
                f._gui = {};
                f.effectiveStyle = f.fType.style;
                layerService.calculateFeatureStyle(f);
                switch (f.fType.style.drawingMode) {
                    case "Point":
                        var html = csComp.Helpers.createIconHtml(f);
                        return html.html;
                    case "Line":
                        var html = csComp.Helpers.createIconHtml(f);
                        return html.html;
                    case "Polygon":
                        var html = csComp.Helpers.createIconHtml(f);
                        return html.html;
                }
            });
            return {
                restrict: 'E',
                scope: {
                    featuretype: "="
                },
                link: function (scope, element, attrs) {
                    var el = $compile(getTemplate(scope.featuretype))(scope);
                    element.html(el);
                }
            };
        }]);
    LayersDirective.myModule.directive('featureType2', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {
                    featuretype: "=featuretype"
                },
                template: '<h1>{{featuretype.name}}</h1>',
                replace: true,
                transclude: true,
                controller: function ($scope) {
                    console.log($scope.featuretype);
                },
                link: function (scope, element, attrs) {
                }
            };
        }
    ]);
})(LayersDirective || (LayersDirective = {}));
//# sourceMappingURL=LayersDirective.js.map
var LayersDirective;
(function (LayersDirective) {
    var LayersDirectiveCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function LayersDirectiveCtrl($scope, $layerService, $messageBusService, $mapService, $dashboardService, $modal, $http) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            this.$modal = $modal;
            this.$http = $http;
            this.state = 'layers';
            /** change layer opacity */
            this.updateLayerOpacity = _.debounce(function (layer) {
                console.log('update opacity');
                if (!layer)
                    return;
                if (layer.renderType && layer.renderType.toLowerCase() === 'gridlayer') {
                    _this.$layerService.updateCanvasOverlay(layer);
                }
                else {
                    _this.$layerService.updateLayerFeatures(layer);
                }
            }, 500);
            $scope.vm = this;
            $scope.options = (function (layer) {
                if (!layer.enabled)
                    return null;
                if (layer.layerSource) {
                    return layer.layerSource.layerMenuOptions(layer);
                }
            });
            this.allCollapsed = false;
            this.$messageBusService.subscribe('project', function (title, project) {
                _this.project = project;
                if (title !== 'loaded' || !project)
                    return;
                if (project.hasOwnProperty('collapseAllLayers') && project.collapseAllLayers === true) {
                    _this.allCollapsed = true;
                }
                else {
                    _this.allCollapsed = false;
                }
            });
            this.$messageBusService.subscribe('layerdrop', function (title, layer) {
                _this.dropLayer(layer);
            });
            this.$messageBusService.subscribe('layer', function (action, layer) {
                if (action === 'deactivate' && layer === _this.layer)
                    _this.stopEditingLayer(layer);
                if (action === 'startEditing')
                    _this.editLayer(layer);
            });
            this.$messageBusService.subscribe('featuretype', function (action, type) {
                if (action === 'startEditing') {
                    _this.editFeaturetype(type);
                }
                if (action === 'stopEditing') {
                    _this.editLayer(_this.layer);
                }
            });
        }
        LayersDirectiveCtrl.prototype.dropLayer = function (layer) {
            this.initGroups();
            this.initResources();
            $('#leftPanelTab a[data-target="#layers"]').tab('show');
            this.state = 'createlayer';
            this.newLayer = layer;
            this.newGroup = layer.id;
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
            ;
        };
        LayersDirectiveCtrl.prototype.editGroup = function (group) {
            var rpt = csComp.Helpers.createRightPanelTab('edit', 'groupsettings', group, 'Group Settings', 'Group Settings', 'cog', true, true);
            this.$messageBusService.publish('rightpanel', 'activate', rpt);
        };
        LayersDirectiveCtrl.prototype.layerSettings = function (layer) {
            var rpt = csComp.Helpers.createRightPanelTab('edit', 'layersettings', layer, 'Layer Settings', 'Layer Settings', 'cog', true, true);
            this.$messageBusService.publish('rightpanel', 'activate', rpt);
        };
        /** add new type to a resource file */
        LayersDirectiveCtrl.prototype.addNewType = function () {
            if (this.resource) {
                var st = {
                    drawingMode: 'Point',
                    iconUri: '/images/home.png',
                    cornerRadius: 50,
                    fillColor: 'yellow',
                    iconWidth: 30,
                    iconHeight: 30
                };
                var newType = {};
                newType.id = 'new type';
                newType.name = 'new type';
                newType.style = st;
                newType.propertyTypeKeys = 'title,notes';
                var id = newType.id;
                //this.resource.featureTypes[id] = newType;
                //this.$layerService.saveResource(this.resource);
                this.editFeaturetype(newType);
            }
        };
        LayersDirectiveCtrl.prototype.dropdownpos = function (event) {
            // alert('drop down');
            //     var dropDownTop = button.offset().top + button.outerHeight();
            // dropdown.css('top', dropDownTop + 'px');
            // dropdown.css('left', button.offset().left + 'px');
        };
        LayersDirectiveCtrl.prototype.deleteFeaturetype = function (featureType) {
            if (_.isUndefined(featureType))
                return;
            var tr = this.$layerService.findResourceByLayer(this.layer);
            if (!_.isUndefined(tr)) {
                var types = [];
                for (var t in tr.featureTypes) {
                    if (tr.featureTypes[t].id === featureType.id)
                        types.push(t);
                }
                if (types.length > 0) {
                    types.forEach(function (t) {
                        tr.featureTypes[t] = null;
                        delete tr.featureTypes[t];
                    });
                    this.$layerService.saveResource(tr);
                }
                this.editLayer(this.layer);
            }
        };
        /** start editing feature type */
        LayersDirectiveCtrl.prototype.editFeaturetype = function (featureType) {
            if (this.resource && this.resource.isDynamic) {
                featureType._resource = this.resource;
                this.selectedFeatureType = featureType;
                this.state = 'editfeaturetype';
            }
        };
        LayersDirectiveCtrl.prototype.initGroups = function () {
            var _this = this;
            this.groups = [];
            if (this.$layerService.project.groups)
                this.$layerService.project.groups.forEach(function (g) { return _this.groups.push(g); });
            var g = new csComp.Services.ProjectGroup;
            g.id = '<new>';
            g.title = '<new group>';
            this.groups.push(g);
        };
        // public initDrag(key: string, layer: csComp.Services.ProjectLayer) {
        //     var transformProp;
        //     var startx, starty;
        //     var i = interact('#layerfeaturetype-' + key)
        //         .draggable({
        //         max: Infinity,
        //         onstart: (event) => {
        //             startx = 0;
        //             starty = 0;
        //             event.interaction.x = parseInt(event.target.getAttribute('data-x'), 10) || 0;
        //             event.interaction.y = parseInt(event.target.getAttribute('data-y'), 10) || 0;
        //              var interaction = event.interaction;
        //             // if the pointer was moved while being held down
        //             // and an interaction hasn't started yet
        //                 var original = event.currentTarget,
        //                     // create a clone of the currentTarget element
        //                     clone = event.currentTarget.cloneNode(true);
        //                 // insert the clone to the page
        //                 // TODO: position the clone appropriately
        //                 document.body.appendChild(clone);
        //                 // start a drag interaction targeting the clone
        //                 interaction.start({ name: 'drag' },
        //                                     event.interactable,
        //                                     clone);
        //         },
        //         onmove: (event) => {
        //             event.interaction.x += event.dx;
        //             event.interaction.y += event.dy;
        //             event.target.style.left = event.interaction.x + 'px';
        //             event.target.style.top = event.interaction.y + 'px';
        //         },
        //         onend: (event) => {
        //             setTimeout(() => {
        //                 var x = event.clientX;
        //                 var y = event.clientY;
        //                 var pos = this.$layerService.activeMapRenderer.getLatLon(x, y - 50);
        //                 console.log(pos);
        //                 var f = new csComp.Services.Feature();
        //                 f.layerId = layer.id;
        //                 f.geometry = {
        //                     type: 'Point', coordinates: [pos.lon, pos.lat]
        //                 };
        //                 //f.
        //                 f.properties = { 'featureTypeId': key, 'Name': key };
        //                 layer.data.features.push(f);
        //                 this.$layerService.initFeature(f, layer);
        //                 this.$layerService.activeMapRenderer.addFeature(f);
        //                 this.$layerService.saveFeature(f);
        //             }, 100);
        //             //this.$dashboardService.mainDashboard.widgets.push(widget);
        //             event.target.setAttribute('data-x', 0);
        //             event.target.setAttribute('data-y', 0);
        //             event.target.style.left = '0px';
        //             event.target.style.top = '0px';
        //             console.log(key);
        //         }
        //     })
        // }
        LayersDirectiveCtrl.prototype.initDrag = function (key, layer) {
            var _this = this;
            var transformProp;
            var startx, starty;
            var i = interact('#layerfeaturetype-' + key).draggable({
                'onmove': function (event) {
                    var target = event.target;
                    var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                    var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                    // translate the element
                    target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';
                    // update the posiion attributes
                    target.setAttribute('data-x', x);
                    target.setAttribute('data-y', y);
                },
                'onend': function (event) {
                    console.log('Draggable: ', event);
                    setTimeout(function () {
                        var x = event.clientX;
                        var y = event.clientY;
                        var pos = _this.$layerService.activeMapRenderer.getLatLon(x, y);
                        console.log(pos);
                        var f = new csComp.Services.Feature();
                        f.layerId = layer.id;
                        f.geometry = {
                            type: 'Point', coordinates: [pos.lon, pos.lat]
                        };
                        var fid = 'new object';
                        var tr = _this.$layerService.findResourceByLayer(layer);
                        f.properties = { 'featureTypeId': key, 'Name': fid };
                        if (tr.featureTypes.hasOwnProperty(key)) {
                            var ft = tr.featureTypes[key];
                            if (!ft._isInitialized) {
                                _this.$layerService.initFeatureType(ft, tr.propertyTypeData);
                            }
                            if (_.isArray(ft._propertyTypeData)) {
                                for (var k in ft._propertyTypeData) {
                                    var pt = ft._propertyTypeData[k];
                                    ft._propertyTypeData.forEach(function (pt) {
                                        f.properties[pt.label] = pt.title; //_.isUndefined(pt.defaultValue) ? '' : pt.defaultValue;
                                    });
                                }
                            }
                            fid = ft.name;
                        }
                        layer.data.features.push(f);
                        _this.$layerService.initFeature(f, layer);
                        _this.$layerService.activeMapRenderer.addFeature(f);
                        _this.$layerService.saveFeature(f);
                        _this.$layerService.selectFeature(f);
                    }, 10);
                    //this.$dashboardService.mainDashboard.widgets.push(widget);
                    // event.target.setAttribute('data-x', 0);
                    // event.target.setAttribute('data-y', 0);
                    // event.target.style.left = '0px';
                    // event.target.style.top = '0px';
                    $(event.target).remove();
                }
            }).on('move', function (event) {
                var interaction = event.interaction;
                // if the pointer was moved while being held down
                // and an interaction hasn't started yet
                if (interaction.pointerIsDown && !interaction.interacting() && event.currentTarget.classList.contains('drag-element-source')) {
                    var original = event.target;
                    var pos = { left: 0, top: 0 }; //$(original).offset();
                    // create a clone of the currentTarget element
                    var clone = event.currentTarget.cloneNode(true);
                    // Remove CSS class using JS only (not jQuery or jQLite) - http://stackoverflow.com/a/2155786/4972844
                    clone.className = clone.className.replace(/\bdrag-element-source\b/, '');
                    pos.left = event.clientX - 20; //-interaction.startOffset.left;
                    pos.top = event.clientY - 20; //-interaction.startOffset.top;
                    // update the posiion attributes
                    //  clone.setAttribute('data-x', pos.left);
                    // clone.setAttribute('data-y', pos.top);
                    $(clone).css('left', pos.left);
                    $(clone).css('top', pos.top);
                    $(clone).css('z-index', 1000);
                    // insert the clone to the page
                    // TODO: position the clone appropriately
                    $(document.body).append(clone);
                    // start a drag interaction targeting the clone
                    interaction.start({ name: 'drag' }, event.interactable, clone);
                }
                else {
                    interaction.start({ name: 'drag' }, event.interacFtable, event.currentTarget);
                }
            });
        };
        LayersDirectiveCtrl.prototype.selectProjectLayer = function (layer) {
            this.layer = layer;
        };
        LayersDirectiveCtrl.prototype.exitDirectory = function () {
            this.layer = null;
            this.layerTitle = '';
            this.state = 'layers';
        };
        /* start editing layer */
        LayersDirectiveCtrl.prototype.editLayer = function (layer) {
            this.state = 'editlayer';
            layer.layerSource.startEditing(layer);
            this.layer = layer;
            this.resource = null;
            if (this.layer.typeUrl) {
                if (this.$layerService.typesResources.hasOwnProperty(this.layer.typeUrl)) {
                    this.resource = this.$layerService.typesResources[this.layer.typeUrl];
                }
            }
        };
        /* stop editing layer */
        LayersDirectiveCtrl.prototype.stopEditingLayer = function (layer) {
            this.state = 'layers';
            if (layer._gui['featureTypes']) {
                for (var key in layer._gui['featureTypes']) {
                    interact('#layerfeaturetype-' + key).onstart = null;
                    interact('#layerfeaturetype-' + key).onmove = null;
                    interact('#layerfeaturetype-' + key).onend = null;
                }
                ;
            }
            this.$layerService.stopEditingLayer(layer);
        };
        LayersDirectiveCtrl.prototype.setLayerOpacity = function (layer) {
            this.updateLayerOpacity(layer);
        };
        /** get a list of available layers from the server */
        LayersDirectiveCtrl.prototype.loadAvailableLayers = function () {
            var _this = this;
            this.mylayers = [];
            if (this.project.groups) {
                this.project.groups.forEach(function (g) {
                    g.layers.forEach(function (l) { return _this.mylayers.push(l.url); });
                });
            }
            if (this.project.layerDirectory) {
                $.getJSON(this.project.layerDirectory, function (result) {
                    _this.directory = [];
                    for (var l in result)
                        _this.directory.push(result[l]);
                });
            }
        };
        LayersDirectiveCtrl.prototype.openDirectory = function () {
            this.initGroups();
            this.loadAvailableLayers();
            this.initResources();
            this.state = 'directory';
        };
        /** get a list of resources for the forms */
        LayersDirectiveCtrl.prototype.initResources = function () {
            var _this = this;
            this.resources = {};
            if (!this.project.groups)
                return;
            this.project.groups.forEach(function (g) {
                if (g.layers)
                    g.layers.forEach(function (l) {
                        if (l.typeUrl && !_this.resources.hasOwnProperty(l.typeUrl))
                            _this.resources[l.typeUrl] = { title: l.typeUrl };
                    });
            });
            this.resources['<new>'] = { title: '<new type file>' };
            this.layerResourceType = '<new>';
        };
        /** go to create layer state */
        LayersDirectiveCtrl.prototype.createLayer = function () {
            this.initGroups();
            this.loadAvailableLayers();
            this.initResources();
            if (this.$layerService.project.groups && this.$layerService.project.groups.length > 0) {
                this.layerGroup = this.$layerService.project.groups[0].id;
            }
            else {
                this.layerGroup = new csComp.Services.ProjectGroup;
                this.layerGroup.id = '<new>';
                this.layerGroup.title = '<new group>';
                this.$layerService.project.groups = [];
            }
            this.state = 'createlayer';
            this.newLayer = new csComp.Services.ProjectLayer();
            this.newLayer.type = 'dynamicgeojson';
            this.newLayer.layerSource = this.$layerService.layerSources['dynamicgeojson'];
        };
        /** actually create new layer */
        LayersDirectiveCtrl.prototype.createNewLayer = function () {
            var _this = this;
            //this.loadAvailableLayers();
            var group;
            // new group was selected
            if (this.layerGroup === '<new>') {
                group = new csComp.Services.ProjectGroup;
                group.title = this.newGroup;
                if (this.$layerService.project.groups.some(function (g) { return g.title === _this.newGroup; })) {
                    this.$messageBusService.notify('Error creating group', 'Group already exists');
                    return;
                }
                else {
                    this.$layerService.project.groups.push(group);
                    this.$layerService.initGroup(group);
                }
            }
            else {
                group = this.$layerService.findGroupById(this.layerGroup);
            }
            if (group) {
                var id_1 = encodeURI(this.newLayer.title.toLowerCase());
                this.newLayer.id = id_1;
                var nl = this.newLayer;
                //// make a sensible id
                //var id = nl.title.replace(' ', '_').toLowerCase();
                /// create layer on server
                if (this.newLayer.type === 'dynamicgeojson') {
                    this.newLayer.url = 'api/layers/' + id_1;
                    async.series([
                        // save or find resource
                        function (cb) {
                            if (_this.layerResourceType === '<new>') {
                                // use layer id as a resource id
                                _this.newLayer.typeUrl = 'api/resources/' + id_1;
                                // create empty resource
                                var r = { id: id_1, title: _this.newLayer.title, featureTypes: {}, propertyTypeData: {} };
                                if (_this.newLayer.data && _this.newLayer.data.features && _this.newLayer.data.features.length > 0)
                                    r.featureTypes['Default'] = csComp.Helpers.createDefaultType(_this.newLayer.data.features[0], r);
                                // call api
                                _this.$http.post('api/resources', r)
                                    .success(function (data) {
                                    // resource sucessfully added, continu
                                    cb(null);
                                })
                                    .error(function (e) {
                                    // error adding resource, stop
                                    _this.$messageBusService.notifyError('Creating layer', 'Error creating new layer, resource already exists');
                                    cb(e);
                                });
                            }
                            else {
                                _this.newLayer.typeUrl = _this.layerResourceType;
                                cb(null);
                            }
                        },
                        function (cb) {
                            var l = {
                                id: id_1,
                                title: nl.title,
                                isDynamic: true,
                                type: nl.type,
                                storage: 'file',
                                description: nl.description,
                                typeUrl: nl.typeUrl,
                                tags: nl.tags,
                                url: nl.url,
                                features: []
                            };
                            if (_this.newLayer.data)
                                l.features = _this.newLayer.data.features;
                            // post layer to api
                            _this.$http.post('/api/layers/' + l.id, l)
                                .success(function (data) {
                                // init layer
                                _this.$layerService.initLayer(group, _this.newLayer);
                                // add to group
                                group.layers.push(_this.newLayer);
                                _this.$layerService.addLayer(_this.newLayer);
                                _this.$layerService.saveProject();
                                // layer sucessfully added, continu
                                cb(null);
                            })
                                .error(function (e) {
                                _this.$messageBusService.notifyError('Creating layer', 'Error creating new layer');
                                console.log('error adding layer');
                                cb(e);
                            });
                        }
                    ], function (e) {
                        if (!e) {
                            _this.$messageBusService.notifyError('Creating layer', 'Layer created');
                            _this.exitDirectory();
                        }
                    });
                }
                else {
                    this.$layerService.initLayer(group, this.newLayer);
                    group.layers.push(this.newLayer);
                    this.$layerService.addLayer(this.newLayer);
                    this.exitDirectory();
                }
            }
        };
        /** toggle layer (use shift key to start editing) */
        LayersDirectiveCtrl.prototype.toggleLayer = function (layer, event) {
            var _this = this;
            // if shift key pressed go to edit mode
            if (event.altKey) {
                if (!layer.enabled) {
                    this.$layerService.addLayer(layer, function () { _this.editLayer(layer); });
                }
                else {
                    this.editLayer(layer);
                }
            }
            else {
                this.$layerService.toggleLayer(layer);
            }
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        /** execute layer action */
        LayersDirectiveCtrl.prototype.clickAction = function (o, layer) {
            o.callback(layer, this.$layerService);
        };
        /** triggered when layer was created, make a list of layer actions */
        LayersDirectiveCtrl.prototype.openLayerMenu = function (event, layer) {
            var _this = this;
            console.log('open layer menu');
            event.stopPropagation();
            layer._gui['options'] = [];
            this.$layerService.actionServices.forEach(function (acs) {
                if (_.isFunction(acs.getLayerActions)) {
                    var actions = acs.getLayerActions(layer);
                    if (_.isArray(actions))
                        actions.forEach(function (a) { return layer._gui['options'].push(a); });
                }
            });
            layer._gui['options'].push({ title: 'Layer Settings', callback: function (l, ls) { return _this.layerSettings(l); } });
            $(event.target).next().dropdown('toggle');
            //$(event.target).next().dropdown('toggle');
        };
        LayersDirectiveCtrl.prototype.collapseAll = function () {
            this.$layerService.collapseAll();
            this.allCollapsed = true;
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        LayersDirectiveCtrl.prototype.expandAll = function () {
            this.$layerService.expandAll();
            this.allCollapsed = false;
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        /** Hide groups whose title or id start with an underscore */
        LayersDirectiveCtrl.prototype.filterHiddenGroups = function (group) {
            return group.title[0] !== '_' && group.id[0] !== '_';
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        LayersDirectiveCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            'mapService',
            'dashboardService',
            '$uibModal',
            '$http'
        ];
        return LayersDirectiveCtrl;
    }());
    LayersDirective.LayersDirectiveCtrl = LayersDirectiveCtrl;
})(LayersDirective || (LayersDirective = {}));
//# sourceMappingURL=LayersDirectiveCtrl.js.map
var Legend;
(function (Legend) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Legend.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Legend.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a legend in a widget.
      */
    Legend.myModule.directive('legendDirective', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Legend/Legend.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Legend.LegendCtrl
            };
        }
    ]);
})(Legend || (Legend = {}));
//# sourceMappingURL=Legend.js.map
var Legend;
(function (Legend) {
    // created 12 May 2015, RPS, TNO
    // TODO1: decide how to determine which legend (from which layer) shows up immediately after loading
    // currently the last added layer shows up which is the netatmo layer in csMapUS.
    // And after a reload (refresh), the one for the current indicator's layer shows up
    // TODO2: disappear when empty -> reopen legend for the most recently activated layer that is still active
    // TODO3: positioning: from bottom up (using "bottom" in the project.json file didn't work)
    // TODO4: provide possibility to not show a legend at all. Either by a hide button (but how to show then)
    // or via a project/user setting
    var LegendData = (function () {
        function LegendData() {
        }
        return LegendData;
    }());
    Legend.LegendData = LegendData;
    var LegendCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function LegendCtrl($scope, $layerService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.passcount = 1;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = (par.widget);
            //console.log(JSON.stringify(this.widget.data));
            //$scope.title = this.widget.title;
            //$scope.timestamp = '19:45';
            if (this.widget && this.widget.data)
                $scope.data = this.widget.data;
            //$scope.s1 = $scope.data.propertyTypeKey;
            if (this.widget && this.widget.data && this.widget.data.hasOwnProperty('propertyTypeKey'))
                var ptd = this.$layerService.propertyTypeData[$scope.data.propertyTypeKey];
            //if (ptd) $scope.s2 = ptd.title;
            //$scope.s3 = 'passcount=' + this.passcount.toString();
            // if ($scope.data.mode = 'lastSelectedStyle') {
            //     $scope.legend = this.createLegend($scope.data.propertyTypeKey);
            // }
            if ($scope.data && $scope.data.mode === 'lastSelectedLayer') {
                this.$messageBus.subscribe("layer", function (a, l) {
                    if (a === "activated") {
                        $scope.legend = null;
                        if (l && l.defaultLegend) {
                            $scope.legend = _this.$layerService.getLayerLegend(l);
                            console.log('activate new layer ' + l.title);
                        }
                    }
                });
            }
            else if ($scope.data && $scope.data.mode === 'lastSelectedStyle') {
                $scope.legend = this.createLegend();
                if ($scope.$parent.hasOwnProperty('widget')) {
                    if (!$scope.legend.hasOwnProperty('legendEntries')) {
                        $scope.$parent.widget['enabled'] = false;
                    }
                    else {
                        $scope.$parent.widget['enabled'] = true;
                    }
                }
                if (!this.subscribeHandle) {
                    this.subscribeHandle = this.$messageBus.subscribe("updatelegend", function (title, ptdataKey) {
                        switch (title) {
                            case 'removelegend':
                                _this.$messageBus.unsubscribe(_this.subscribeHandle);
                                break;
                            default:
                                if (ptd && ptd.legend) {
                                    $scope.legend = ptd.legend;
                                }
                                if ($scope.data.mode = 'lastSelectedStyle') {
                                    $scope.legend = _this.createLegend();
                                    if ($scope.$parent.hasOwnProperty('widget')) {
                                        if (!$scope.legend.hasOwnProperty('legendEntries')) {
                                            $scope.$parent.widget['enabled'] = false;
                                        }
                                        else {
                                            $scope.$parent.widget['enabled'] = true;
                                        }
                                    }
                                }
                                if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                                    _this.$scope.$apply();
                                }
                        }
                    });
                }
            }
            else {
                $scope.legend = this.widget.data;
                if ($scope.$parent.hasOwnProperty('widget')) {
                    if (!$scope.legend.hasOwnProperty('legendEntries')) {
                        $scope.$parent.widget['enabled'] = false;
                    }
                    else {
                        $scope.$parent.widget['enabled'] = true;
                    }
                }
            }
        }
        LegendCtrl.prototype.createLegend = function () {
            var leg = new csComp.Services.Legend();
            var activeStyle;
            this.$layerService.project.groups.forEach(function (g) {
                g.styles.forEach(function (gs) {
                    if (gs.enabled) {
                        activeStyle = gs;
                    }
                });
            });
            if (!activeStyle)
                return leg;
            var ptd = this.$layerService.propertyTypeData[activeStyle.property];
            if (!ptd)
                return leg;
            if (ptd.legend)
                return ptd.legend;
            leg.id = ptd.label + 'legendcolors';
            leg.legendKind = 'interpolated';
            leg.description = ptd.title;
            leg.legendEntries = [];
            if (activeStyle.activeLegend && activeStyle.activeLegend.legendEntries) {
                activeStyle.activeLegend.legendEntries.forEach(function (le) {
                    leg.legendEntries.push(le);
                });
            }
            else {
                leg.legendEntries.push(this.createLegendEntry(activeStyle, ptd, activeStyle.info.min));
                leg.legendEntries.push(this.createLegendEntry(activeStyle, ptd, (activeStyle.info.min + activeStyle.info.max) / 4));
                leg.legendEntries.push(this.createLegendEntry(activeStyle, ptd, 2 * (activeStyle.info.min + activeStyle.info.max) / 4));
                leg.legendEntries.push(this.createLegendEntry(activeStyle, ptd, 3 * (activeStyle.info.min + activeStyle.info.max) / 4));
                leg.legendEntries.push(this.createLegendEntry(activeStyle, ptd, activeStyle.info.max));
                leg.legendEntries = leg.legendEntries.sort(function (a, b) { return (a.value - b.value); });
            }
            return leg;
        };
        LegendCtrl.prototype.createLegendEntry = function (activeStyle, ptd, value) {
            var le = new csComp.Services.LegendEntry();
            le.label = csComp.Helpers.convertPropertyInfo(ptd, value);
            if (le.label === value.toString()) {
                //if no stringformatting was applied, define one based on maximum values
                if (activeStyle.info.max > 100) {
                    le.label = String.format("{0:#,#}", value);
                }
                else {
                    le.label = String.format("{0:#,#.#}", value);
                }
            }
            le.value = value;
            le.color = csComp.Helpers.getColor(value, activeStyle);
            return le;
        };
        LegendCtrl.prototype.getStyle = function (legend, le, key) {
            var style = {
                'float': 'left',
                'position': 'relative',
                'top': '10px',
                'background': "linear-gradient(to bottom, " + le.color + ", " + legend.legendEntries[legend.legendEntries.length - key - 2].color + ")",
                'border-left': '1px solid black',
                'border-right': '1px solid black'
            };
            if (key === 0) {
                style['border-top'] = '1px solid black';
            }
            else if (key === legend.legendEntries.length - 2) {
                style['border-bottom'] = '1px solid black';
            }
            return style;
        };
        // $inject annotation
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        LegendCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return LegendCtrl;
    }());
    Legend.LegendCtrl = LegendCtrl;
})(Legend || (Legend = {}));
//# sourceMappingURL=LegendCtrl.js.map
var LegendList;
(function (LegendList) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        LegendList.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        LegendList.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    LegendList.myModule.directive('legendList', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/LegendList/LegendList.tpl.html',
                // Directives that want to modify the DOM typically use the link option.link takes a function with the following signature, function link(scope, element, attrs) { ... } where:
                // scope is an Angular scope object.
                // element is the jqLite - wrapped element that this directive matches.
                // attrs is a hash object with key - value pairs of normalized attribute names and their corresponding attribute values.
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: true,
                transclude: true,
                controller: LegendList.LegendListCtrl
            };
        }
    ]);
})(LegendList || (LegendList = {}));
//# sourceMappingURL=LegendList.js.map
var LegendList;
(function (LegendList) {
    var LegendListCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function LegendListCtrl($scope, $sce, $timeout, layerService, mapService, messageBusService, expressionService) {
            var _this = this;
            this.$scope = $scope;
            this.$sce = $sce;
            this.$timeout = $timeout;
            this.layerService = layerService;
            this.mapService = mapService;
            this.messageBusService = messageBusService;
            this.expressionService = expressionService;
            /** If true, the legend is visible in the DOM. */
            this.isVisible = false;
            $scope.vm = this;
            messageBusService.subscribe('project', function (title) {
                switch (title) {
                    case 'loaded':
                        // Update the legend when a project is loaded.
                        _this.updateLegendItems();
                        break;
                }
            });
            messageBusService.subscribe('layer', function (title) {
                switch (title) {
                    case 'activated':
                    case 'deactivate':
                        // Update the legend when a layer is added or removed.
                        _this.updateLegendItems();
                        break;
                }
            });
            messageBusService.subscribe('mapbbox', function (title, data) {
                if (title !== 'update')
                    return;
                var pts = [];
                data.split(',').forEach(function (p) {
                    pts.push(+p);
                });
                _this.bbox = new L.LatLngBounds([pts[1], pts[0]], [pts[3], pts[2]]);
                // console.log('BBOX: ' + this.bbox.toBBoxString());
                if (_this.isVisible)
                    _this.updateLegendItems();
            });
            // receive a trigger to redraw the legend when it becomes visible.        
            $scope.$watch(function () {
                return $('#legend').is(':visible');
            }, function (isVisible) {
                _this.isVisible = isVisible;
                if (isVisible)
                    _this.updateLegendItems();
            });
            $scope.legendItems = [];
            $scope.numberOfItems = 10; // This is being reset in the directive upon receiving a resize.
        }
        /**
         * Three approaches for creating a legend can be used:
         * 1. Using the featureTypes loaded in LayerService, which is quick, but also includes items that are not shown.
         *    Also, when deactivating the layer, items persist in the legendlist. Finally, items with an icon based on a property
         *    are only shown once (e.g., houses with energylabels).
         * 2. Second approach is to loop over all features on the map and select unique legend items. This is slower for large
         *    amounts of features, but the items in the legendlist are always complete and correct.
         * 3. Third approach is to use a legend that is defined in a featuretype. This is useful if you want to show a custom legend.
         * For 1. use 'updateLegendItemsUsingFeatureTypes()', for 2. use 'updateLegendItemsUsingFeatures(), for 3. use 'updateLegendStatically()'
         */
        LegendListCtrl.prototype.updateLegendItems = function () {
            //this.updateLegendItemsUsingFeatureTypes(); // 1.
            this.updateLegendItemsUsingFeatures(); // 2.
            //this.updateLegendStatically(); // 3.
        };
        /**
         * Loops over every layer in the project. If a layer is enabled, has a typeUrl and a defaultFeatureType,
         * that corresponding featureType is acquired. When the featureType has a property 'legend' in which legenditems are defined,
         * these items are added to the legend.
         * Example definition in the FeatureType:
         * 'MyFeatureType' : {
         *   'legendItems' : [{
         *     'title' : 'My feature',
         *     'uri' : 'images/myicon.png'
         *   }]
         * }
         */
        LegendListCtrl.prototype.updateLegendStatically = function () {
            var _this = this;
            var project = this.layerService.project;
            if (!project)
                return;
            if (!project.hasOwnProperty('groups')) {
                console.log('Creating legend failed: no groups found');
                return;
            }
            var legendItems = [];
            var processedFeatureTypes = {};
            project.groups.forEach(function (g) {
                if (!g.hasOwnProperty('layers'))
                    return;
                g.layers.forEach(function (l) {
                    if (l.enabled && l.hasOwnProperty('typeUrl') && l.hasOwnProperty('defaultFeatureType')) {
                        var typeName = l.typeUrl + '#' + l.defaultFeatureType;
                        var fType = _this.layerService.getFeatureTypeById(typeName);
                        if (!processedFeatureTypes.hasOwnProperty(typeName) && fType && fType.hasOwnProperty('legendItems')) {
                            fType['legendItems'].forEach(function (i) {
                                legendItems.push({ title: i.title, uri: i.uri || '', html: i.html || '' });
                            });
                        }
                        processedFeatureTypes[typeName] = true;
                    }
                });
            });
            this.$scope.legendItems = legendItems;
        };
        LegendListCtrl.prototype.updateLegendItemsUsingFeatureTypes = function () {
            var legendItems = [];
            var existingItems = [];
            for (var key in this.layerService._featureTypes) {
                var ft = this.layerService._featureTypes[key];
                var uri = csComp.Helpers.getImageUri(ft);
                var html = '';
                var title = this.getName(key, ft);
                var existingItem = title + uri;
                if (existingItems.indexOf(existingItem) < 0) {
                    existingItems.push(existingItem);
                    legendItems.push({ 'title': title, 'uri': uri, 'html': html });
                }
            }
            legendItems.sort(function (a, b) {
                if (a.title > b.title)
                    return 1;
                if (a.title < b.title)
                    return -1;
                return 0;
            });
            this.$scope.legendItems = legendItems;
        };
        LegendListCtrl.prototype.updateLegendItemsUsingFeatures = function () {
            var _this = this;
            var sort = true;
            var processedFeatureTypes = {};
            var legendItems = [];
            var existingItems = [];
            if (!this.layerService.project || this.layerService.project.features.length === 0) {
                this.$scope.legendItems = legendItems;
                return;
            }
            // Loop over all features on the map
            this.layerService.project.features.forEach(function (f) {
                if (!f._gui.included)
                    return;
                if (_this.bbox && !_this.bbox.contains(csComp.Helpers.GeoExtensions.getFeatureBounds(f)))
                    return;
                var ft = f.fType;
                if (!ft)
                    ft = _this.layerService.getFeatureType(f);
                if (!ft || processedFeatureTypes.hasOwnProperty(ft.name))
                    return;
                var uri = ft.style && ft.style.hasOwnProperty('iconUri')
                    ? csComp.Helpers.convertStringFormat(f, ft.style.iconUri)
                    : csComp.Helpers.getImageUri(ft);
                var title = ft.name || f.layer.title || (ft.id ? ft.id.split('#').pop() : 'undefined');
                var existingItem = title + uri;
                var i = existingItems.indexOf(existingItem);
                if (i < 0) {
                    // If a (static) legend is defined in the featureType, use it
                    if (ft.hasOwnProperty('legendItems')) {
                        ft['legendItems'].forEach(function (i) {
                            legendItems.push({ title: i.title, uri: i.uri || '', html: i.html || '' });
                        });
                        sort = false;
                        processedFeatureTypes[ft.name] = true;
                        return;
                    }
                    // Else get the legend entry from the feature style
                    if (uri.indexOf('_Media') >= 0)
                        f.effectiveStyle.iconUri = 'cs/images/polygon.png';
                    var html = csComp.Helpers.createIconHtml(f)['html'];
                    existingItems.push(existingItem);
                    legendItems.push({ title: title, uri: uri, html: html, count: 1, expressions: ft.legendExpr, features: [f] });
                }
                else {
                    legendItems[i].features.push(f);
                }
            });
            if (sort) {
                legendItems.sort(function (a, b) {
                    if (a.title > b.title)
                        return 1;
                    if (a.title < b.title)
                        return -1;
                    return 0;
                });
            }
            legendItems.forEach(function (li) {
                li.count = li.features.length;
                if (li.expressions && li.expressions.length > 0) {
                    for (var i = 0, _length = li.expressions.length; i < _length; i++) {
                        var pt = li.expressions[i];
                        pt.calculation = _this.expressionService.evalPropertyType(pt, li.features, null);
                    }
                    delete li.features;
                }
            });
            this.$timeout(function () {
                _this.$scope.legendItems = legendItems;
            }, 0);
        };
        LegendListCtrl.prototype.getName = function (key, ft) {
            return ft.name || key.split('#').pop();
        };
        LegendListCtrl.prototype.toTrusted = function (html) {
            try {
                if (html === undefined || html === null)
                    return this.$sce.trustAsHtml(html);
                return this.$sce.trustAsHtml(html.toString());
            }
            catch (e) {
                console.log(e + ': ' + html);
                return '';
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        LegendListCtrl.$inject = [
            '$scope',
            '$sce',
            '$timeout',
            'layerService',
            'mapService',
            'messageBusService',
            'expressionService'
        ];
        return LegendListCtrl;
    }());
    LegendList.LegendListCtrl = LegendListCtrl;
})(LegendList || (LegendList = {}));
//# sourceMappingURL=LegendListCtrl.js.map
var MapElement;
(function (MapElement) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        MapElement.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        MapElement.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    MapElement.myModule.directive('map', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {
                    mapid: '='
                },
                //templateUrl: 'directives/MapElement/MapElement.tpl.html',
                templateUrl: 'directives/MapElement/MapElement.tpl.html',
                link: function (scope, element, attrs) {
                    //scope.mapid = attrs.mapid;
                    //var s = jQuery.parseJSON(attrs.param);
                    //scope.initDashboard();
                },
                replace: false,
                transclude: true,
                controller: MapElement.MapElementCtrl
            };
        }
    ]);
})(MapElement || (MapElement = {}));
//# sourceMappingURL=MapElement.js.map
var MapElement;
(function (MapElement) {
    var MapElementCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function MapElementCtrl($scope, $layerService, mapService, $messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.mapService = mapService;
            this.$messageBusService = $messageBusService;
            this.locale = 'en-us';
            this.options = ['test', 'boe'];
            $scope.vm = this;
            this.initMap();
            $scope.initMap = function () { return _this.initMap(); };
        }
        MapElementCtrl.prototype.initMap = function () {
            this.$layerService.selectRenderer('leaflet');
        };
        // $inject annotation.
        // It provides $injector with information a'bout dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        MapElementCtrl.$inject = [
            '$scope',
            'layerService',
            'mapService',
            'messageBusService'
        ];
        return MapElementCtrl;
    }());
    MapElement.MapElementCtrl = MapElementCtrl;
})(MapElement || (MapElement = {}));
//# sourceMappingURL=MapElementCtrl.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Mca;
(function (Mca_1) {
    var Models;
    (function (Models) {
        (function (ScoringFunctionType) {
            ScoringFunctionType[ScoringFunctionType["Manual"] = 0] = "Manual";
            ScoringFunctionType[ScoringFunctionType["Ascending"] = 1] = "Ascending";
            ScoringFunctionType[ScoringFunctionType["Descending"] = 2] = "Descending";
            ScoringFunctionType[ScoringFunctionType["AscendingSigmoid"] = 3] = "AscendingSigmoid";
            ScoringFunctionType[ScoringFunctionType["DescendingSigmoid"] = 4] = "DescendingSigmoid";
            ScoringFunctionType[ScoringFunctionType["GaussianPeak"] = 5] = "GaussianPeak";
            ScoringFunctionType[ScoringFunctionType["GaussianValley"] = 6] = "GaussianValley";
        })(Models.ScoringFunctionType || (Models.ScoringFunctionType = {}));
        var ScoringFunctionType = Models.ScoringFunctionType;
        /**
        * Scoring function creates a PLA of the scoring algorithm.
        */
        var ScoringFunction = (function () {
            //get img(): string {
            //    return '/includes/images/plot' + csComp.StringExt.Utils.toUnderscore(ScoringFunctionType[this.type]) + '.png';
            //}
            function ScoringFunction(scoringFunctionType) {
                if (typeof scoringFunctionType != 'undefined' && scoringFunctionType != null) {
                    this.type = scoringFunctionType;
                }
                this.title = ScoringFunctionType[scoringFunctionType].toString();
            }
            Object.defineProperty(ScoringFunction.prototype, "cssClass", {
                get: function () {
                    return ScoringFunctionType[this.type].toLowerCase();
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Create a score based on the type, in which x in [0,10] and y in [0.1].
             * Before applying it, you need to scale the x-axis based on your actual range.
             * Typically, you would map x=0 to the min(x)+0.1*range(x) and x(10)-0.1*range(x) to max(x),
             * i.e. x' = ax+b, where a=100/(8r) and b=-100(min+0.1r)/(8r) and r=max-min
             */
            ScoringFunction.createScores = function (type) {
                var scores;
                switch (type) {
                    default:
                    case ScoringFunctionType.Ascending:
                        scores = '[0,0 10,1]';
                        break;
                    case ScoringFunctionType.Descending:
                        scores = '[0,1 10,0]';
                        break;
                    case ScoringFunctionType.AscendingSigmoid:
                        // http://mathnotepad.com/: f(x) = (3.5+2*atan(x-5))/7
                        // f([0,1,2,3,4,5,6,7,8,9,10])
                        // round(100*f([0,1,2,3,4,5,6,7,8,9,10]))/100
                        // [0.11 0.12 0.14 0.18 0.28 0.5 0.72 0.82 0.86 0.88 0.89]
                        scores = '[0,0.11 1,0.12 2,0.14 3,0.18 4,0.28 5,0.5 6,0.72 7,0.82 8,0.86 9,0.88 10,0.89]';
                        break;
                    case ScoringFunctionType.DescendingSigmoid:
                        // 1-f(x)
                        scores = '[0,0.89 1,0.88 2,0.86 3,0.82 4,0.72 5,0.5 6,0.28 7,0.18 8,0.14 9,0.12 10,0.11]';
                        break;
                    case ScoringFunctionType.GaussianPeak:
                        // h(x)=3*exp(-((x-u)^2)/(2s^2))/(s*sqrt(2pi))
                        scores = '[0,0 2,0.04 3,0.25 4,0.7 5,1 6,0.7 7,0.25 8,0.04 9,0]';
                        break;
                    case ScoringFunctionType.GaussianValley:
                        // 1-h(x)
                        scores = '[0,1 2,0.96 3,0.75 4,0.3 5,0 6,0.3 7,0.75 8,0.96 9,0]';
                        break;
                }
                return scores;
            };
            return ScoringFunction;
        }());
        Models.ScoringFunction = ScoringFunction;
        var ScoringFunctions = (function () {
            function ScoringFunctions() {
            }
            return ScoringFunctions;
        }());
        Models.ScoringFunctions = ScoringFunctions;
        var Criterion = (function () {
            function Criterion() {
                /** Specified weight by the user */
                this.userWeight = 1;
                this.criteria = [];
                /** Piece-wise linear approximation of the scoring function by a set of x and y points */
                this.isPlaUpdated = false;
                /** Piece-wise linear approximation must be scaled:x' = ax+b, where a=100/(8r) and b=-100(min+0.1r)/(8r) and r=max-min */
                this.isPlaScaled = false;
                // Do not serialize the following properties
                this._propValues = [];
                this._x = [];
                this._y = [];
            }
            Criterion.prototype.deserialize = function (input) {
                var _this = this;
                this.title = input.title;
                this.description = input.description;
                this.label = input.label;
                this.color = input.color;
                this.userWeight = input.userWeight;
                this.weight = input.weight;
                this.isPlaScaled = input.isPlaScaled;
                this.scores = input.scores;
                this.minCutoffValue = input.minCutoffValue;
                this.maxCutoffValue = input.maxCutoffValue;
                this.minValue = input.minValue;
                this.maxValue = input.maxValue;
                if (input.criteria) {
                    input.criteria.forEach(function (c) {
                        _this.criteria.push(new Criterion().deserialize(c));
                    });
                }
                return this;
            };
            Criterion.prototype.toJSON = function () {
                var clone = {};
                for (var key in this) {
                    if (key[0] === '_' || !this.hasOwnProperty(key))
                        continue;
                    clone[key] = this[key];
                }
                return clone;
                // return JSON.stringify(this, (key, value) => {
                //      return key[0] === '_' ? undefined : value;
                // });
            };
            Criterion.prototype.requiresMinimum = function () {
                return this.scores && this.scores.indexOf('min') >= 0;
            };
            Criterion.prototype.requiresMaximum = function () {
                return this.scores && this.scores.indexOf('max') >= 0;
            };
            Criterion.prototype.getTitle = function () {
                return this.title
                    ? this.title
                    : this.label;
            };
            /**
             * Update the piecewise linear approximation (PLA) of the scoring (a.k.a. user) function,
             * which translates a property value to a MCA value in the range [0,1] using all features.
             */
            Criterion.prototype.updatePla = function (features) {
                var _this = this;
                if (this.isPlaUpdated) {
                    return;
                }
                if (this.criteria.length > 0) {
                    this.criteria.forEach(function (c) {
                        c.updatePla(features);
                    });
                    this.isPlaUpdated = true;
                    return;
                }
                // Replace min and max by their values:
                if (this.scores == null) {
                    return;
                }
                var scores = this.scores;
                this._propValues = [];
                if (this.requiresMaximum() || this.requiresMinimum() || this.isPlaScaled) {
                    features.forEach(function (feature) {
                        if (feature.properties.hasOwnProperty(_this.label)) {
                            // The property is available. I use the '+' to convert the string value to a number.
                            var prop = feature.properties[_this.label];
                            if ($.isNumeric(prop)) {
                                _this._propValues.push(prop);
                            }
                        }
                    });
                }
                var max = this.maxValue, min = this.minValue;
                if (this.isPlaScaled || this.requiresMaximum()) {
                    max = max || Math.max.apply(null, this._propValues);
                    scores.replace('max', max.toPrecision(3));
                }
                if (this.isPlaScaled || this.requiresMinimum()) {
                    min = min || Math.min.apply(null, this._propValues);
                    scores.replace('min', min.toPrecision(3));
                }
                if (this.isPlaScaled) {
                    var stats = csComp.Helpers.standardDeviation(this._propValues);
                    max = max || Math.min(max, stats.avg + 2 * stats.stdDev);
                    min = min || Math.max(min, stats.avg - 2 * stats.stdDev);
                }
                // Regex to split the scores: [^\d\.]+ and remove empty entries
                var pla = scores.split(/[^\d\.]+/).filter(function (item) { return item.length > 0; });
                // Test that we have an equal number of x and y,
                var range = max - min, a, b;
                if (this.minValue != null || this.maxValue != null) {
                    a = range / 10;
                    b = min;
                }
                else {
                    a = 0.08 * range,
                        b = min + 0.1 * range;
                }
                if (pla.length % 2 !== 0) {
                    throw Error(this.label + ' does not have an even (x,y) pair in scores.');
                }
                for (var i = 0; i < pla.length / 2; i++) {
                    var x = parseFloat(pla[2 * i]);
                    if (this.isPlaScaled) {
                        // Scale x, i.e. x'=ax+b with x'(0)=min+0.1r and x'(10)=max-0.1r, r=max-min
                        // min+0.1r=b
                        // max-0.1r=10a+b=10a+min+0.1r <=> max-min-0.2r=10a <=> 0.8r=10a <=> a=0.08r
                        x = a * x + b;
                    }
                    if (i > 0 && this._x[i - 1] > x) {
                        throw Error(this.label + ': x should increment continuously.');
                    }
                    this._x.push(x);
                    // Test that y in [0, 1].
                    var y = parseFloat(pla[2 * i + 1]);
                    if (y < 0) {
                        y = 0;
                    }
                    else if (y > 1) {
                        y = 1;
                    }
                    this._y.push(y);
                }
                this.isPlaUpdated = true;
            };
            Criterion.prototype.getScore = function (feature) {
                if (!this.isPlaUpdated) {
                    throw ('Error: PLA must be updated for criterion ' + this.title + '!');
                }
                if (this.criteria.length === 0) {
                    // End point: compute the score for each feature
                    if (feature.properties.hasOwnProperty(this.label)) {
                        // The property is available
                        var x = feature.properties[this.label];
                        if (this.maxCutoffValue <= x || x <= this.minCutoffValue) {
                            return 0;
                        }
                        if (x < this._x[0]) {
                            return this._y[0];
                        }
                        var last = this._x.length - 1;
                        if (x > this._x[last]) {
                            return this._y[last];
                        }
                        //for (var k in this.x) {
                        for (var k = 0; k < this._x.length; k++) {
                            if (x < this._x[k]) {
                                // Found relative position of x in this.x
                                var x0 = this._x[k - 1];
                                var x1 = this._x[k];
                                var y0 = this._y[k - 1];
                                var y1 = this._y[k];
                                // Use linear interpolation
                                return (y1 - y0) * (x - x0) / (x1 - x0);
                            }
                        }
                    }
                    else {
                        return 0;
                    }
                }
                else {
                    // Sum all the sub-criteria.
                    var finalScore = 0;
                    this.criteria.forEach(function (crit) {
                        finalScore += crit.weight > 0
                            ? crit.weight * crit.getScore(feature)
                            : Math.abs(crit.weight) * (1 - crit.getScore(feature));
                    });
                    return this.weight > 0
                        ? this.weight * finalScore
                        : Math.abs(this.weight) * (1 - finalScore);
                }
                return 0;
            };
            return Criterion;
        }());
        Models.Criterion = Criterion;
        // NOTE: When extending a base class, make sure that the base class has been defined already.
        var Mca = (function (_super) {
            __extends(Mca, _super);
            function Mca(mca) {
                _super.call(this);
                this.id = csComp.Helpers.getGuid();
                /** Maximum number of star ratings to use to set the weight */
                this.userWeightMax = 5;
                /** Applicable feature ids as a string[]. */
                this.featureIds = [];
                if (mca) {
                    this.deserialize(mca);
                }
                else {
                    this.weight = 1;
                    this.isPlaUpdated = false;
                }
            }
            Object.defineProperty(Mca.prototype, "rankLabel", {
                get: function () {
                    return this.label + '#';
                },
                enumerable: true,
                configurable: true
            });
            Mca.prototype.deserialize = function (input) {
                this.id = input.id;
                this.section = input.section;
                this.stringFormat = input.stringFormat;
                this.rankTitle = input.rankTitle;
                this.rankDescription = input.rankDescription;
                this.rankFormat = input.rankFormat;
                this.userWeightMax = input.userWeightMax;
                this.featureIds = input.featureIds;
                this.minCutoffValue = input.minCutoffValue;
                this.maxCutoffValue = input.maxCutoffValue;
                this.minValue = input.minValue;
                this.maxValue = input.maxValue;
                this.scaleMinValue = input.scaleMinValue;
                this.scaleMaxValue = input.scaleMaxValue;
                _super.prototype.deserialize.call(this, input);
                return this;
            };
            /**
            * Update the MCA by calculating the weights and setting the colors.
            */
            Mca.prototype.update = function () {
                this.calculateWeights();
                this.setColors();
            };
            Mca.prototype.calculateWeights = function (criteria) {
                if (!criteria) {
                    criteria = this.criteria;
                }
                var totalWeight = 0;
                for (var k in criteria) {
                    if (!criteria.hasOwnProperty(k)) {
                        continue;
                    }
                    var crit = criteria[k];
                    if (crit.criteria.length > 0) {
                        this.calculateWeights(crit.criteria);
                    }
                    totalWeight += Math.abs(crit.userWeight);
                }
                if (totalWeight > 0) {
                    for (var j in criteria) {
                        if (!criteria.hasOwnProperty(j)) {
                            continue;
                        }
                        var critj = criteria[j];
                        critj.weight = critj.userWeight / totalWeight;
                    }
                }
            };
            /** Set the colors of all criteria and sub-criteria */
            Mca.prototype.setColors = function () {
                var redColors = chroma.scale('RdYlBu').domain([0, this.criteria.length - 1], this.criteria.length);
                var totalSubcrit = 0;
                var i = 0;
                this.criteria.forEach(function (c) {
                    totalSubcrit += c.criteria.length;
                    if (!c.color) {
                        c.color = redColors(i++).hex();
                    }
                });
                var blueColors = chroma.scale('PRGn').domain([0, totalSubcrit - 1], totalSubcrit);
                i = 0;
                this.criteria.forEach(function (c) {
                    c.criteria.forEach(function (crit) {
                        if (!crit.color) {
                            crit.color = blueColors(i++).hex();
                        }
                    });
                });
            };
            return Mca;
        }(Criterion));
        Models.Mca = Mca;
    })(Models = Mca_1.Models || (Mca_1.Models = {}));
})(Mca || (Mca = {}));
//# sourceMappingURL=Criteria.js.map
var Mca;
(function (Mca) {
    'use strict';
    /**
     * Config
     */
    var moduleName = 'csComp';
    try {
        Mca.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Mca.myModule = angular.module(moduleName, []);
    }
    /**
     * Directive to display an MCA control.
     */
    Mca.myModule
        .directive('mca', [
        '$window', '$compile', '$templateCache',
        function ($window, $compile) {
            return {
                terminal: true,
                restrict: 'EA',
                scope: {},
                templateUrl: 'directives/MCA/Mca.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Mca.McaCtrl
            };
        }
    ]);
})(Mca || (Mca = {}));
//# sourceMappingURL=Mca.js.map
var Mca;
(function (Mca) {
    'use strict';
    var McaCtrl = (function () {
        function McaCtrl($scope, $modal, $translate, $timeout, $localStorageService, layerService, messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$modal = $modal;
            this.$translate = $translate;
            this.$timeout = $timeout;
            this.$localStorageService = $localStorageService;
            this.layerService = layerService;
            this.messageBusService = messageBusService;
            this.features = [];
            this.availableMcas = [];
            this.showAsterChart = false; // When true, show a pie chart, when false, show a bar chart.
            this.showDialog = false;
            this.expertMode = false;
            this.showSparkline = false;
            this.featureMessageReceived = function (title, feature) {
                //console.log("MC: featureMessageReceived");
                if (!_this.mca || !feature || _this.mca.featureIds.indexOf(feature.featureTypeName) < 0)
                    return;
                switch (title) {
                    case 'onFeatureSelect':
                        _this.updateSelectedFeature(feature, true);
                        break;
                    case 'onFeatureDeselect':
                        _this.showFeature = false;
                        _this.selectedFeature = null;
                        _this.drawChart();
                        break;
                    default:
                        //console.log(title);
                        break;
                }
                _this.scopeApply();
            };
            $scope.vm = this;
            messageBusService.subscribe('layer', function (title) {
                switch (title) {
                    case 'deactivate':
                        _this.updateAvailableMcas();
                        break;
                    case 'activated':
                        _this.updateAvailableMcas();
                        _this.calculateMca();
                        break;
                }
            });
            messageBusService.subscribe('project', function (title) {
                switch (title) {
                    case 'loaded':
                        _this.expertMode = layerService.project != null
                            && layerService.project.hasOwnProperty('userPrivileges')
                            && layerService.project.userPrivileges.hasOwnProperty('mca')
                            && layerService.project.userPrivileges.mca.hasOwnProperty('expertMode')
                            && layerService.project.userPrivileges.mca.expertMode;
                        if (typeof layerService.project.mcas === 'undefined' || layerService.project.mcas == null) {
                            layerService.project.mcas = [];
                        }
                        else {
                            // MCA specifications exist. Deserialize them into objects again.
                            var mcaObjects = [];
                            layerService.project.mcas.forEach(function (mca) { return mcaObjects.push(new Mca.Models.Mca(mca)); });
                            layerService.project.mcas = mcaObjects;
                        }
                        var mcas = _this.$localStorageService.get(McaCtrl.mcas);
                        if (typeof mcas === 'undefined' || mcas === null)
                            return;
                        mcas.forEach(function (mca) { return _this.saveMcaToProject(new Mca.Models.Mca(mca)); });
                        break;
                }
            });
            messageBusService.subscribe('feature', this.featureMessageReceived);
            $translate('MCA.DELETE_MSG').then(function (translation) {
                McaCtrl.confirmationMsg1 = translation;
            });
            $translate('MCA.DELETE_MSG2').then(function (translation) {
                McaCtrl.confirmationMsg2 = translation;
            });
        }
        /** Save the MCA to the project, only if it is not already there. */
        McaCtrl.prototype.saveMcaToProject = function (saveMca) {
            var mcas = this.layerService.project.mcas;
            for (var i = 0; i < mcas.length; i++) {
                if (mcas[i].id !== saveMca.id)
                    continue;
                mcas[i] = saveMca;
                return;
            }
            mcas.push(saveMca);
        };
        McaCtrl.prototype.getVotingClass = function (criterion) {
            if (criterion == null || this.mca == null || criterion.userWeight === 0 || criterion.userWeight < -this.mca.userWeightMax || criterion.userWeight > this.mca.userWeightMax) {
                return 'disabledMca';
            }
            return criterion.userWeight > 0 ? 'prefer' : 'avoid';
        };
        // private createDummyMca() {
        //     var mca = new Models.Mca();
        //     mca.title = 'Mijn Zelfredzaamheid';
        //     mca.description = 'Analyse van de zelfredzaamheid van een gemeente.';
        //     mca.label = 'mca_zelfredzaamheid';
        //     mca.stringFormat = '{0:0.0}';
        //     mca.rankTitle = 'Positie';
        //     mca.rankDescription = 'Relatieve positie in de lijst.';
        //     mca.rankFormat = '{0} van {1}';
        //     mca.userWeightMax = 5;
        //     mca.featureIds = ['cities_Default'];
        //     var criterion = new Models.Criterion();
        //     criterion.label = 'p_00_14_jr';
        //     criterion.scores = '[0,0 20,1]';
        //     criterion.userWeight = 1;
        //     mca.criteria.push(criterion);
        //     criterion = new Models.Criterion();
        //     criterion.label = 'p_15_24_jr';
        //     criterion.scores = '[0,0 20,1]';
        //     criterion.userWeight = 1;
        //     mca.criteria.push(criterion);
        //     criterion = new Models.Criterion();
        //     criterion.label = 'p_65_eo_jr';
        //     criterion.scores = '[0,0 25,1]';
        //     criterion.userWeight = 3;
        //     mca.criteria.push(criterion);
        //     this.addMcaToProject(mca);
        //     mca = new Models.Mca();
        //     mca.title = 'test';
        //     mca.label = 'mca_test';
        //     mca.stringFormat = '{0:0.0}';
        //     mca.rankTitle = 'Rang';
        //     mca.rankFormat = '{0} van {1}';
        //     mca.userWeightMax = 3;
        //     mca.featureIds = ['cities_Default'];
        //     criterion = new Models.Criterion();
        //     criterion.label = 'p_15_24_jr';
        //     criterion.scores = '[0,0 20,1]';
        //     criterion.userWeight = 1;
        //     mca.criteria.push(criterion);
        //     criterion = new Models.Criterion();
        //     criterion.label = 'p_65_eo_jr';
        //     criterion.scores = '[0,0 25,1]';
        //     criterion.userWeight = 3;
        //     mca.criteria.push(criterion);
        //     this.addMcaToProject(mca);
        // }
        McaCtrl.prototype.toggleMcaChartType = function () {
            this.showAsterChart = !this.showAsterChart;
            this.drawChart(this.mca.criteria[0]);
        };
        McaCtrl.prototype.toggleSparkline = function () {
            this.showSparkline = !this.showSparkline;
            if (this.showSparkline) {
                this.drawChart();
            }
        };
        McaCtrl.prototype.weightUpdated = function (criterion) {
            this.selectedCriterion = criterion;
            this.updateMca(criterion);
            this.saveMca(this.mca);
        };
        McaCtrl.prototype.updateMca = function (criterion) {
            this.selectedCriterion = criterion;
            this.features = [];
            this.calculateMca();
            this.drawChart(criterion);
        };
        McaCtrl.prototype.editMca = function (mca) {
            this.showMcaEditor(mca);
        };
        McaCtrl.prototype.createMca = function () {
            this.showMcaEditor(new Mca.Models.Mca());
        };
        McaCtrl.prototype.showMcaEditor = function (newMca) {
            var _this = this;
            var modalInstance = this.$modal.open({
                templateUrl: 'directives/MCA/McaEditorView.tpl.html',
                controller: Mca.McaEditorCtrl,
                resolve: {
                    mca: function () { return newMca; }
                }
            });
            modalInstance.result.then(function (mca) {
                _this.showSparkline = false;
                _this.saveMca(mca);
                _this.updateMca();
                //console.log(JSON.stringify(mca, null, 2));
            }, function () {
                //console.log('Modal dismissed at: ' + new Date());
            });
        };
        McaCtrl.prototype.removeMca = function (mca) {
            var _this = this;
            if (!mca) {
                return;
            }
            var title = String.format(McaCtrl.confirmationMsg1, mca.title);
            this.messageBusService.confirm(title, McaCtrl.confirmationMsg2, function (result) {
                if (!result) {
                    return;
                }
                _this.$timeout(function () {
                    _this.deleteMca(mca);
                    if (_this.mca) {
                        _this.updateMca();
                    }
                }, 0);
            });
            this.scopeApply();
        };
        McaCtrl.prototype.getMcaIndex = function (mca) {
            var mcaIndex = -1;
            var mcas = this.layerService.project.mcas;
            for (var i = 0; i < mcas.length; i++) {
                if (mcas[i].title !== mca.title) {
                    continue;
                }
                mcaIndex = i;
                break;
            }
            return mcaIndex;
        };
        McaCtrl.prototype.saveMca = function (mca) {
            if (!mca)
                return;
            this.deleteMca(mca);
            this.saveMcaToProject(mca);
            this.saveMcaToLocalStorage(mca);
            this.updateAvailableMcas(mca);
        };
        McaCtrl.prototype.deleteMca = function (mca) {
            if (!mca) {
                return;
            }
            var mcaIndex = this.getMcaIndex(mca);
            if (mcaIndex < 0) {
                return;
            }
            var mcas = this.layerService.project.mcas;
            if (mcaIndex >= 0) {
                mcas.splice(mcaIndex, 1);
            }
            this.deleteMcaFromLocalStorage(mca);
            this.updateAvailableMcas();
        };
        McaCtrl.prototype.saveMcaToLocalStorage = function (mca) {
            this.deleteMcaFromLocalStorage(mca);
            var mcas = this.$localStorageService.get(McaCtrl.mcas);
            if (typeof mcas === 'undefined' || mcas === null) {
                mcas = [];
            }
            mcas.push(mca);
            this.$localStorageService.set(McaCtrl.mcas, mcas);
        };
        McaCtrl.prototype.deleteMcaFromLocalStorage = function (mca) {
            var mcas = this.$localStorageService.get(McaCtrl.mcas);
            if (typeof mcas === 'undefined' || mcas === null)
                return;
            for (var i = 0; i < mcas.length; i++) {
                if (mcas[i].id !== mca.id)
                    continue;
                mcas.splice(i, 1);
                this.$localStorageService.set(McaCtrl.mcas, mcas);
                return;
            }
        };
        McaCtrl.prototype.scopeApply = function () {
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        McaCtrl.prototype.updateSelectedFeature = function (feature, drawCharts) {
            if (drawCharts === void 0) { drawCharts = false; }
            if (typeof feature === 'undefined' || feature == null) {
                this.featureIcon = '';
                return;
            }
            this.selectedFeature = feature;
            this.featureIcon = this.selectedFeature.fType != null && this.selectedFeature.fType.style != null
                ? this.selectedFeature.fType.style.iconUri
                : '';
            if (!feature.properties.hasOwnProperty(this.mca.label)) {
                return;
            }
            this.showFeature = true;
            this.properties = [];
            var mi = McaCtrl.createPropertyType(this.mca);
            var displayValue = csComp.Helpers.convertPropertyInfo(mi, feature.properties[mi.label]);
            this.properties.push(new FeatureProps.CallOutProperty(mi.title, displayValue, mi.label, true, true, true, feature, false, false, mi.description, mi));
            if (this.mca.rankTitle) {
                mi = McaCtrl.createRankPropertyType(this.mca);
                displayValue = csComp.Helpers.convertPropertyInfo(mi, feature.properties[mi.label]);
                this.properties.push(new FeatureProps.CallOutProperty(mi.title, displayValue, mi.label, false, false, true, feature, false, false, mi.description, mi));
            }
            if (drawCharts) {
                this.drawChart();
            }
        };
        McaCtrl.prototype.drawChart = function (criterion) {
            var _this = this;
            this.selectedCriterion = criterion;
            this.showChart = true;
            if (this.showFeature) {
                if (this.showAsterChart) {
                    this.drawAsterPlot(criterion);
                }
                else {
                    this.drawHistogram(criterion);
                }
            }
            else {
                this.drawPieChart(criterion);
            }
            if (!this.showSparkline) {
                return;
            }
            var i = 0;
            this.mca.criteria.forEach(function (crit) {
                var id = 'histogram_' + i++;
                if (crit.criteria.length === 0) {
                    var y1 = crit._y;
                    if (crit.userWeight < 0) {
                        y1 = y1.map(function (v) { return 1 - v; });
                    }
                    csComp.Helpers.Plot.drawMcaPlot(crit._propValues, {
                        id: id,
                        width: 220,
                        height: 70,
                        xy: { x: crit._x, y: y1 },
                        featureValue: _this.selectedFeature ? _this.selectedFeature.properties[crit.label] : null
                    });
                }
                else {
                    var j = 0;
                    crit.criteria.forEach(function (c) {
                        var y2 = c._y;
                        if (crit.userWeight < 0) {
                            y2 = y2.map(function (v) { return 1 - v; });
                        }
                        csComp.Helpers.Plot.drawMcaPlot(c._propValues, {
                            id: id + '_' + j++,
                            width: 220,
                            height: 70,
                            xy: { x: c._x, y: y2 },
                            featureValue: _this.selectedFeature ? _this.selectedFeature.properties[c.label] : null
                        });
                    });
                }
            });
        };
        McaCtrl.prototype.getTitle = function (criterion) {
            return criterion.title || criterion.label;
        };
        McaCtrl.prototype.getParentOfSelectedCriterion = function (criterion) {
            var _this = this;
            var parent;
            this.mca.update();
            if (typeof criterion === 'undefined' || this.mca.criteria.indexOf(criterion) >= 0) {
                this.selectedCriterion = null;
                parent = this.mca.criteria;
            }
            else {
                this.mca.criteria.forEach(function (c) {
                    if (c.criteria.indexOf(criterion) >= 0) {
                        _this.selectedCriterion = c;
                        parent = c.criteria;
                    }
                });
            }
            return parent;
        };
        McaCtrl.prototype.drawHistogram = function (criterion) {
            var _this = this;
            if (!this.mca || !this.selectedFeature) {
                return;
            }
            var currentLevel = this.getParentOfSelectedCriterion(criterion);
            if (typeof currentLevel === 'undefined' || currentLevel == null) {
                return;
            }
            var data = [];
            var options = {
                id: McaCtrl.mcaChartId,
                numberOfBins: 10,
                width: 240,
                height: 100,
                selectedValue: this.selectedFeature.properties[this.mca.label]
            };
            this.features.forEach(function (feature) {
                if (feature.properties.hasOwnProperty(_this.mca.label)) {
                    // The property is available. I use the '+' to convert the string value to a number.
                    var prop = feature.properties[_this.mca.label];
                    if ($.isNumeric(prop))
                        data.push(prop);
                }
            });
            csComp.Helpers.Plot.drawHistogram(data, options);
        };
        McaCtrl.prototype.drawAsterPlot = function (criterion) {
            var _this = this;
            if (!this.mca || !this.selectedFeature) {
                return;
            }
            var currentLevel = this.getParentOfSelectedCriterion(criterion);
            if (typeof currentLevel === 'undefined' || currentLevel == null) {
                return;
            }
            var data = [];
            var i = 0;
            currentLevel.forEach(function (c) {
                var rawScore = c.getScore(_this.selectedFeature);
                var pieData = new csComp.Helpers.AsterPieData();
                pieData.id = i++;
                pieData.label = c.getTitle();
                pieData.weight = Math.abs(c.weight);
                pieData.color = c.color;
                pieData.score = (c.weight > 0 ? rawScore : 1 - rawScore) * 100;
                data.push(pieData);
            });
            csComp.Helpers.Plot.drawAsterPlot(100, data, McaCtrl.mcaChartId);
        };
        McaCtrl.prototype.drawPieChart = function (criterion) {
            if (!this.mca) {
                return;
            }
            var currentLevel = this.getParentOfSelectedCriterion(criterion);
            if (typeof currentLevel === 'undefined' || currentLevel == null) {
                return;
            }
            var data = [];
            var i = 0;
            currentLevel.forEach(function (c) {
                var pieData = new csComp.Helpers.PieData();
                pieData.id = i++;
                pieData.label = c.getTitle();
                pieData.weight = Math.abs(c.weight);
                pieData.color = c.color;
                data.push(pieData);
            });
            csComp.Helpers.Plot.drawPie(100, data, McaCtrl.mcaChartId);
        };
        /**
        * Based on the currently loaded features, which MCA can we use
        */
        McaCtrl.prototype.updateAvailableMcas = function (mca) {
            var _this = this;
            this.showChart = false;
            this.mca = mca;
            this.availableMcas = [];
            if (this.layerService.project.mcas) {
                this.layerService.project.mcas.forEach(function (m) {
                    if (!m.featureIds) {
                        return;
                    }
                    m.featureIds.forEach(function (featureId) {
                        if (_this.availableMcas.indexOf(m) < 0 && _this.layerService._featureTypes.hasOwnProperty(featureId)) {
                            _this.availableMcas.push(m);
                            var featureType = _this.layerService._featureTypes[featureId];
                            _this.applyPropertyInfoToCriteria(m, featureType);
                        }
                    });
                });
            }
            if (!mca && this.availableMcas.length > 0) {
                this.mca = this.availableMcas[0];
                this.updateMca();
            }
        };
        McaCtrl.prototype.calculateMca = function () {
            var _this = this;
            if (!this.mca)
                return;
            var mca = this.mca;
            mca.featureIds.forEach(function (featureId) {
                if (!(_this.layerService._featureTypes.hasOwnProperty(featureId))) {
                    return;
                }
                _this.addPropertyInfo(featureId, mca);
                _this.layerService.project.features.forEach(function (feature) {
                    if (feature.featureTypeName != null && feature.featureTypeName === featureId) {
                        _this.features.push(feature);
                    }
                });
                if (_this.features.length === 0) {
                    return;
                }
                mca.updatePla(_this.features);
                mca.update();
                var tempScores = [];
                var index = 0;
                _this.features.forEach(function (feature) {
                    var score = mca.getScore(feature);
                    if (mca.rankTitle) {
                        var tempItem = { score: score, index: index++ };
                        tempScores.push(tempItem);
                    }
                    feature.properties[mca.label] = score * 100;
                    _this.layerService.calculateFeatureStyle(feature);
                    _this.layerService.activeMapRenderer.updateFeature(feature);
                    //this.$layerService.updateFeature(feature);
                });
                if (mca.rankTitle) {
                    // Add rank information
                    tempScores.sort(function (a, b) { return b.score - a.score; });
                    var length = _this.features.length;
                    var scaleRange = mca.scaleMinValue ? Math.abs(mca.scaleMaxValue - mca.scaleMinValue) + 1 : length;
                    var scaleFactor = Math.ceil(length / scaleRange);
                    var rankFunction = mca.scaleMinValue
                        ? mca.scaleMaxValue > mca.scaleMinValue
                            ? function (position) { return mca.scaleMaxValue - Math.round(position / scaleFactor); }
                            : function (position) { return mca.scaleMinValue + Math.round(position / scaleFactor); }
                        : function (position) { return position; };
                    var prevScore = -1;
                    var rank = 1;
                    for (var i = 0; i < length; i++) {
                        var item = tempScores[i];
                        // Assign items with the same value the same rank.
                        if (item.score !== prevScore) {
                            rank = i + 1;
                        }
                        prevScore = item.score;
                        _this.features[item.index].properties[mca.label + '#'] = rankFunction(rank) + ',' + scaleRange;
                    }
                }
            });
            this.updateSelectedFeature(this.selectedFeature, false);
            if (this.selectedFeature) {
                this.messageBusService.publish('feature', 'onFeatureSelect', this.selectedFeature);
            }
            if (this.groupStyle) {
                this.layerService.updateStyle(this.groupStyle);
            }
        };
        McaCtrl.prototype.applyPropertyInfoToCriteria = function (mca, featureType) {
            var propertyTypes = csComp.Helpers.getPropertyTypes(featureType, this.layerService.propertyTypeData);
            if (propertyTypes.length === 0) {
                return;
            }
            mca.criteria.forEach(function (criterion) {
                var label = criterion.label;
                propertyTypes.forEach(function (propInfo) {
                    if (propInfo.label === label) {
                        criterion.title = propInfo.title;
                        criterion.description = propInfo.description;
                    }
                });
            });
        };
        McaCtrl.prototype.addPropertyInfo = function (featureId, mca, forceUpdate) {
            if (forceUpdate === void 0) { forceUpdate = false; }
            var featureType = this.layerService._featureTypes[featureId];
            //var propertyTypes = featureType.propertyTypeData;
            var propertyTypes = csComp.Helpers.getPropertyTypes(featureType, this.layerService.propertyTypeData);
            var labelIndex = -1;
            for (var i = propertyTypes.length - 1; i >= 0; i--) {
                if (propertyTypes[i].label === mca.label) {
                    labelIndex = i;
                    break;
                }
            }
            if (forceUpdate || labelIndex < 0) {
                var pt = McaCtrl.createPropertyType(mca);
                if (labelIndex < 0) {
                    if (!featureType._propertyTypeData) {
                        featureType._propertyTypeData = [];
                    }
                    featureType._propertyTypeData.push(pt); // NOTE: propertyTypes refers to a new list, so you cannot add to it.
                }
                else {
                    propertyTypes[labelIndex] = pt; // NOTE: but you should be able to overwrite an existing property.
                }
            }
            if (!mca.rankTitle) {
                return;
            }
            labelIndex = -1;
            for (i = propertyTypes.length - 1; i >= 0; i--) {
                if (propertyTypes[i].label === mca.rankLabel) {
                    labelIndex = i;
                    break;
                }
            }
            if (forceUpdate || labelIndex < 0) {
                pt = McaCtrl.createRankPropertyType(mca);
                if (labelIndex < 0) {
                    featureType._propertyTypeData.push(pt);
                }
                else {
                    propertyTypes[labelIndex] = pt;
                }
            }
        };
        McaCtrl.prototype.setStyle = function (item) {
            // If groupStyle has been set, we have called it before.
            // However, make sure that not another filter has set the fillColor too, overwriting our label.
            if (this.groupStyle
                && this.groupStyle.group != null
                && this.groupStyle.group.styles != null
                && this.groupStyle.group.styles.filter(function (s) { return s.visualAspect === 'fillColor'; })[0].property === this.mca.label) {
                this.layerService.updateStyle(this.groupStyle);
            }
            else {
                this.groupStyle = this.layerService.setStyle(item, false);
                this.groupStyle.colors = ['#F04030', '#3040F0'];
                this.layerService.updateStyle(this.groupStyle);
            }
        };
        McaCtrl.createPropertyType = function (mca) {
            var mi = {
                title: mca.title,
                label: mca.label,
                type: 'number',
                maxValue: 1,
                minValue: 0,
                description: mca.description,
                stringFormat: mca.stringFormat,
                visibleInCallOut: true,
                section: mca.section || 'MCA'
            };
            return mi;
        };
        McaCtrl.createRankPropertyType = function (mca) {
            var mi = {
                title: mca.rankTitle,
                label: mca.rankLabel,
                type: 'rank',
                description: mca.rankDescription,
                stringFormat: mca.rankFormat,
                visibleInCallOut: true,
                section: mca.section || 'MCA'
            };
            return mi;
        };
        McaCtrl.mcaChartId = 'mcaChart';
        McaCtrl.mcas = 'MCAs';
        McaCtrl.$inject = [
            '$scope',
            '$uibModal',
            '$translate',
            '$timeout',
            'localStorageService',
            'layerService',
            'messageBusService'
        ];
        return McaCtrl;
    }());
    Mca.McaCtrl = McaCtrl;
})(Mca || (Mca = {}));
//# sourceMappingURL=McaCtrl.js.map
var Mca;
(function (Mca) {
    'use strict';
    var McaEditorCtrl = (function () {
        function McaEditorCtrl($scope, $modalInstance, $layerService, $translate, messageBusService, mca) {
            var _this = this;
            this.$scope = $scope;
            this.$modalInstance = $modalInstance;
            this.$layerService = $layerService;
            this.$translate = $translate;
            this.messageBusService = messageBusService;
            this.mca = mca;
            this.propInfos = [];
            this.headers = [];
            this.scoringFunctions = [];
            $scope.vm = this;
            this.scoringFunctions.push(new Mca.Models.ScoringFunction(Mca.Models.ScoringFunctionType.Ascending));
            //this.scoringFunctions.push(new Models.ScoringFunction(Models.ScoringFunctionType.Descending));
            this.scoringFunctions.push(new Mca.Models.ScoringFunction(Mca.Models.ScoringFunctionType.AscendingSigmoid));
            //this.scoringFunctions.push(new Models.ScoringFunction(Models.ScoringFunctionType.DescendingSigmoid));
            this.scoringFunctions.push(new Mca.Models.ScoringFunction(Mca.Models.ScoringFunctionType.GaussianPeak));
            //this.scoringFunctions.push(new Models.ScoringFunction(Models.ScoringFunctionType.GaussianValley));
            //this.scoringFunctions.push(new Models.ScoringFunction(Models.ScoringFunctionType.Manual));
            $translate('MCA.LINEAR').then(function (translation) {
                _this.scoringFunctions[0].title = translation;
            });
            $translate('MCA.SIGMOID').then(function (translation) {
                _this.scoringFunctions[1].title = translation;
            });
            $translate('MCA.GAUSSIAN').then(function (translation) {
                _this.scoringFunctions[2].title = translation;
            });
            this.dataset = csComp.Helpers.loadMapLayers(this.$layerService);
            messageBusService.subscribe('layer', function () {
                _this.dataset = csComp.Helpers.loadMapLayers(_this.$layerService);
            });
            this.mcaTitle = mca.title;
            this.rankTitle = mca.rankTitle;
            this.scaleMin = mca.scaleMinValue;
            this.scaleMax = mca.scaleMaxValue;
            this.selectedFeatureType = mca.featureIds.length === 0 ? '' : this.dataset.featureTypes[mca.featureIds[0]];
            if (this.selectedFeatureType) {
                this.updatePropertyInfo(this.selectedFeatureType);
                this.updatePropertyInfoUponEdit(mca);
            }
            else {
                this.selectFirstFeatureType();
            }
        }
        McaEditorCtrl.prototype.updatePropertyInfoUponEdit = function (criterion, category) {
            var _this = this;
            criterion.criteria.forEach(function (c) {
                if (c.label) {
                    var propInfos = _this.propInfos;
                    for (var i in propInfos) {
                        if (!propInfos.hasOwnProperty(i))
                            continue;
                        var mi = propInfos[i];
                        if (mi.label !== c.label)
                            continue;
                        mi.isSelected = true;
                        mi.minCutoffValue = c.minCutoffValue;
                        mi.maxCutoffValue = c.maxCutoffValue;
                        mi.minValue = c.minValue;
                        mi.maxValue = c.maxValue;
                        mi.userWeight = c.userWeight;
                        if (category) {
                            mi.category = category;
                        }
                        break;
                    }
                }
                else {
                    _this.updatePropertyInfoUponEdit(c, c.title);
                }
            });
        };
        McaEditorCtrl.prototype.loadPropertyTypes = function () {
            this.updatePropertyInfo(this.selectedFeatureType);
        };
        ///** 
        // * Load the features as visible on the map.
        // */
        //private loadMapLayers(): void {
        //    var data         : IGeoJsonFile = {
        //        type         : '',
        //        features     : [],
        //        featureTypes : {}
        //    };
        //    // If we are filtering, load the filter results
        //    this.$layerService.project.groups.forEach((group) => {
        //        if (group.filterResult != null)
        //            group.filterResult.forEach((f) => data.features.push(f));
        //    });
        //    // Otherwise, take all loaded features
        //    if (data.features.length === 0)
        //        data.features = this.$layerService.project.features;
        //    data.features.forEach((f: IFeature) => {
        //        if (!(data.featureTypes.hasOwnProperty(f.featureTypeName))) {
        //            var featureType = data.featureTypes[f.featureTypeName];
        //            if (!featureType.name) featureType.name = f.featureTypeName.replace('_Default', '');
        //            data.featureTypes[f.featureTypeName] = featureType;
        //        }
        //    });
        //    this.dataset = data;
        //}
        McaEditorCtrl.prototype.selectFirstFeatureType = function () {
            var featureTypes = this.dataset.featureTypes;
            for (var key in featureTypes) {
                if (!featureTypes.hasOwnProperty(key))
                    continue;
                this.selectedFeatureType = featureTypes[key];
                this.updatePropertyInfo(this.selectedFeatureType);
                return;
            }
        };
        McaEditorCtrl.prototype.updatePropertyInfo = function (featureType) {
            var _this = this;
            this.propInfos = [];
            this.headers = [];
            var titles = [];
            var pis = [];
            // Push the Name, so it always appears on top.
            pis.push({
                label: 'Name',
                visibleInCallOut: true,
                title: 'Naam',
                type: 'text',
                filterType: 'text',
                isSelected: false,
                scoringFunctionType: this.scoringFunctions[0].type
            });
            if (featureType.propertyTypeKeys != null) {
                var keys = featureType.propertyTypeKeys.split(/[,;]+/);
                keys.forEach(function (k) {
                    if (_this.$layerService.propertyTypeData.hasOwnProperty(k))
                        pis.push(_this.$layerService.propertyTypeData[k]);
                    else if (featureType._propertyTypeData != null) {
                        var result = $.grep(featureType._propertyTypeData, function (e) { return e.label === k; });
                        if (result.length >= 1)
                            pis.push(result);
                    }
                });
            }
            else if (featureType._propertyTypeData != null) {
                featureType._propertyTypeData.forEach(function (mi) { return pis.push(mi); });
            }
            pis.forEach(function (pi) {
                // TODO Later, we could also include categories and not only numbers, where each category represents a certain value.
                if (pi.visibleInCallOut && pi.type === 'number' && pi.label.indexOf('mca_') < 0 && titles.indexOf(pi.title) < 0) {
                    titles.push(pi.title);
                    // Clone object inline. See http://stackoverflow.com/a/122704/319711
                    _this.propInfos.push({
                        title: pi.title,
                        label: pi.label,
                        stringFormat: pi.stringFormat,
                        isSelected: false,
                        maxValue: pi.maxValue,
                        minValue: pi.minValue,
                        defaultValue: pi.defaultValue,
                        description: pi.description
                    });
                }
            });
        };
        McaEditorCtrl.prototype.toggleSelection = function (metaInfoTitle) {
            var idx = this.headers.indexOf(metaInfoTitle);
            // is currently selected
            if (idx > -1) {
                this.headers.splice(idx, 1);
            }
            else {
                this.headers.push(metaInfoTitle);
            }
        };
        McaEditorCtrl.prototype.isDisabled = function () {
            if (typeof this.mcaTitle === 'undefined' || this.mcaTitle.length === 0)
                return true;
            if (this.propInfos.length === 0 || !this.propInfos.reduce(function (p, c) { return p || c.isSelected; }))
                return true;
            return false;
        };
        /**
         * Create a new MCA criterion
         */
        McaEditorCtrl.prototype.save = function () {
            var mca = new Mca.Models.Mca();
            mca.title = this.mcaTitle || 'New MCA criterion';
            mca.label = 'mca_' + mca.title.replace(' ', '_');
            mca.stringFormat = '{0:0.0}';
            if (this.rankTitle) {
                mca.rankTitle = this.rankTitle || 'Rank';
                mca.rankFormat = '{0} / {1}';
            }
            if (this.scaleMin && this.scaleMax) {
                mca.scaleMinValue = this.scaleMin;
                mca.scaleMaxValue = this.scaleMax;
            }
            mca.userWeightMax = 5;
            var featureTypes = this.dataset.featureTypes;
            for (var key in featureTypes) {
                if (!featureTypes.hasOwnProperty(key))
                    continue;
                if (featureTypes[key] === this.selectedFeatureType)
                    mca.featureIds = [key];
            }
            this.propInfos.forEach(function (mi) {
                if (!mi.isSelected)
                    return;
                var criterion = new Mca.Models.Criterion();
                criterion.label = mi.label;
                criterion.title = mi.title;
                criterion.isPlaScaled = true;
                criterion.description = mi.description;
                criterion.userWeight = mi.userWeight || 1;
                criterion.minCutoffValue = mi.minCutoffValue ? +mi.minCutoffValue : undefined;
                criterion.maxCutoffValue = mi.maxCutoffValue ? +mi.maxCutoffValue : undefined;
                criterion.minValue = mi.minValue ? +mi.minValue : undefined;
                criterion.maxValue = mi.maxValue ? +mi.maxValue : undefined;
                if (mi.scoringFunctionType === Mca.Models.ScoringFunctionType.Manual) {
                    criterion.scores = mi.scores;
                }
                else {
                    criterion.scores = Mca.Models.ScoringFunction.createScores(mi.scoringFunctionType);
                }
                if (mi.category) {
                    var parent;
                    for (var i in mca.criteria) {
                        if (!mca.criteria.hasOwnProperty(i))
                            continue;
                        var c = mca.criteria[i];
                        if (c.title !== mi.category)
                            continue;
                        parent = c;
                        break;
                    }
                    if (parent == null) {
                        parent = new Mca.Models.Criterion;
                        parent.title = mi.category;
                        parent.isPlaUpdated = false;
                        mca.criteria.push(parent);
                    }
                    parent.criteria.push(criterion);
                }
                else {
                    mca.criteria.push(criterion);
                }
            });
            this.$modalInstance.close(mca);
        };
        McaEditorCtrl.prototype.cancel = function () {
            this.mcaTitle = '';
            this.rankTitle = '';
            this.headers = [];
            this.$modalInstance.dismiss('cancel');
        };
        McaEditorCtrl.prototype.toggleItemDetails = function (index) {
            this.showItem = this.showItem == index ? -1 : index;
        };
        McaEditorCtrl.$inject = [
            '$scope',
            '$modalInstance',
            'layerService',
            '$translate',
            'messageBusService',
            'mca'
        ];
        return McaEditorCtrl;
    }());
    Mca.McaEditorCtrl = McaEditorCtrl;
})(Mca || (Mca = {}));
//# sourceMappingURL=McaEditorCtrl.js.map
var Mobile;
(function (Mobile) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Mobile.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Mobile.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    Mobile.myModule.directive('mobile', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Mobile/Mobile.tpl.html',
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: false,
                transclude: false,
                controller: Mobile.MobileCtrl
            };
        }
    ]);
})(Mobile || (Mobile = {}));
//# sourceMappingURL=Mobile.js.map
var Mobile;
(function (Mobile) {
    var MobileCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function MobileCtrl($scope, $layerService, $messageBus, localStorageService, geoService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.localStorageService = localStorageService;
            this.geoService = geoService;
            $scope.vm = this;
            this.$messageBus.subscribe('project', function (a, p) {
                if (a === 'loaded') {
                    _this.availableLayers = [];
                    p.groups.forEach((function (g) {
                        g.layers.forEach(function (l) {
                            if (l.tags && l.tags.indexOf('mobile') >= 0)
                                _this.availableLayers.push(l);
                        });
                    }));
                    // find mobile layer
                    console.log('available layers');
                    console.log(_this.availableLayers);
                }
            });
            $messageBus.subscribe("geo", function (action, loc) {
                switch (action) {
                    case "pos":
                        var f = new csComp.Services.Feature();
                        //f.layerId = layer.id;
                        f.geometry = {
                            type: 'Point', coordinates: []
                        };
                        f.geometry.coordinates = [loc.coords.longitude, loc.coords.latitude];
                        f.properties = { "Name": "test" };
                        //layer.data.features.push(f);
                        //this.$layerService.initFeature(f, layer);
                        _this.$layerService.activeMapRenderer.addFeature(f);
                        _this.$layerService.saveFeature(f);
                        break;
                }
            });
            this.geoService.start({});
        }
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        MobileCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService', 'localStorageService', 'geoService'
        ];
        return MobileCtrl;
    }());
    Mobile.MobileCtrl = MobileCtrl;
})(Mobile || (Mobile = {}));
//# sourceMappingURL=MobileCtrl.js.map
var Navigate;
(function (Navigate) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Navigate.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Navigate.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    Navigate.myModule.directive('navigate', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Navigate/Navigate.tpl.html',
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: false,
                transclude: false,
                controller: Navigate.NavigateCtrl
            };
        }
    ]).directive('bsPopover', function () {
        return function (scope, element, attrs) {
            element.find("a[rel=popover]").popover({ placement: 'right', html: 'true' });
        };
    });
})(Navigate || (Navigate = {}));
//# sourceMappingURL=Navigate.js.map
var Navigate;
(function (Navigate) {
    var RecentFeature = (function () {
        function RecentFeature() {
        }
        return RecentFeature;
    }());
    Navigate.RecentFeature = RecentFeature;
    var NavigateCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function NavigateCtrl($scope, $layerService, $messageBus, localStorageService, $dashboardService, geoService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.localStorageService = localStorageService;
            this.$dashboardService = $dashboardService;
            this.geoService = geoService;
            this.RecentLayers = [];
            this.mobileLayers = [];
            this.RecentFeatures = [];
            this.lastPost = { longitude: 0, latitude: 0 };
            this.searchResults = [];
            $scope.vm = this;
            this.$messageBus.subscribe('project', function (a, p) {
                if (a === 'loaded') {
                    _this.createSearchResultLayer();
                    _this.initRecentLayers();
                    _this.initRecentFeatures();
                    if (_this.$layerService.isMobile)
                        _this.initMobileLayers(p);
                }
            });
            this.$messageBus.subscribe('search', function (title, search) {
                _this.searchResults = [];
                switch (title) {
                    case 'update':
                        _this.doSearch(search.query);
                        break;
                    case 'reset':
                        _this.clearSearchLayer();
                        break;
                }
            });
        }
        /** Create a new layer for the search results. Also create a group, if necessary, and a feature type for the search results. */
        NavigateCtrl.prototype.createSearchResultLayer = function () {
            var searchResultId = '_search';
            var searchResultGroupId = '_hidden';
            if (this.$layerService.findLayer(searchResultId))
                return;
            this.searchResultGroup = this.$layerService.findGroupById(searchResultGroupId);
            if (!this.searchResultGroup) {
                this.searchResultGroup = new csComp.Services.ProjectGroup();
                this.searchResultGroup.title = searchResultGroupId;
                this.$layerService.project.groups.push(this.searchResultGroup);
                this.$layerService.initGroup(this.searchResultGroup);
                this.searchResultLayer = new csComp.Services.ProjectLayer();
                this.searchResultLayer.title = searchResultId;
                this.searchResultLayer.fitToMap = true;
                this.searchResultLayer.data = { features: [] };
                this.$layerService.initLayer(this.searchResultGroup, this.searchResultLayer);
                this.searchResultGroup.layers.push(this.searchResultLayer);
                var ft = {};
                ft.id = searchResultId;
                ft.style = {
                    drawingMode: 'Point',
                    fillColor: '#00f',
                    opacity: 0.8,
                    //iconUri: 'bower_components/csweb/dist-bower/images/large-marker.png',
                    innerTextProperty: 'searchIndex',
                    innerTextSize: 24,
                    marker: 'pin'
                };
                this.$layerService.initFeatureType(ft, null);
                this.$layerService._featureTypes[(this.$layerService.project.url + "#" + ft.id)] = ft;
            }
        };
        /** Remove the search results from the map. */
        NavigateCtrl.prototype.clearSearchLayer = function () {
            var _this = this;
            if (this.searchResultLayer && this.searchResultLayer.data && this.searchResultLayer.data) {
                this.searchResultLayer.data.features.forEach(function (f) {
                    _this.$layerService.activeMapRenderer.removeFeature(f);
                });
                this.searchResultLayer.data.features.length = 0;
            }
        };
        /**
         * Update the displayed search results on the map, basically creating a feature from each search result (that has a
         * location and isn't a feature already).
         */
        NavigateCtrl.prototype.updateSearchLayer = function () {
            var _this = this;
            // Clear layer
            // if (this.searchResultLayer.group) csComp.Services.GeojsonRenderer.remove(this.$layerService, this.searchResultLayer);
            this.clearSearchLayer();
            // Add results to the map
            var mark = 'A';
            var index = 0;
            this.searchResults.forEach(function (sr) {
                sr.searchIndex = mark;
                // if (sr.feature) return; // Is already on the map, so we don't need to add it.
                var feature = new csComp.Services.Feature();
                if (sr.feature && sr.feature.geometry) {
                    switch (sr.feature.geometry.type.toLowerCase()) {
                        case 'point':
                            feature.geometry = sr.feature.geometry;
                            break;
                        default:
                            feature.geometry = csComp.Helpers.GeoExtensions.getCentroid(sr.feature.geometry.coordinates);
                            break;
                    }
                }
                else {
                    feature.geometry = sr.location;
                }
                // feature.featureTypeName = '_search';
                feature.layer = _this.searchResultLayer;
                feature.layerId = _this.searchResultLayer.id;
                feature.index = index++;
                feature.id = csComp.Helpers.getGuid();
                feature.properties = {
                    Name: sr.title,
                    featureTypeId: '_search',
                    searchIndex: mark,
                };
                feature.fType = _this.$layerService.getFeatureType(feature);
                _this.$layerService.calculateFeatureStyle(feature);
                _this.searchResultLayer.data.features.push(feature);
                // this.$layerService.initFeature(feature, this.searchResultLayer);
                mark = csComp.Helpers.nextChar(mark);
            });
            csComp.Services.GeojsonRenderer.render(this.$layerService, this.searchResultLayer, this.$layerService.activeMapRenderer);
            //this.fitMap(this.searchResultLayer);
        };
        /** Fit the search results, if any, to the map. */
        NavigateCtrl.prototype.fitMap = function (layer) {
            if (this.searchResults.length === 0)
                return;
            var bounds = {
                xMin: NaN,
                xMax: NaN,
                yMin: NaN,
                yMax: NaN,
            };
            var bbox = {};
            layer.data.features.forEach(function (f) {
                var b = f.geometry.coordinates;
                bounds.xMin = bounds.xMin < b[0] ? bounds.xMin : b[0];
                bounds.xMax = bounds.xMax > b[0] ? bounds.xMax : b[0];
                bounds.yMin = bounds.yMin < b[1] ? bounds.yMin : b[1];
                bounds.yMax = bounds.yMax > b[1] ? bounds.yMax : b[1];
            });
            bbox.southWest = [bounds.yMin, bounds.xMin];
            bbox.northEast = [bounds.yMax, bounds.xMax];
            // var b = csComp.Helpers.GeoExtensions.getBoundingBox(layer.data);
            if (this.searchResults.length === 1 && this.searchResults[0].location.type.toLowerCase() === 'point') {
                this.$messageBus.publish('map', 'setzoom', { loc: bbox.southWest, zoom: 16 });
            }
            else {
                this.$messageBus.publish('map', 'setextent', bbox);
            }
        };
        NavigateCtrl.prototype.selectSearchResult = function (item) {
            if (item.click)
                item.click(item);
        };
        NavigateCtrl.prototype.doSearch = function (search) {
            var _this = this;
            this.$layerService.actionServices.forEach(function (as) {
                if (!as.search)
                    return;
                as.search({ query: search, results: _this.searchResults }, function (error, result) {
                    _this.searchResults = _this.searchResults.filter(function (sr) { return sr.service !== as.id; });
                    _this.searchResults = _this.searchResults.concat(result).sort(function (a, b) { return ((b.score - a.score) || -1); });
                    _this.updateSearchLayer();
                    if (_this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest') {
                        _this.$scope.$apply();
                    }
                });
            });
        };
        NavigateCtrl.prototype.leave = function (l) {
            if (this.mobileLayer && this.MyFeature) {
                this.$layerService.removeFeature(this.MyFeature, true);
                this.$layerService.activeMapRenderer.removeFeature(this.MyFeature);
                //this.$layerService.saveFeature(this.MyFeature);
                this.MyFeature = null;
            }
            this.mobileLayer = null;
        };
        NavigateCtrl.prototype.join = function (l) {
            var _this = this;
            this.localStorageService.set('username', this.UserName);
            async.series([function (cb) {
                    if (!l.enabled) {
                        _this.$layerService.addLayer(l, function () {
                            cb();
                        });
                    }
                    else {
                        cb();
                    }
                }, function (cb) {
                    _this.mobileLayer = l;
                    var f = new csComp.Services.Feature();
                    f.layerId = _this.mobileLayer.id;
                    f.geometry = {
                        type: 'Point', coordinates: []
                    };
                    // todo disable
                    f.geometry.coordinates = [_this.lastPost.longitude, _this.lastPost.latitude]; //[0, 0]; //loc.coords.longitude, loc.coords.latitude];
                    f.id = _this.UserName;
                    f.properties = { 'Name': _this.UserName };
                    //layer.data.features.push(f);
                    _this.$layerService.initFeature(f, _this.mobileLayer);
                    _this.$layerService.activeMapRenderer.addFeature(f);
                    _this.$layerService.saveFeature(f);
                    _this.MyFeature = f;
                }]);
        };
        NavigateCtrl.prototype.initMobileLayers = function (p) {
            var _this = this;
            this.UserName = this.localStorageService.get('username');
            if (!this.UserName)
                this.UserName = 'mobile user';
            this.mobileLayers = [];
            p.groups.forEach((function (g) {
                g.layers.forEach(function (l) {
                    if (l.tags && l.tags.indexOf('mobile') >= 0)
                        _this.mobileLayers.push(l);
                });
            }));
            if (this.$layerService.isMobile) {
                this.$messageBus.subscribe('geo', function (action, loc) {
                    switch (action) {
                        case 'pos':
                            if (_this.mobileLayer && _this.MyFeature) {
                                _this.lastPost = loc.coords;
                                _this.MyFeature.geometry.coordinates = [loc.coords.longitude, loc.coords.latitude];
                                _this.$layerService.activeMapRenderer.updateFeature(_this.MyFeature);
                                _this.$layerService.saveFeature(_this.MyFeature);
                            }
                            break;
                    }
                });
                this.geoService.start({});
            }
        };
        NavigateCtrl.prototype.updateRecentFeaturesList = function () {
            var _this = this;
            setTimeout(function () {
                var ids = _this.localStorageService.get('recentfeatures');
                if (ids) {
                    _this.RecentFeatures = ids;
                    _this.RecentFeatures.forEach(function (rf) {
                        var l = _this.$layerService.findLayer(rf.layerId);
                        if (l && l.enabled) {
                            rf.feature = _this.$layerService.findFeature(l, rf.id);
                        }
                    });
                }
            }, 0);
        };
        NavigateCtrl.prototype.selectFeature = function (feature) {
            this.$layerService.selectFeature(feature, false, true);
        };
        NavigateCtrl.prototype.initRecentFeatures = function () {
            var _this = this;
            this.updateRecentFeaturesList();
            this.$messageBus.subscribe('feature', function (a, feature) {
                if (a === 'onFeatureSelect') {
                    _this.RecentFeatures = _this.RecentFeatures.filter(function (f) { return f.id !== feature.id; });
                    var rf = { id: feature.id, name: csComp.Helpers.getFeatureTitle(feature), layerId: feature.layerId, feature: feature };
                    _this.RecentFeatures.splice(0, 0, rf);
                    if (_this.RecentFeatures.length > 5)
                        _this.RecentFeatures.pop();
                    var save = [];
                    _this.RecentFeatures.forEach(function (f) { return save.push({ id: f.id, name: f.name, layerId: f.layerId }); });
                    _this.localStorageService.set('recentfeatures', save);
                    if (_this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest') {
                        _this.$scope.$root.$apply();
                    }
                }
            });
        };
        NavigateCtrl.prototype.toggleLayer = function (layer) {
            this.$layerService.toggleLayer(layer);
        };
        NavigateCtrl.prototype.initRecentLayers = function () {
            var _this = this;
            var ids = this.localStorageService.get('recentlayers');
            if (ids)
                ids.forEach(function (id) {
                    var l = _this.$layerService.findLayer(id);
                    if (l)
                        _this.RecentLayers.push(l);
                });
            this.$messageBus.subscribe('layer', function (a, layer) {
                if (a === 'activated') {
                    _this.RecentLayers = _this.RecentLayers.filter(function (f) { return f.id !== layer.id; });
                    _this.RecentLayers.splice(0, 0, layer);
                    if (_this.RecentLayers.length > 5)
                        _this.RecentLayers.pop();
                    ids = [];
                    _this.RecentLayers.forEach(function (l) { return ids.push(l.id); });
                    _this.localStorageService.set('recentlayers', ids);
                    if (_this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest') {
                        _this.$scope.$apply();
                    }
                }
                _this.updateRecentFeaturesList();
            });
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        NavigateCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            'localStorageService',
            'dashboardService',
            'geoService'
        ];
        return NavigateCtrl;
    }());
    Navigate.NavigateCtrl = NavigateCtrl;
})(Navigate || (Navigate = {}));
//# sourceMappingURL=NavigateCtrl.js.map
var Search;
(function (Search) {
    var NavigateSteps = (function () {
        function NavigateSteps() {
        }
        return NavigateSteps;
    }());
    Search.NavigateSteps = NavigateSteps;
    var NavigateState = (function () {
        function NavigateState() {
        }
        return NavigateState;
    }());
    Search.NavigateState = NavigateState;
})(Search || (Search = {}));
//# sourceMappingURL=SearchClasses.js.map
var OfflineSearch;
(function (OfflineSearch) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        OfflineSearch.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        OfflineSearch.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    OfflineSearch.myModule.directive('offlineSearch', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/OfflineSearch/OfflineSearch.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: OfflineSearch.OfflineSearchCtrl
            };
        }
    ]);
})(OfflineSearch || (OfflineSearch = {}));
//# sourceMappingURL=OfflineSearch.js.map
var OfflineSearch;
(function (OfflineSearch) {
    var Layer = (function () {
        function Layer(groupTitle, index, id, title, path, type) {
            this.groupTitle = groupTitle;
            this.index = index;
            this.id = id;
            this.title = title;
            this.path = path;
            this.type = type;
            /**
             * Names of all the features.
             * @type {string[]}
             */
            this.featureNames = [];
        }
        return Layer;
    }());
    OfflineSearch.Layer = Layer;
    /**
     * An index entry that contains a search result.
     */
    var Entry = (function () {
        function Entry(layerIndexOrArray, featureIndex, propertyIndex) {
            this.v = Array(2);
            if (typeof layerIndexOrArray === 'number') {
                this.v[0] = layerIndexOrArray;
                this.v[1] = featureIndex;
            }
            else {
                this.v = layerIndexOrArray;
            }
        }
        Object.defineProperty(Entry.prototype, "layerIndex", {
            get: function () { return this.v[0]; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entry.prototype, "featureIndex", {
            get: function () { return this.v[1]; },
            enumerable: true,
            configurable: true
        });
        /**
         * This function is called when serializing the Entry object to JSON, which is
         * much less verbose than the default JSON. In the constructor, I've used a
         * Union type to deserialize it again.
         */
        Entry.prototype.toJSON = function () {
            return this.v;
        };
        return Entry;
    }());
    OfflineSearch.Entry = Entry;
    var KeywordIndex = (function () {
        function KeywordIndex() {
        }
        return KeywordIndex;
    }());
    OfflineSearch.KeywordIndex = KeywordIndex;
    var OfflineSearchResult = (function () {
        function OfflineSearchResult(project, options) {
            this.project = project;
            this.options = options;
            this.layers = [];
            this.keywordIndex = {};
        }
        return OfflineSearchResult;
    }());
    OfflineSearch.OfflineSearchResult = OfflineSearchResult;
})(OfflineSearch || (OfflineSearch = {}));
//# sourceMappingURL=OfflineSearchClasses.js.map
var OfflineSearch;
(function (OfflineSearch) {
    var OfflineSearchResultViewModel = (function () {
        function OfflineSearchResultViewModel(title, layerTitle, groupTitle, entry) {
            this.title = title;
            this.layerTitle = layerTitle;
            this.groupTitle = groupTitle;
            this.entry = entry;
            this.firstInGroup = false;
        }
        OfflineSearchResultViewModel.prototype.toString = function () {
            return this.title;
        };
        Object.defineProperty(OfflineSearchResultViewModel.prototype, "fullTitle", {
            get: function () {
                return this.groupTitle + ' >> ' + this.layerTitle + ' >> ' + this.title;
            },
            enumerable: true,
            configurable: true
        });
        return OfflineSearchResultViewModel;
    }());
    OfflineSearch.OfflineSearchResultViewModel = OfflineSearchResultViewModel;
    var OfflineSearchCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function OfflineSearchCtrl($scope, $http, $layerService, $mapService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBus = $messageBus;
            this.isReady = false;
            $scope.vm = this;
            $messageBus.subscribe('project', function (title) {
                switch (title) {
                    case 'loaded':
                        var offlineSearchResultUrl = $layerService.projectUrl.url.replace('project.json', 'offline_search_result.json');
                        _this.loadSearchResults(offlineSearchResultUrl);
                        break;
                }
            });
            $messageBus.subscribe('language', function (title, language) {
                switch (title) {
                    case 'newLanguage':
                        // TODO switch language!
                        break;
                }
            });
        }
        /**
         * Load the offline search results (json file).
         */
        OfflineSearchCtrl.prototype.loadSearchResults = function (url) {
            var _this = this;
            this.$http.get(url)
                .success(function (offlineSearchResult) {
                _this.offlineSearchResult = offlineSearchResult;
                var kwi = offlineSearchResult.keywordIndex;
                var keywordIndex = {};
                for (var key in kwi) {
                    if (!kwi.hasOwnProperty(key))
                        continue;
                    kwi[key].forEach(function (entry) {
                        if (!keywordIndex.hasOwnProperty(key))
                            keywordIndex[key] = [];
                        keywordIndex[key].push(new OfflineSearch.Entry(entry));
                    });
                }
                _this.offlineSearchResult.keywordIndex = keywordIndex;
                _this.isReady = true;
            })
                .error(function () { console.log("OfflineSearch: error with $http "); });
        };
        /**
         * Get the locations based on the entered text.
         */
        OfflineSearchCtrl.prototype.getLocation = function (text, resultCount) {
            if (resultCount === void 0) { resultCount = 15; }
            if (!this.isReady || text === null || text.length < 3)
                return [];
            var searchWords = text.toLowerCase().split(' ');
            // test if last word in text might be a (part of) a stopword, if so remove it
            var lastSearchTerm = searchWords[searchWords.length - 1];
            var possibleStopWords = this.offlineSearchResult.options.stopWords.filter(function (stopword) { return stopword.indexOf(lastSearchTerm) > -1; });
            if (possibleStopWords.length > 0) {
                searchWords.splice(searchWords.length - 1, 1);
            }
            // remove all exact stopwords
            this.offlineSearchResult.options.stopWords.forEach(function (stopWord) {
                while (searchWords.indexOf(stopWord) > -1) {
                    searchWords.splice(searchWords.indexOf(stopWord), 1);
                }
            });
            var totResults;
            for (var j in searchWords) {
                var result = this.getKeywordHits(searchWords[j]);
                totResults = !totResults
                    ? result
                    : this.mergeResults(totResults, result);
            }
            var searchResults = [];
            var layers = this.offlineSearchResult.layers;
            var count = resultCount;
            var resultIndex = 0;
            while (count > 0 && resultIndex < totResults.length) {
                var r = totResults[resultIndex++];
                var subCount = Math.min(count, r.entries.length);
                for (var i = 0; i < subCount; i++) {
                    var entry = r.entries[i];
                    var layer = layers[entry.layerIndex];
                    count--;
                    searchResults.push(new OfflineSearchResultViewModel(layer.featureNames[entry.featureIndex], layer.title, layer.groupTitle, entry));
                }
            }
            // Group search results by groupTitle | layerTitle
            var groups = {};
            searchResults.forEach(function (sr) {
                var group = sr.groupTitle + ' >> ' + sr.layerTitle;
                if (!groups.hasOwnProperty(group))
                    groups[group] = [];
                groups[group].push(sr);
            });
            searchResults = [];
            for (var key in groups) {
                if (!groups.hasOwnProperty(key))
                    continue;
                var firstInGroup = true;
                groups[key].forEach(function (sr) {
                    sr.firstInGroup = firstInGroup;
                    searchResults.push(sr);
                    firstInGroup = false;
                });
            }
            return searchResults;
        };
        /**
         * Merge the resuls of two keyword lookups by checking whether different entries refer
         * to the same layer and feature.
         * @result1 {ILookupResult[]}
         * @result2 {ILookupResult[]}
         */
        OfflineSearchCtrl.prototype.mergeResults = function (result1, result2) {
            var r = [];
            result1.forEach(function (r1) {
                result2.forEach(function (r2) {
                    r1.entries.forEach(function (entry1) {
                        r2.entries.forEach(function (entry2) {
                            if (entry1.layerIndex === entry2.layerIndex && entry1.featureIndex === entry2.featureIndex)
                                r.push({ score: r1.score * r2.score, key: r1.key + ' ' + r2.key, entries: [entry1] });
                        });
                    });
                });
            });
            r = r.sort(function (a, b) { return b.score - a.score; });
            return r;
        };
        /**
         * Do a fuzzy keyword comparison between the entered text and the list of keywords,
         * and return a subset.
         * @text: {string}
         */
        OfflineSearchCtrl.prototype.getKeywordHits = function (text) {
            var results = [];
            var keywordIndex = this.offlineSearchResult.keywordIndex;
            var keywords = Object.getOwnPropertyNames(keywordIndex);
            keywords.forEach(function (key) {
                var score = key.score(text, null);
                if (score < 0.5)
                    return;
                results.push({ score: score, key: key, entries: keywordIndex[key] });
            });
            results = results.sort(function (a, b) { return b.score - a.score; });
            return results;
        };
        /**
         * When an item is selected, optionally open the layer and jump to the selected feature.
         */
        OfflineSearchCtrl.prototype.onSelect = function (selectedItem) {
            var _this = this;
            var layerIndex = selectedItem.entry.layerIndex;
            var layer = this.offlineSearchResult.layers[layerIndex];
            var projectLayer = this.$layerService.findLayer(layer.id);
            console.log(selectedItem);
            if (!projectLayer)
                return;
            if (projectLayer.enabled) {
                this.selectFeature(layer.id, selectedItem.entry.featureIndex);
                return;
            }
            else {
                var handle = this.$messageBus.subscribe('layer', function (title, layer) {
                    if (title !== 'activated' || projectLayer.url !== layer.url)
                        return;
                    _this.selectFeature(layer.id, selectedItem.entry.featureIndex);
                    _this.$messageBus.unsubscribe(handle);
                });
                this.$layerService.addLayer(projectLayer);
            }
            var group = $("#layergroup_" + projectLayer.groupId);
            group.collapse("show");
        };
        OfflineSearchCtrl.prototype.selectFeature = function (layerId, featureIndex) {
            var feature = this.$layerService.findFeatureByIndex(layerId, featureIndex);
            if (feature == null)
                return;
            this.$mapService.zoomTo(feature);
            this.$layerService.selectFeature(feature);
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        OfflineSearchCtrl.$inject = [
            '$scope',
            '$http',
            'layerService',
            'mapService',
            'messageBusService'
        ];
        return OfflineSearchCtrl;
    }());
    OfflineSearch.OfflineSearchCtrl = OfflineSearchCtrl;
})(OfflineSearch || (OfflineSearch = {}));
//# sourceMappingURL=OfflineSearchCtrl.js.map
var ProfileHeader;
(function (ProfileHeader) {
    var ProfileHeaderCtrl = (function () {
        function ProfileHeaderCtrl($scope, $localStorageService, $layerService, $mapService, $messageBus, profileService) {
            var _this = this;
            this.$scope = $scope;
            this.$localStorageService = $localStorageService;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBus = $messageBus;
            this.profileService = profileService;
            $scope.vm = this;
            console.log('init profile service');
            $messageBus.subscribe('project', function (action, value) {
                if (_this.$layerService.project) {
                    _this.$scope.enabled = _this.$layerService.project.profile.authenticationMethod != csComp.Services.authMethods.none;
                    console.log(_this.$layerService.project.profile.authenticationMethod);
                    switch (_this.$layerService.project.profile.authenticationMethod) {
                    }
                }
            });
        }
        ProfileHeaderCtrl.prototype.startLogin = function () {
            this.profileService.startLogin();
        };
        ProfileHeaderCtrl.prototype.logout = function () {
            this.profileService.logoutUser();
        };
        ProfileHeaderCtrl.$inject = [
            '$scope',
            'localStorageService',
            'layerService',
            'mapService',
            'messageBusService',
            'profileService'
        ];
        return ProfileHeaderCtrl;
    }());
    ProfileHeader.ProfileHeaderCtrl = ProfileHeaderCtrl;
    /**
* Config
*/
    var moduleName = 'csComp';
    try {
        ProfileHeader.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ProfileHeader.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to set the expert mode, so we can determine what the user should see (degree of difficulty).
      * The expert mode can either be set manually, e.g. using this directive, or by setting the expertMode property in the
      * project.json file. In neither are set, we assume that we are dealing with an expert, so all features should be enabled.
      *
      * Precedence:
      * - when a declaration is absent, assume Expert.
      * - when the mode is set in local storage, take that value.
      * - when the mode is set in the project.json file, take that value.
      *
      * As we want the expertMode to be always available, we have added it to the MapService service.
      */
    ProfileHeader.myModule
        .directive('profileHeader', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Profile/ProfileHeader.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                //link: function (scope, element, attrs) {
                //     // Since we are wrapping the rating directive in this directive, I couldn't use transclude,
                //     // so I copy the existing attributes manually.
                //     var attributeString = '';
                //     for (var key in attrs) {
                //         if (key.substr(0, 1) !== '$' && attrs.hasOwnProperty(key)) attributeString += key + '="' + attrs[key] + '" ';
                //     }
                //     var html = '<rating ng-model="expertMode" '
                //         + attributeString
                //         + 'tooltip-html-unsafe="{{\'EXPERTMODE.EXPLANATION\' | translate}}" tooltip-placement="bottom" tooltip-trigger="mouseenter" tooltip-append-to-body="false"'
                //         + 'max="3"></rating>';
                //     var e = $compile(html)(scope);
                //     element.replaceWith(e);
                // },
                replace: true,
                transclude: true,
                controller: ProfileHeaderCtrl
            };
        }
    ]);
})(ProfileHeader || (ProfileHeader = {}));
//# sourceMappingURL=ProfileHeaderCtrl.js.map
var ProfileTab;
(function (ProfileTab) {
    var ProfileTabCtrl = (function () {
        function ProfileTabCtrl($scope, $localStorageService, $layerService, $mapService, $messageBus, profileService) {
            var _this = this;
            this.$scope = $scope;
            this.$localStorageService = $localStorageService;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBus = $messageBus;
            this.profileService = profileService;
            $scope.vm = this;
            $messageBus.subscribe('project', function (action, value) {
                if (_this.$layerService.project) {
                    _this.$scope.enabled = _this.$layerService.project.profile.authenticationMethod != csComp.Services.authMethods.none;
                    console.log(_this.$layerService.project.profile.authenticationMethod);
                    switch (_this.$layerService.project.profile.authenticationMethod) {
                    }
                }
            });
        }
        ProfileTabCtrl.prototype.startLogin = function () {
            this.profileService.startLogin();
        };
        ProfileTabCtrl.prototype.validateUser = function () {
            this.profileService.validateUser(this.userName, this.userPassword);
            this.userPassword = "";
        };
        ProfileTabCtrl.prototype.logout = function () {
            this.profileService.logoutUser();
        };
        ProfileTabCtrl.$inject = [
            '$scope',
            'localStorageService',
            'layerService',
            'mapService',
            'messageBusService',
            'profileService'
        ];
        return ProfileTabCtrl;
    }());
    ProfileTab.ProfileTabCtrl = ProfileTabCtrl;
    /**
* Config
*/
    var moduleName = 'csComp';
    try {
        ProfileTab.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ProfileTab.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to set the expert mode, so we can determine what the user should see (degree of difficulty).
      * The expert mode can either be set manually, e.g. using this directive, or by setting the expertMode property in the
      * project.json file. In neither are set, we assume that we are dealing with an expert, so all features should be enabled.
      *
      * Precedence:
      * - when a declaration is absent, assume Expert.
      * - when the mode is set in local storage, take that value.
      * - when the mode is set in the project.json file, take that value.
      *
      * As we want the expertMode to be always available, we have added it to the MapService service.
      */
    ProfileTab.myModule
        .directive('profiletab', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Profile/ProfileTab.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                //link: function (scope, element, attrs) {
                //     // Since we are wrapping the rating directive in this directive, I couldn't use transclude,
                //     // so I copy the existing attributes manually.
                //     var attributeString = '';
                //     for (var key in attrs) {
                //         if (key.substr(0, 1) !== '$' && attrs.hasOwnProperty(key)) attributeString += key + '="' + attrs[key] + '" ';
                //     }
                //     var html = '<rating ng-model="expertMode" '
                //         + attributeString
                //         + 'tooltip-html-unsafe="{{\'EXPERTMODE.EXPLANATION\' | translate}}" tooltip-placement="bottom" tooltip-trigger="mouseenter" tooltip-append-to-body="false"'
                //         + 'max="3"></rating>';
                //     var e = $compile(html)(scope);
                //     element.replaceWith(e);
                // },
                replace: true,
                transclude: true,
                controller: ProfileTabCtrl
            };
        }
    ]);
})(ProfileTab || (ProfileTab = {}));
//# sourceMappingURL=ProfileTabCtrl.js.map
var ProjectHeaderSelection;
(function (ProjectHeaderSelection) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        ProjectHeaderSelection.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ProjectHeaderSelection.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    ProjectHeaderSelection.myModule.directive('projectHeaderSelection', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/ProjectSelection/ProjectHeaderSelection.tpl.html',
                link: function (scope, element, attrs) {
                },
                replace: true,
                transclude: true,
                controller: ProjectHeaderSelection.ProjectHeaderSelectionCtrl
            };
        }
    ]);
})(ProjectHeaderSelection || (ProjectHeaderSelection = {}));
//# sourceMappingURL=ProjectHeaderSelection.js.map
var ProjectHeaderSelection;
(function (ProjectHeaderSelection) {
    var ProjectHeaderSelectionCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function ProjectHeaderSelectionCtrl($scope, $layerService, $dashboardService, $mapService, $messageBusService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$dashboardService = $dashboardService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            $scope.vm = this;
        }
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        ProjectHeaderSelectionCtrl.$inject = [
            '$scope',
            'layerService',
            'dashboardService',
            'mapService',
            'messageBusService'
        ];
        return ProjectHeaderSelectionCtrl;
    }());
    ProjectHeaderSelection.ProjectHeaderSelectionCtrl = ProjectHeaderSelectionCtrl;
})(ProjectHeaderSelection || (ProjectHeaderSelection = {}));
//# sourceMappingURL=ProjectHeaderSelectionCtrl.js.map
var ProjectSettings;
(function (ProjectSettings) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        ProjectSettings.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ProjectSettings.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    ProjectSettings.myModule.directive('projectSettings', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/ProjectSettings/ProjectSettings.tpl.html',
                // compile: el => {    // I need to explicitly compile it in order to use interpolation like {{xxx}}
                //     var fn = $compile(el);
                //     return scope => {
                //         fn(scope);
                //     };
                // },
                replace: true,
                //transclude: true,    // Add elements and attributes to the template
                controller: ProjectSettings.ProjectSettingsCtrl
            };
        }
    ]);
})(ProjectSettings || (ProjectSettings = {}));
//# sourceMappingURL=ProjectSettings.js.map
var ProjectSettings;
(function (ProjectSettings) {
    var ProjectSettingsCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function ProjectSettingsCtrl($scope, $timeout, $layerService, dashboardService, mapService, messageBus, $localStorageService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.dashboardService = dashboardService;
            this.mapService = mapService;
            this.messageBus = messageBus;
            this.$localStorageService = $localStorageService;
            $scope.vm = this;
        }
        ProjectSettingsCtrl.prototype.toggleTouchMode = function () {
            this.dashboardService.touchMode = !this.dashboardService.touchMode;
            this.$localStorageService.set('touchmode', this.dashboardService.touchMode);
        };
        ProjectSettingsCtrl.prototype.toggleRenderer = function () {
            if (this.$layerService.activeMapRenderer.title === 'cesium') {
                this.$layerService.selectRenderer('leaflet');
            }
            else {
                this.$layerService.selectRenderer('cesium');
            }
        };
        ProjectSettingsCtrl.prototype.toggleShowLocation = function () {
            this.messageBus.publish('map', 'showLocation');
        };
        ProjectSettingsCtrl.prototype.toggleAdminMode = function () {
            if (this.mapService.expertMode !== csComp.Services.Expertise.Admin) {
                this.mapService.expertMode = csComp.Services.Expertise.Admin;
                this.messageBus.publish('expertMode', 'newExpertise', csComp.Services.Expertise.Admin);
            }
            else {
                this.mapService.expertMode = csComp.Services.Expertise.Expert;
                this.messageBus.publish('expertMode', 'newExpertise', csComp.Services.Expertise.Expert);
            }
        };
        ProjectSettingsCtrl.prototype.saveSettings = function () {
            var _this = this;
            this.$timeout(function () {
                var data = _this.$layerService.project.serialize();
                //console.log(data);
                console.log('Save settings: ');
                csComp.Helpers.saveData(data, 'project', 'json');
            }, 0);
        };
        ProjectSettingsCtrl.prototype.updateProject = function () {
            this.$layerService.saveProject();
        };
        ProjectSettingsCtrl.prototype.updateProjectReady = function (data) {
            if (data.success().statusText !== 'OK') {
                console.error('Error update project.json: ' + JSON.stringify(data));
            }
            else {
                console.log('Project.json updated succesfully!');
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        ProjectSettingsCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'dashboardService',
            'mapService',
            'messageBusService',
            'localStorageService'
        ];
        return ProjectSettingsCtrl;
    }());
    ProjectSettings.ProjectSettingsCtrl = ProjectSettingsCtrl;
})(ProjectSettings || (ProjectSettings = {}));
//# sourceMappingURL=ProjectSettingsCtrl.js.map
var Helpers;
(function (Helpers) {
    var Resize;
    (function (Resize) {
        /**
         * Config
         */
        var moduleName = 'csComp';
        try {
            Resize.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Resize.myModule = angular.module(moduleName, []);
        }
        /**
          * Directive to resize an element by settings its width or height,
          * for example to make sure that the scrollbar appears.
          * Typical usage:
          * <div style="overflow-y: auto; overflow-x: hidden" resize resize-x="20" resize-y="250">...</div>
          * Load the directive in your module, e.g.
          * angular.module('myWebApp', ['csWeb.resize'])
          */
        Resize.myModule.directive('resize', ['$window',
            function ($window) {
                return {
                    terminal: false,
                    // E = elements, A=attributes and C=css classes. Can be compined, e.g. EAC
                    restrict: 'A',
                    // Name if optional. Text Binding (Prefix: @), One-way Binding (Prefix: &), Two-way Binding (Prefix: =)
                    scope: {
                        resizeX: '@',
                        resizeY: '@'
                    },
                    // Directives that want to modify the DOM typically use the link option.link takes a function with the following signature, function link(scope, element, attrs) { ... } where:
                    // * scope is an Angular scope object.
                    // * element is the jqLite wrapped element that this directive matches.
                    // * attrs is a hash object with key-value pairs of normalized attribute names and their corresponding attribute values.
                    link: function (scope, element, attrs) {
                        scope.onResizeFunction = function () {
                            // console.log(scope.resizeX + "-" + scope.resizeY);
                            if (scope.resizeX) {
                                var windowWidth = $window.innerWidth;
                                element.width((windowWidth - scope.resizeX) + 'px');
                            }
                            if (scope.resizeY) {
                                var windowHeight = $window.innerHeight;
                                element.height((windowHeight - scope.resizeY) + 'px');
                            }
                        };
                        // Call to the function when the page is first loaded
                        scope.onResizeFunction();
                        // Listen to the resize event.
                        angular.element($window).bind('resize', function () {
                            scope.onResizeFunction();
                            scope.$apply();
                        });
                    }
                };
            }
        ]);
        var inputresizerApp = angular.module('inputresizer', []);
        Resize.myModule.directive('expandTo', function () {
            return {
                restrict: 'A',
                link: function ($scope, $element, $attributes) {
                    var expandsize = $attributes['expandTo'] || '50px';
                    var original = $element.width();
                    $element.on('focus', function () {
                        $element.animate({
                            width: expandsize
                        }, 500, function () {
                            // Animation complete.
                        });
                    }).on('blur', function () {
                        $element.animate({
                            width: original + 'px'
                        }, 500, function () {
                            // Animation complete.
                        });
                    });
                }
            };
        });
    })(Resize = Helpers.Resize || (Helpers.Resize = {}));
})(Helpers || (Helpers = {}));
//# sourceMappingURL=Resize.js.map
var ShowModal;
(function (ShowModal) {
    /**
    * Config
    */
    var moduleName = 'csComp';
    try {
        ShowModal.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ShowModal.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to show a modal dialog, whose html is specified inside the main HTML code.
      * Typical usage: http://plnkr.co/edit/WJBp7A6M3RB1MLERDXSS?p=info
      * angular.module('myWebApp', ['csWeb.showModal'])
      */
    ShowModal.myModule.directive('showModal', [
        '$parse',
        function ($parse) {
            return {
                restrict: "A",
                link: function (scope, element, attrs) {
                    //Hide or show the modal
                    scope.showModalDialog = function (visible, elem) {
                        if (!elem)
                            elem = element;
                        var myElem = $(elem);
                        if (visible)
                            myElem.appendTo('body').modal("show");
                        else
                            myElem.modal("hide");
                    };
                    //Watch for changes to the modal-visible attribute
                    scope.$watch(attrs.showModal, function (newValue, oldValue) {
                        scope.showModalDialog(newValue, attrs.$$element);
                    });
                    //Update the visible value when the dialog is closed through UI actions (Ok, cancel, etc.)
                    $(element).bind("hide.bs.modal", function () {
                        $parse(attrs.showModal).assign(scope, false);
                        if (!scope.$$phase && !scope.$root.$$phase)
                            scope.$apply();
                    });
                }
            };
        }
    ]);
})(ShowModal || (ShowModal = {}));
//# sourceMappingURL=ShowModal.js.map
var StyleList;
(function (StyleList) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        StyleList.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        StyleList.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    StyleList.myModule
        .filter('reverse', function () {
        return function (items) {
            return items.slice().reverse();
        };
    })
        .directive('styleList', ['$window', '$compile', function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/StyleList/StyleList.tpl.html',
                //compile             : el          => {    // I need to explicitly compile it in order to use interpolation like {{xxx}}
                //    var fn                        = $compile(el);
                //    return scope                  => {
                //        fn(scope);
                //    };
                //},
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: true,
                transclude: true,
                controller: StyleList.StyleListCtrl
            };
        }
    ]);
})(StyleList || (StyleList = {}));
//# sourceMappingURL=StyleList.js.map
var StyleList;
(function (StyleList) {
    var StyleListCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function StyleListCtrl($scope, $timeout, $layerService, messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.messageBus = messageBus;
            $scope.vm = this;
            this.activeStyles = [];
            messageBus.subscribe('layer', function (title) {
                switch (title) {
                    case "activated":
                    case "deactivate":
                        // Update the legend when a layer is added or removed.
                        _this.initWizard();
                        break;
                }
            });
            messageBus.subscribe('updatelegend', function (title, gs) {
                if (title === 'updatedstyle') {
                    if (_this.selectedGroup) {
                        var g = _this.$layerService.findGroupById(_this.selectedGroup.id);
                        if (g.styles) {
                            _this.$timeout(function () {
                                _this.activeStyles = _.map(g.styles.filter(function (s) { return s.enabled; }), function (enabledStyle) { return enabledStyle.property; });
                            }, 0);
                        }
                    }
                }
            });
        }
        StyleListCtrl.prototype.selectGroup = function (group) {
            this.selectedGroup = group;
            if (!group._gui["showSections"]) {
                for (var s in group._gui["sections"])
                    this.selectSection(group._gui["sections"][s]);
            }
            else {
                setTimeout(function () {
                    $("#styles_sections").collapse('show');
                }, 100);
            }
        };
        StyleListCtrl.prototype.selectSection = function (section) {
            this.selectedSection = section;
            setTimeout(function () {
                $("#styles_properties").collapse('show'); //.attr('aria-expanded', 'true');
            }, 100);
        };
        StyleListCtrl.prototype.initWizard = function () {
            console.log('init wizard');
            this.selectedSection = null;
            this.selectedGroup = null;
            if (this.$layerService.project.groups && this.$layerService.project.groups.length > 0) {
                this.$layerService.project.groups.forEach(function (g) {
                    delete g._gui["sections"];
                    delete g._gui["showSections"];
                    if (g.layers) {
                        var resources = [];
                        var sections = {};
                        g.layers.forEach(function (l) {
                            if (l.enabled) {
                                if (l._gui["sections"]) {
                                    for (var s in l._gui["sections"]) {
                                        var section = l._gui["sections"][s];
                                        if (!sections.hasOwnProperty(s))
                                            sections[s] = new csComp.Services.Section();
                                        for (var label in section.properties) {
                                            if (!sections[s].properties.hasOwnProperty(label))
                                                sections[s].properties[label] = section.properties[label];
                                        }
                                        ;
                                    }
                                }
                            }
                        });
                        if (_.keys(sections).length > 0)
                            g._gui["sections"] = sections;
                        if (_.keys(sections).length > 1)
                            g._gui["showSections"] = true;
                    }
                });
                this.selectedGroup = this.$layerService.project.groups[0];
            }
        };
        StyleListCtrl.prototype.setStyle = function (g, property) {
            this.$layerService.setGroupStyle(g, property);
        };
        StyleListCtrl.prototype.getStyle = function (legend, le, key) {
            return {
                'float': 'left',
                'position': 'relative',
                'top': '10px',
                'background': "linear-gradient(to bottom, " + le.color + ", " + legend.legendEntries[legend.legendEntries.length - key - 2].color + ")"
            };
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        StyleListCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'messageBusService'
        ];
        return StyleListCtrl;
    }());
    StyleList.StyleListCtrl = StyleListCtrl;
})(StyleList || (StyleList = {}));
//# sourceMappingURL=StyleListCtrl.js.map
var Timeline;
(function (Timeline) {
    // The following class represents the provider
    var TimelineService = (function () {
        function TimelineService() {
            this.timelineOptions = {
                'width': '100%',
                'height': '100px',
                'editable': false,
                'layout': 'box'
            };
        }
        // Configuration function
        TimelineService.prototype.setTimelineOptions = function (options) {
            this.timelineOptions = options;
        };
        // Provider's factory function
        TimelineService.prototype.$get = function () {
            var _this = this;
            return {
                getTimelineOptions: function () { return _this.timelineOptions; },
                setTimelineOptions: function (options) { return _this.setTimelineOptions; }
            };
        };
        return TimelineService;
    }());
    /**
     * Config
     */
    var moduleName = 'csComp';
    try {
        Timeline.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Timeline.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      *
      * When turning of the event margins in app.ts (see below), also set the #focustimeContainer { bottom: 45px; }
      * $layerService.timelineOptions = {
      *     'width': '100%',
      *     "eventMargin": 0,
      *     "eventMarginAxis": 0,
      *     'editable': false,
      *     'layout': 'box'
      * };
      * @seealso: http://almende.github.io/chap-links-library/downloads.html
      */
    Timeline.myModule
        .provider('TimelineService', TimelineService)
        .directive('timeline', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Timeline/Timeline.tpl.html',
                replace: true,
                transclude: true,
                controller: Timeline.TimelineCtrl
            };
        }
    ]);
})(Timeline || (Timeline = {}));
//# sourceMappingURL=Timeline.js.map
var Timeline;
(function (Timeline) {
    var TimelineCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function TimelineCtrl($scope, $layerService, $mapService, $messageBusService, TimelineService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            this.TimelineService = TimelineService;
            this.locale = 'en-us';
            this.timelineGroups = new vis.DataSet();
            /** Holds the timeline items, is databound to the timeline. */
            this.timelineItems = new vis.DataSet();
            this.expanded = false;
            this.isPinned = true;
            this.expandButtonBottom = 52;
            this.items = new vis.DataSet();
            this.ids = [];
            this.setFocusContainerDebounce = _.debounce(function (data) {
                _this.updateFocusTimeContainer(data);
                //console.log(`Moved timeline and focuscontainer to ${data}`);
            }, 300, true);
            this.throttleTimeSpanUpdate = _.debounce(this.triggerTimeSpanUpdated, 1000);
            this.loadLocales();
            this.options = {
                'width': '100%',
                'editable': false,
                'margin': 0,
                'height': 54,
                'zoomMax': 172800000000,
                'zoomMin': 3600000
            };
            this.debounceUpdate = _.debounce(this.updateFeatures, 500);
            this.debounceSetItems = _.debounce(function (items) { _this.addItems(items); }, 500);
            $scope.vm = this;
            this.$messageBusService.subscribe('dashboard-main', function (s, data) {
                if (s === 'activated')
                    _this.updatePanelHeights();
            });
            this.$messageBusService.subscribe('project', function (s, data) {
                setTimeout(function () {
                    _this.$scope.timeline.setItems(_this.timelineItems);
                    _this.$scope.timeline.setGroups(_this.timelineGroups);
                    // set min/max zoom levels if available
                    if (_this.$layerService.project && _this.$layerService.project.timeLine !== null) {
                        if (!_.isUndefined(_this.$layerService.project.timeLine.zoomMax))
                            _this.$scope.timeline.options['zoomMax'] = _this.$layerService.project.timeLine.zoomMax;
                        if (!_.isUndefined(_this.$layerService.project.timeLine.zoomMin))
                            _this.$scope.timeline.options['zoomMin'] = _this.$layerService.project.timeLine.zoomMin;
                    }
                    _this.updateFocusTime();
                    _this.updateDragging();
                    _this.myTimer();
                    if (_this.$layerService.project.timeLine.isLive)
                        _this.goLive();
                }, 0);
            });
            this.initTimeline();
            this.$messageBusService.subscribe('timeline', function (s, data) { _this.update(s, data); });
            this.$messageBusService.subscribe('feature', function (s, feature) {
                if (s === 'onFeatureSelect' && feature) {
                    if (_this.ids.indexOf(feature.id) !== -1) {
                        _this.$scope.timeline.setSelection(feature.id);
                    }
                }
            });
            //$scope.focusDate = $layerService.project.timeLine.focusDate();
            // Options for the timeline
            this.$messageBusService.subscribe('language', function (s, newLanguage) {
                switch (s) {
                    case 'newLanguage':
                        _this.initTimeline();
                        break;
                }
            });
            this.$messageBusService.subscribe('layer', function (title, layer) {
                switch (title) {
                    case 'activated':
                        _this.addTimelineItemsInLayer(layer);
                        break;
                    case 'deactivate':
                        _this.removeTimelineItemsInLayer(layer);
                        break;
                }
            });
        }
        /** Check whether the layer contains timeline items, and if so, add them to the timeline. */
        TimelineCtrl.prototype.addTimelineItemsInLayer = function (layer) {
            if (!layer.timeAware || !layer.data || !layer.data.features)
                return;
            var layerConfig = layer.timelineConfig;
            var items = [];
            layer.data.features.forEach(function (f) {
                var props = f.properties;
                var featureConfig = f.fType.timelineConfig;
                if (!featureConfig && !layerConfig)
                    return;
                var classProp = (featureConfig && featureConfig.classProperty) || (layerConfig && layerConfig.classProperty);
                var groupClassProp = (featureConfig && featureConfig.groupClassProperty) || (layerConfig && layerConfig.groupClassProperty);
                var contentProp = (featureConfig && featureConfig.contentProperty) || (layerConfig && layerConfig.contentProperty);
                var startProp = (featureConfig && featureConfig.startTimeProperty) || (layerConfig && layerConfig.startTimeProperty);
                var endProp = (featureConfig && featureConfig.endTimeProperty) || (layerConfig && layerConfig.endTimeProperty);
                var groupProp = (featureConfig && featureConfig.groupProperty) || (layerConfig && layerConfig.groupProperty);
                var timelineItem = {
                    id: f.id,
                    layerId: layer.id,
                    className: props.hasOwnProperty(classProp) ? props[classProp] : (featureConfig && featureConfig.class) || (layerConfig && layerConfig.class),
                    groupClass: props.hasOwnProperty(groupClassProp) ? props[groupClassProp] : (featureConfig && featureConfig.groupClass) || (layerConfig && layerConfig.groupClass),
                    group: props.hasOwnProperty(groupProp) ? props[groupProp] : (featureConfig && featureConfig.group) || (layerConfig && layerConfig.group) || '',
                    start: props.hasOwnProperty(startProp) ? props[startProp] : null,
                    end: props.hasOwnProperty(endProp) ? props[endProp] : null,
                    content: props.hasOwnProperty(contentProp) ? props[contentProp] : ''
                };
                items.push(timelineItem);
            });
            this.addItems(items);
        };
        /** Remove all timeline items that could be found in this layer. */
        TimelineCtrl.prototype.removeTimelineItemsInLayer = function (layer) {
            if (!layer.timeAware || !layer.data || !layer.data.features)
                return;
            var deleteItems = [];
            this.timelineItems.forEach(function (item) {
                if (item.layerId !== layer.id)
                    return;
                deleteItems.push(item);
            });
            this.deleteItems(deleteItems);
        };
        /** Update the groups, most likely after certain items have been added or deleted */
        TimelineCtrl.prototype.updateGroups = function () {
            var _this = this;
            this.timelineGroups.clear();
            var groups = [];
            this.timelineItems.forEach(function (item) {
                if (groups.indexOf(item.group) >= 0)
                    return;
                groups.push(item.group);
                _this.timelineGroups.add({
                    className: item.groupClass,
                    content: item.group,
                    id: item.group,
                    title: item.group
                });
            });
        };
        TimelineCtrl.prototype.update = function (s, data) {
            switch (s) {
                case 'updateTimerange':
                    this.$scope.timeline.setWindow(data.start, data.end);
                    this.updateFocusTime();
                    break;
                case 'loadProjectTimeRange':
                    if (typeof this.$layerService.project === 'undefined'
                        || this.$layerService.project === null
                        || typeof this.$layerService.project.timeLine === 'undefined'
                        || this.$layerService.project.timeLine === null)
                        return;
                    this.$scope.timeline.setWindow(this.$layerService.project.timeLine.start, this.$layerService.project.timeLine.end);
                    this.updateFocusTime();
                    break;
                case 'setFocus':
                    this.setFocusContainerDebounce(data);
                    break;
                case 'updateFeatures':
                    this.debounceUpdate();
                    break;
                case 'setItems':
                    this.debounceSetItems(data);
                    break;
                case 'setGroups':
                    this.setGroups(data);
                    break;
            }
        };
        TimelineCtrl.prototype.addItems = function (items) {
            if (!items)
                return;
            this.timelineItems.add(items);
            this.updateGroups();
        };
        TimelineCtrl.prototype.deleteItems = function (items) {
            if (!items)
                return;
            this.timelineItems.remove(items);
            this.updateGroups();
        };
        TimelineCtrl.prototype.setGroups = function (groups) {
            if (!groups)
                return;
            this.timelineGroups.add(groups);
            //var gs = new vis.DataSet(groups);
            //this.$scope.timeline.setGroups(gs);
        };
        TimelineCtrl.prototype.updateFeatures = function () {
            var _this = this;
            //console.log('timeline: updating features');
            //this.items = [];
            //this.$scope.timeline.redraw();
            var temp = [];
            var hasChanged = false;
            // check for new items
            this.$layerService.project.features.forEach(function (f) {
                hasChanged = true;
                if (f.layer.showOnTimeline && f.properties.hasOwnProperty('date')) {
                    temp.push(f.id);
                    if (_this.ids.indexOf(f.id) === -1) {
                        var t = { id: f.id, group: 'all', content: f.properties['Name'], start: new Date(f.properties['date']) };
                        _this.items.update(t);
                        _this.ids.push(f.id);
                    }
                }
            });
            // check for old items
            this.ids.forEach(function (s) {
                hasChanged = true;
                if (temp.indexOf(s) === -1) {
                    // remove item
                    var i = _this.items.remove(s);
                    _this.ids = _this.ids.filter(function (t) { return s !== t; });
                }
            });
            //this.$scope.timeline.setItems(i);
            if (hasChanged)
                this.$scope.timeline.redraw();
        };
        TimelineCtrl.prototype.initTimeline = function () {
            var _this = this;
            var container = document.getElementById('timeline');
            // Remove old timeline before initializing a new one
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            this.$layerService.timeline = this.$scope.timeline = new vis.Timeline(container, this.items, this.options);
            this.$layerService.timeline.redraw();
            if (this.$layerService.project && this.$layerService.project.timeLine !== null) {
                this.$scope.timeline.setWindow(this.$layerService.project.timeLine.start, this.$layerService.project.timeLine.end);
                if (this.$layerService.project.timeLine.isLive)
                    this.goLive();
            }
            this.updateDragging();
            this.updateFocusTime();
            this.$scope.timeline.on('select', function (properties) {
                if (properties.items && properties.items.length > 0) {
                    var id = properties.items[0];
                    var f = _this.$layerService.findFeatureById(id);
                    if (f) {
                        _this.$layerService.selectFeature(f);
                    }
                    else if (_this.$layerService.project.eventTab) {
                        _this.$messageBusService.publish('eventtab', 'zoomto', { id: id });
                    }
                }
            });
            this.$scope.timeline.addEventListener('rangechange', _.throttle(function (prop) { return _this.onRangeChanged(prop); }, 200));
            //this.addEventListener('featureschanged', _.throttle((prop) => this.updateFeatures(), 200));
        };
        TimelineCtrl.prototype.updateDragging = function () {
            var _this = this;
            if (this.$layerService.project && this.$layerService.project.timeLine.isLive) {
                $('#focustimeContainer').draggable('disable');
            }
            else {
                $('#focustimeContainer').draggable({
                    axis: 'x',
                    containment: 'parent',
                    drag: _.throttle(function () { return _this.updateFocusTime(); }, 200)
                });
                $('#focustimeContainer').draggable('enable');
            }
        };
        TimelineCtrl.prototype.expandToggle = function () {
            this.expanded = !this.expanded;
            //    this.options.margin = {};
            //    this.options.margin['item'] = (this.expanded) ? 65 : 0;
            this.options.height = (this.expanded) ? this.$layerService.project.timeLine.expandHeight : 54;
            this.expandButtonBottom = (this.expanded) ? this.$layerService.project.timeLine.expandHeight - 1 : 52;
            this.$layerService.timeline.setOptions(this.options);
            this.$layerService.timeline.redraw();
            this.updatePanelHeights();
        };
        TimelineCtrl.prototype.updatePanelHeights = function () {
            var height = (this.expanded) ? this.$layerService.project.timeLine.expandHeight : 54;
            $('.leftpanel-container').css('bottom', height + 20);
            $('.rightpanel').css('bottom', height);
        };
        /**
         * trigger a debounced timespan updated message on the message bus
         */
        TimelineCtrl.prototype.triggerTimeSpanUpdated = function () {
            this.$messageBusService.publish('timeline', 'timeSpanUpdated', '');
        };
        /**
         * time span was updated by timeline control
         */
        TimelineCtrl.prototype.onRangeChanged = function (prop) {
            this.updateFocusTime();
            this.throttleTimeSpanUpdate();
        };
        TimelineCtrl.prototype.start = function () {
            var _this = this;
            this.stop();
            this.isPlaying = true;
            if (this.timer)
                this.timer = null;
            this.timer = setInterval(function () { _this.myTimer(); }, 500);
        };
        TimelineCtrl.prototype.goLive = function () {
            this.stop();
            this.$layerService.project.timeLine.isLive = true;
            this.isPlaying = false;
            if (this.$layerService.project.timeLine.isLive) {
                this.myTimer();
                this.start();
            }
            this.updateDragging();
        };
        TimelineCtrl.prototype.stopLive = function () {
            if (!this.$layerService.project)
                return;
            this.stop();
            this.$layerService.project.timeLine.isLive = false;
            this.isPlaying = false;
            this.updateDragging();
        };
        TimelineCtrl.prototype.myTimer = function () {
            var tl = this.$scope.timeline;
            if (this.$layerService.project.timeLine.isLive) {
                var pos = tl._toScreen(new Date());
                $('#focustimeContainer').css('left', pos - 65);
                if (this.isPinned)
                    tl.moveTo(new Date(), { animation: { duration: 500, easingFunction: 'linear' } });
                this.updateFocusTime();
            }
            else if (this.isPlaying) {
                var w = tl.getWindow();
                var dif = (w.end.getTime() - w.start.getTime()) / 200;
                tl.setWindow(w.start.getTime() + dif, w.end.getTime() + dif, { animation: { duration: 500, easingFunction: 'linear' } });
                //tl.move(0.005);
                this.updateFocusTime();
            }
        };
        TimelineCtrl.prototype.mouseEnter = function () {
            this.updateFocusTime();
            if (!isNaN(this.focusDate.getTime())) {
                this.showControl = true;
            }
        };
        TimelineCtrl.prototype.mouseLeave = function () {
            if (!this.isPlaying)
                this.showControl = false;
        };
        TimelineCtrl.prototype.pin = function () {
            this.isPinned = true;
        };
        TimelineCtrl.prototype.unPin = function () {
            this.isPinned = false;
        };
        TimelineCtrl.prototype.pinToNow = function () {
            this.isPinned = true;
            this.start();
        };
        TimelineCtrl.prototype.stop = function () {
            this.isPlaying = false;
            if (this.timer)
                clearInterval(this.timer);
        };
        TimelineCtrl.prototype.updateFocusTimeContainer = function (time) {
            this.$scope.timeline.moveTo(time);
            this.$scope.timeline.redraw();
            if (this.$scope.$$phase !== '$apply' && this.$scope.$$phase !== '$digest') {
                this.$scope.$apply();
            }
            var screenPos = this.$scope.timeline._toScreen(time);
            $('#focustimeContainer').css('left', screenPos - $('#focustimeContainer').width() / 2);
        };
        TimelineCtrl.prototype.updateFocusTime = function () {
            var _this = this;
            if (!this.$layerService.project)
                return;
            //if (!this.$mapService.timelineVisible) return;
            setTimeout(function () {
                var tl = _this.$scope.timeline;
                tl.showCustomTime = true;
                // typeof this.$layerService.project === 'undefined'
                //     ? tl.setCustomTime(new Date())
                //     : tl.setCustomTime(this.$layerService.project.timeLine.focusDate());
                //var end = $("#timeline").width;
                var range = _this.$scope.timeline.getWindow();
                //tl.calcConversionFactor();
                var pos = $('#focustimeContainer').position().left + $('#focustimeContainer').width() / 2;
                if (_this.$layerService.project.timeLine.isLive) {
                    _this.focusDate = new Date();
                }
                else {
                    _this.focusDate = new Date(_this.$scope.timeline._toTime(pos));
                }
                _this.startDate = range.start; //new Date(range.start); //this.$scope.timeline.screenToTime(0));
                _this.endDate = range.end; //new Date(this.$scope.timeline.screenToTime(end));
                if (_this.$layerService.project != null && _this.$layerService.project.timeLine != null) {
                    var projecttime = _this.$layerService.project.timeLine;
                    projecttime.setFocus(_this.focusDate, _this.startDate, _this.endDate);
                    var month = _this.focusDate.toLocaleString(_this.locale, { month: 'long' });
                    switch (projecttime.zoomLevelName) {
                        case 'decades':
                            _this.line1 = _this.focusDate.getFullYear().toString();
                            _this.line2 = '';
                            break;
                        case 'years':
                            _this.line1 = _this.focusDate.getFullYear().toString();
                            _this.line2 = month;
                            break;
                        case 'weeks':
                            _this.line1 = _this.focusDate.getFullYear().toString();
                            _this.line2 = moment(_this.focusDate).format('DD') + ' ' + month;
                            break;
                        case 'milliseconds':
                            _this.line1 = moment(_this.focusDate).format('MM - DD - YYYY');
                            _this.line2 = moment(_this.focusDate).format('HH:mm:ss.SSS');
                            break;
                        default:
                            _this.line1 = moment(_this.focusDate).format('MM - DD - YYYY');
                            _this.line2 = moment(_this.focusDate).format('HH:mm:ss');
                    }
                }
                if (_this.$scope.$$phase !== '$apply' && _this.$scope.$$phase !== '$digest') {
                    _this.$scope.$apply();
                }
                _this.$messageBusService.publish('timeline', 'focusChange', _this.focusDate);
            }, 0);
            //this.$layerService.focusTime = new Date(this.timelineCtrl.screenToTime(centerX));
        };
        /**
        * Load the locales: instead of loading them from the original timeline-locales.js distribution,
        * add them here so you don't need to add another js dependency.
        * @seealso: http://almende.github.io/chap-links-library/downloads.html
        */
        TimelineCtrl.prototype.loadLocales = function () {
            if (typeof vis === 'undefined') {
                vis = {};
                vis.locales = {};
            }
            else if (typeof vis.locales === 'undefined') {
                vis.locales = {};
            }
            // English ===================================================
            vis.locales['en'] = {
                'MONTHS': ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                'MONTHS_SHORT': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                'DAYS': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                'DAYS_SHORT': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                'ZOOM_IN': 'Zoom in',
                'ZOOM_OUT': 'Zoom out',
                'MOVE_LEFT': 'Move left',
                'MOVE_RIGHT': 'Move right',
                'NEW': 'New',
                'CREATE_NEW_EVENT': 'Create new event'
            };
            vis.locales['en_US'] = vis.locales['en'];
            vis.locales['en_UK'] = vis.locales['en'];
            // French ===================================================
            vis.locales['fr'] = {
                'MONTHS': ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'],
                'MONTHS_SHORT': ['Jan', 'Fev', 'Mar', 'Avr', 'Mai', 'Jun', 'Jul', 'Aou', 'Sep', 'Oct', 'Nov', 'Dec'],
                'DAYS': ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
                'DAYS_SHORT': ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'],
                'ZOOM_IN': 'Zoomer',
                'ZOOM_OUT': 'Dézoomer',
                'MOVE_LEFT': 'Déplacer à gauche',
                'MOVE_RIGHT': 'Déplacer à droite',
                'NEW': 'Nouveau',
                'CREATE_NEW_EVENT': 'Créer un nouvel évènement'
            };
            vis.locales['fr_FR'] = vis.locales['fr'];
            vis.locales['fr_BE'] = vis.locales['fr'];
            vis.locales['fr_CA'] = vis.locales['fr'];
            // German ===================================================
            vis.locales['de'] = {
                'MONTHS': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
                'MONTHS_SHORT': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
                'DAYS': ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
                'DAYS_SHORT': ['Son', 'Mon', 'Die', 'Mit', 'Don', 'Fre', 'Sam'],
                'ZOOM_IN': 'Vergrößern',
                'ZOOM_OUT': 'Verkleinern',
                'MOVE_LEFT': 'Nach links verschieben',
                'MOVE_RIGHT': 'Nach rechts verschieben',
                'NEW': 'Neu',
                'CREATE_NEW_EVENT': 'Neues Ereignis erzeugen'
            };
            vis.locales['de_DE'] = vis.locales['de'];
            vis.locales['de_CH'] = vis.locales['de'];
            // Dutch =====================================================
            vis.locales['nl'] = {
                'MONTHS': ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
                'MONTHS_SHORT': ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
                'DAYS': ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag'],
                'DAYS_SHORT': ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
                'ZOOM_IN': 'Inzoomen',
                'ZOOM_OUT': 'Uitzoomen',
                'MOVE_LEFT': 'Naar links',
                'MOVE_RIGHT': 'Naar rechts',
                'NEW': 'Nieuw',
                'CREATE_NEW_EVENT': 'Nieuwe gebeurtenis maken'
            };
            vis.locales['nl_NL'] = vis.locales['nl'];
            vis.locales['nl_BE'] = vis.locales['nl'];
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        TimelineCtrl.$inject = [
            '$scope',
            'layerService',
            'mapService',
            'messageBusService',
            'TimelineService'
        ];
        return TimelineCtrl;
    }());
    Timeline.TimelineCtrl = TimelineCtrl;
})(Timeline || (Timeline = {}));
//# sourceMappingURL=TimelineCtrl.js.map
var TripPlanner;
(function (TripPlanner) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        TripPlanner.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        TripPlanner.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    TripPlanner.myModule.directive('tripplanner', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/TripPlanner/TripPlanner.tpl.html',
                replace: true,
                transclude: true,
                controller: TripPlanner.TripPlannerCtrl
            };
        }
    ]);
})(TripPlanner || (TripPlanner = {}));
//# sourceMappingURL=TripPlanner.js.map
var TripPlanner;
(function (TripPlanner) {
    var TripPlannerCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function TripPlannerCtrl($scope, $mapService, $layerService, $messageBusService, $dashboardService) {
            var _this = this;
            this.$scope = $scope;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.urlKeys = ['arriveBy', 'fromPlace', 'toPlace', 'intermediatePlaces', 'date', 'time', 'mode', 'maxWalkDistance', 'walkSpeed', 'bikeSpeed',
                'maxTimeSec', 'precisionMeters', 'zDataType', 'coordinateOrigin'];
            this.scope = $scope;
            $scope.vm = this;
            this.layer = $scope.$parent["data"];
            this.tabs = [];
            this.tabs.push({ icon: 'fa-edit', title: 'Edit' });
            this.tabs.push({ icon: 'fa-map-marker', title: 'Route' });
            this.activeTab = 'Edit';
            this.urlParameters = {};
            this.urlKeys.forEach(function (key) { _this.urlParameters[key] = 0; });
            this.bikeSpeedKm;
            this.walkSpeedKm;
            this.transportModes = {};
            this.transportModes["Walking"] = "WALK";
            this.transportModes["Biking"] = "BICYCLE";
            this.transportModes["Public transport"] = "TRANSIT";
            //this.transportModes["Car"] = "CAR";
        }
        TripPlannerCtrl.prototype.planRoute = function () {
            this.urlParameters['time'] = encodeURIComponent(this.time);
            this.urlParameters['mode'] = this.transportMode;
            if (this.walkSpeedKm)
                this.urlParameters['walkSpeed'] = csComp.Helpers.GeoExtensions.convertKmToMile(this.walkSpeedKm);
            if (this.bikeSpeedKm)
                this.urlParameters['bikeSpeed'] = csComp.Helpers.GeoExtensions.convertKmToMile(this.bikeSpeedKm);
            this.layer.url = csComp.Helpers.joinUrlParameters(this.urlParameters, '?', '&', '=');
            if (!this.layer.enabled) {
                this.$layerService.addLayer(this.layer);
            }
            else {
                if (this.layer.layerSource)
                    this.layer.layerSource.refreshLayer(this.layer);
            }
            this.$layerService.visual.rightPanelVisible = true;
        };
        TripPlannerCtrl.prototype.parseUrl = function () {
            this.urlParameters = csComp.Helpers.parseUrlParameters(this.layer.url, '?', '&', '=');
            var d = new Date(Date.now());
            this.time = ('0' + d.getHours()).slice(-2) + ':' + ('0' + d.getMinutes()).slice(-2);
            this.urlParameters['date'] = (d.getMonth() + 1) + '-' + d.getDate() + '-' + d.getFullYear();
            this.transportMode = this.urlParameters['mode'];
            if (this.urlParameters.hasOwnProperty('walkSpeed'))
                this.walkSpeedKm = +csComp.Helpers.GeoExtensions.convertMileToKm(this.urlParameters['walkSpeed']).toFixed(2);
            if (this.urlParameters.hasOwnProperty('bikeSpeed'))
                this.bikeSpeedKm = +csComp.Helpers.GeoExtensions.convertMileToKm(this.urlParameters['bikeSpeed']).toFixed(2);
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
        };
        TripPlannerCtrl.prototype.featureTabActivated = function (title) {
            var _this = this;
            console.log('activated tab' + title);
            if (title === 'Route') {
                var layer = this.$layerService.findLayer('tripplanner');
                if (!layer)
                    return;
                if (!layer.data.features || layer.data.features.length === 0)
                    return;
                this.itineraries = [];
                layer.data.features.forEach(function (f) {
                    _this.itineraries.push(f.properties);
                });
                this.activeTab = 'Route';
            }
            else {
                this.activeTab = 'Edit';
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        TripPlannerCtrl.$inject = [
            '$scope',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return TripPlannerCtrl;
    }());
    TripPlanner.TripPlannerCtrl = TripPlannerCtrl;
})(TripPlanner || (TripPlanner = {}));
//# sourceMappingURL=TripPlannerCtrl.js.map
var Voting;
(function (Voting) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Voting.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Voting.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display an MCA control.
      */
    Voting.myModule.directive('voting', ['$timeout', function ($timeout) {
            return {
                restrict: 'EA',
                require: '^ngModel',
                scope: {
                    min: '=',
                    max: '=',
                    ngModel: '=',
                    ngChange: '&'
                },
                template: '<div style="line-height: 12px; vertical-align: top; margin: 0; background: rgba(0, 0, 0, 0.1); border-radius: 6px; padding: 4px 6px;">' +
                    '<a href="" data-ng-click="decrement()" data-ng-disabled="ngModel <= min" style="float: left;"><i class="fa" data-ng-class="{true: \'fa-minus-square\', false: \'fa-minus-square-o\'}[ngModel > min]"></i></a>' +
                    '<span style="float: left; width:28px; text-align: center;">{{ngModel}}</span>' +
                    '<a href="" data-ng-click="increment()" data-ng-disabled="ngModel >= max"><i class="fa" data-ng-class="{true: \'fa-plus-square\' , false: \'fa-plus-square-o\' }[ngModel < max]"></i></a>' +
                    '</div>',
                link: function ($scope) {
                    $scope.increment = function () {
                        if ($scope.ngModel >= $scope.max)
                            return;
                        $scope.ngModel++;
                        $timeout($scope.ngChange, 0);
                    };
                    $scope.decrement = function () {
                        if ($scope.ngModel <= $scope.min)
                            return;
                        $scope.ngModel--;
                        $timeout($scope.ngChange, 0);
                    };
                }
            };
        }
    ]);
})(Voting || (Voting = {}));
//# sourceMappingURL=Voting.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var ClientMessage = (function () {
            function ClientMessage(action, data) {
                this.action = action;
                this.data = data;
            }
            return ClientMessage;
        }());
        Services.ClientMessage = ClientMessage;
        // Handle returned when subscribing to a topic
        var MessageBusHandle = (function () {
            function MessageBusHandle(topic, callback) {
                this.topic = topic;
                this.callback = callback;
            }
            return MessageBusHandle;
        }());
        Services.MessageBusHandle = MessageBusHandle;
        var TypedEvent = (function () {
            function TypedEvent() {
                // Private member vars
                this._listeners = [];
            }
            TypedEvent.prototype.add = function (listener) {
                /// <summary>Registers a new listener for the event.</summary>
                /// <param name='listener'>The callback function to register.</param>
                this._listeners.push(listener);
            };
            TypedEvent.prototype.remove = function (listener) {
                /// <summary>Unregisters a listener from the event.</summary>
                /// <param name='listener'>The callback function that was registered. If missing then all listeners will be removed.</param>
                if (typeof listener === 'function') {
                    for (var i = 0, l = this._listeners.length; i < l; l++) {
                        if (this._listeners[i] === listener) {
                            this._listeners.splice(i, 1);
                            break;
                        }
                    }
                }
                else {
                    this._listeners = [];
                }
            };
            TypedEvent.prototype.trigger = function () {
                var a = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    a[_i - 0] = arguments[_i];
                }
                /// <summary>Invokes all of the listeners for this event.</summary>
                /// <param name='args'>Optional set of arguments to pass to listners.</param>
                var context = {};
                var listeners = this._listeners.slice(0);
                for (var i = 0, l = listeners.length; i < l; i++) {
                    listeners[i].apply(context, a || []);
                }
            };
            return TypedEvent;
        }());
        Services.TypedEvent = TypedEvent;
        var Connection = (function () {
            function Connection(id, url, bus) {
                this.id = id;
                this.url = url;
                this.bus = bus;
                this.cache = {};
                this.subscriptions = {};
                // Events
                this.events = new TypedEvent();
            }
            Connection.prototype.unsubscribe = function (id, callback) {
                if (this.subscriptions.hasOwnProperty(id)) {
                    var s = this.subscriptions[id];
                    s.callbacks = s.callbacks.filter(function (f) { return f !== callback; });
                    if (s.callbacks.length === 0) {
                        this.socket.emit(id, { action: 'unsubscribe' });
                        this.socket.removeListener(id, s.serverCallback);
                        s.serverCallback = null;
                        delete this.subscriptions[id];
                    }
                }
            };
            Connection.prototype.reSubscribeAll = function () {
                console.log('resubscribing...');
                for (var s in this.subscriptions) {
                    console.log('reconnecting ' + s);
                    var sub = this.subscriptions[s];
                    this.socket.emit('subscribe', { id: sub.id, target: sub.target, type: sub.type });
                }
            };
            Connection.prototype.disconnectAll = function () {
                console.log('resubscribing...');
                for (var s in this.subscriptions) {
                    var sub = this.subscriptions[s];
                    sub.callbacks.forEach(function (cb) { return cb(sub.id, { action: 'unsubscribed' }); });
                }
            };
            Connection.prototype.subscribe = function (target, type, callback) {
                var _this = this;
                if (!this.socket)
                    return;
                var sub;
                var subs = [];
                for (var s in this.subscriptions) {
                    if (this.subscriptions[s].target === target && this.subscriptions[s].type === type)
                        subs.push(this.subscriptions[s]);
                }
                if (subs == null || subs.length === 0) {
                    sub = new ServerSubscription(target, type);
                    this.socket.emit('subscribe', { id: sub.id, target: sub.target, type: sub.type });
                    sub.callbacks.push(callback);
                    this.subscriptions[sub.id] = sub;
                    sub.serverCallback = function (r) {
                        if (type === 'key') {
                            _this.bus.publish('keyupdate', target, r);
                        }
                        //console.log(r.action);
                        sub.callbacks.forEach(function (cb) { return cb(sub.id, r); });
                    };
                    this.socket.on(sub.id, sub.serverCallback);
                }
                else {
                    sub = subs[0];
                    sub.callbacks.push(callback);
                }
                return sub;
            };
            Connection.prototype.connect = function (callback) {
                var _this = this;
                if (this.isConnected || this.isConnecting || typeof io === 'undefined')
                    return;
                this.socket = io();
                this.isConnecting = true;
                this.socket.on('connect', function () {
                    //console.log(JSON.stringify(this.socket));
                    console.log('socket.io connected');
                    _this.isConnecting = false;
                    _this.isConnected = true;
                    _this.events.trigger('connected');
                    _this.reSubscribeAll();
                    callback();
                });
                this.socket.on('disconnect', function () {
                    _this.isConnecting = false;
                    _this.isConnected = false;
                    _this.disconnectAll();
                    _this.events.trigger('disconnected');
                });
                this.socket.on('reconnect_attempt', function () {
                    console.log('socket.io reconnect attempt');
                    _this.isConnecting = true;
                    _this.isConnected = false;
                });
                this.socket.on('reconnect_failed', function () {
                    console.log('socket.io reconnect failed');
                    _this.isConnecting = false;
                });
            };
            Connection.prototype.disconnect = function () { return; };
            return Connection;
        }());
        Services.Connection = Connection;
        (function (NotifyLocation) {
            NotifyLocation[NotifyLocation["BottomRight"] = 0] = "BottomRight";
            NotifyLocation[NotifyLocation["BottomLeft"] = 1] = "BottomLeft";
            NotifyLocation[NotifyLocation["TopRight"] = 2] = "TopRight";
            NotifyLocation[NotifyLocation["TopLeft"] = 3] = "TopLeft";
            NotifyLocation[NotifyLocation["TopBar"] = 4] = "TopBar";
        })(Services.NotifyLocation || (Services.NotifyLocation = {}));
        var NotifyLocation = Services.NotifyLocation;
        (function (NotifyType) {
            NotifyType[NotifyType["Normal"] = 0] = "Normal";
            NotifyType[NotifyType["Info"] = 1] = "Info";
            NotifyType[NotifyType["Error"] = 2] = "Error";
            NotifyType[NotifyType["Success"] = 3] = "Success";
        })(Services.NotifyType || (Services.NotifyType = {}));
        var NotifyType = Services.NotifyType;
        var ServerSubscription = (function () {
            function ServerSubscription(target, type) {
                this.target = target;
                this.type = type;
                this.callbacks = [];
                this.id = csComp.Helpers.getGuid();
            }
            return ServerSubscription;
        }());
        Services.ServerSubscription = ServerSubscription;
        /**
         * Simple message bus service, used for subscribing and unsubsubscribing to topics.
         * @see {@link https://gist.github.com/floatingmonkey/3384419}
         */
        var MessageBusService = (function () {
            function MessageBusService($translate) {
                this.$translate = $translate;
                this.connections = {};
                this.notifications = [];
                PNotify.prototype.options.styling = 'fontawesome';
            }
            MessageBusService.prototype.getConnection = function (id) {
                if (this.connections.hasOwnProperty(id))
                    return this.connections[id];
                return null;
            };
            MessageBusService.prototype.initConnection = function (id, url, callback) {
                if (id == null)
                    id = '';
                var c = this.getConnection(id);
                if (c == null) {
                    c = new Connection(id, url, this);
                    this.connections[c.id] = c;
                }
                this.connections[id].connect(function () {
                    //for (var topic in c.cache) {
                    //    c.socket.on(topic,(r) => {
                    //        c.cache[topic].forEach(cb => cb(topic, r));
                    //    });
                    //}
                    callback();
                });
            };
            MessageBusService.prototype.serverPublish = function (topic, message, serverId) {
                if (serverId === void 0) { serverId = ''; }
                var c = this.getConnection(serverId);
                if (c == null)
                    return null;
                c.socket.emit(topic, message);
            };
            MessageBusService.prototype.serverSendMessage = function (msg, serverId) {
                if (serverId === void 0) { serverId = ''; }
                var c = this.getConnection(serverId);
                if (c == null)
                    return null;
                c.socket.emit('msg', msg);
            };
            MessageBusService.prototype.serverSendMessageAction = function (action, data, serverId) {
                if (serverId === void 0) { serverId = ''; }
                var cm = new ClientMessage(action, data);
                this.serverSendMessage(cm, serverId);
            };
            MessageBusService.prototype.serverSubscribe = function (target, type, callback, serverId) {
                if (serverId === void 0) { serverId = ''; }
                var c = this.getConnection(serverId);
                if (c == null)
                    return null;
                var sub = c.subscribe(target, type, callback);
                return new MessageBusHandle(sub.id, callback);
            };
            MessageBusService.prototype.serverUnsubscribe = function (handle, serverId) {
                if (serverId === void 0) { serverId = ''; }
                if (!handle)
                    return;
                var c = this.getConnection(serverId);
                if (c == null)
                    return null;
                c.unsubscribe(handle.topic, handle.callback);
            };
            /**
             * Publish a notification that needs to be translated
             * @title:       the translation key of the notification's title
             * @text:        the translation key of the notification's content
             * @location:    the location on the screen where the notification is shown (default bottom right)
             */
            MessageBusService.prototype.notifyWithTranslation = function (title, text, location, type, duration) {
                var _this = this;
                if (location === void 0) { location = NotifyLocation.BottomRight; }
                if (type === void 0) { type = NotifyType.Normal; }
                if (duration === void 0) { duration = 4000; }
                this.$translate(title).then(function (translatedTitle) {
                    _this.$translate(text).then(function (translatedText) {
                        _this.notify(translatedTitle, translatedText, location, type, duration);
                    });
                });
            };
            MessageBusService.prototype.notifyError = function (title, text) {
                this.notify(title, text, NotifyLocation.TopBar, NotifyType.Error);
            };
            /**
             * Publish a notification
             * @title:       the title of the notification
             * @text:        the contents of the notification
             * @location:    the location on the screen where the notification is shown (default bottom right)
             * @notifyType:  the type of notification
             */
            MessageBusService.prototype.notify = function (title, text, location, notifyType, duration) {
                if (location === void 0) { location = NotifyLocation.TopBar; }
                if (notifyType === void 0) { notifyType = NotifyType.Normal; }
                if (duration === void 0) { duration = 4000; }
                //Check if a notication with the same title exists. If so, update existing, if not, add new notification.
                if (this.notifications) {
                    this.notifications = this.notifications.filter(function (n) { return (n.state && n.state !== 'closed'); });
                    var updatedText;
                    this.notifications.some(function (n) {
                        if (n.state === 'closed')
                            return false;
                        if (n.options.title === title) {
                            var foundText = false;
                            var splittedText = n.options.text.split('\n');
                            splittedText.some(function (textLine, index, _splittedText) {
                                if (textLine.replace(/(\ \<\d+\>$)/, '') === text) {
                                    var txt = textLine.replace(/(\ \<\d+\>$)/, '');
                                    var nrWithBrackets = textLine.match(/(\ \<\d+\>$)/);
                                    var nr;
                                    nr = (!nrWithBrackets) ? 2 : +(nrWithBrackets[0].match(/\d+/)) + 1;
                                    _splittedText[index] = txt + ' <' + nr + '>';
                                    foundText = true;
                                    return true;
                                }
                                return false;
                            });
                            if (!foundText) {
                                splittedText.push(text);
                            }
                            updatedText = splittedText.join('\n');
                            n.update({ text: updatedText });
                            return true;
                        }
                        else {
                            return false;
                        }
                    });
                    if (updatedText) {
                        return;
                    }
                }
                var opts = {
                    title: title,
                    text: text,
                    cornerclass: 'ui-pnotify-sharp',
                    shadow: false,
                    addclass: "csNotify",
                    width: "500px",
                    animation: "fade",
                    mouse_reset: true,
                    animate_speed: "slow",
                    nonblock: {
                        nonblock: true,
                        nonblock_opacity: .2
                    },
                    buttons: {
                        closer: true,
                        sticker: false
                    },
                    hide: true
                };
                if (typeof duration != 'undefined')
                    opts['delay'] = duration;
                var PNot = new PNotify(opts);
                this.notifications.push(PNot);
                return PNot;
            };
            MessageBusService.prototype.confirmButtons = function (title, text, buttons, callback) {
                var c = [];
                // buttons.forEach(b=>{
                //     c.push({ text: c, addClass: "", promptTrigger: true, click: (notice, value) =>{ notice.remove(); notice.get().trigger("pnotify.confirm", [notice, value]); } })
                // })            
                var options = {
                    title: title,
                    text: text,
                    addclass: "csNotify",
                    width: "500px",
                    animation: "fade",
                    hide: false,
                    confirm: {
                        confirm: true,
                        buttons: c
                    },
                    buttons: {
                        closer: false,
                        sticker: false
                    },
                    history: {
                        history: false
                    },
                    icon: 'fa fa-question-circle',
                    cornerclass: 'ui-pnotify-sharp'
                };
                var pn = new PNotify(options).get()
                    .on('pnotify.confirm', function (notice, value) {
                    callback("ok");
                })
                    .on('pnotify.cancel', function () { callback(null); });
                return pn;
            };
            /**
             * Show a confirm dialog
             * @title           : the title of the notification
             * @text            : the contents of the notification
             * @callback        : the callback that will be called after the confirmation has been answered.
             */
            MessageBusService.prototype.confirm = function (title, text, callback) {
                var options = {
                    title: title,
                    text: text,
                    addclass: "csNotify",
                    width: "500px",
                    animation: "fade",
                    hide: false,
                    confirm: {
                        confirm: true
                    },
                    buttons: {
                        closer: true,
                        sticker: true
                    },
                    history: {
                        history: false
                    },
                    icon: 'fa fa-question-circle',
                    cornerclass: 'ui-pnotify-sharp',
                    duration: 60000
                };
                var pn = new PNotify(options).get()
                    .on('pnotify.confirm', function () { callback(true); })
                    .on('pnotify.cancel', function () { callback(false); });
                return pn;
            };
            MessageBusService.prototype.notifyBottom = function (title, text) {
                var stack_bar_bottom = { 'dir1': 'up', 'dir2': 'right', 'spacing1': 0, 'spacing2': 0 };
                var options = {
                    title: 'Over Here',
                    text: 'Check me out. I\'m in a different stack.',
                    addclass: 'stack-bar-bottom',
                    cornerclass: '',
                    width: '70%',
                    stack: stack_bar_bottom
                };
                var pn = new PNotify(options);
            };
            /**
             * Publish a notification
             * @title: the title of the notification
             * @text:  the contents of the notification
             */
            MessageBusService.prototype.notifyData = function (data) {
                var pn = new PNotify(data);
                //this.publish('notify', '', data);
            };
            /**
             * Publish to a topic
             */
            MessageBusService.prototype.publish = function (topic, title, data) {
                //window.console.log('publish: ' + topic + ', ' + title);
                if (!MessageBusService.cache[topic])
                    return;
                MessageBusService.cache[topic].forEach(function (cb) { return cb(title, data); });
            };
            //public publish(topic: string, title: string, data?: any): void {
            //	MessageBusService.publish(topic, title, data);
            //}
            /**
             * Subscribe to a topic
             * @param {string} topic The desired topic of the message.
             * @param {IMessageBusCallback} callback The callback to call.
             */
            MessageBusService.prototype.subscribe = function (topic, callback) {
                if (!MessageBusService.cache[topic])
                    MessageBusService.cache[topic] = new Array();
                MessageBusService.cache[topic].push(callback);
                return new MessageBusHandle(topic, callback);
            };
            /**
             * Unsubscribe to a topic by providing its handle
             */
            MessageBusService.prototype.unsubscribe = function (handle) {
                var topic = handle.topic;
                var callback = handle.callback;
                if (!MessageBusService.cache[topic])
                    return;
                MessageBusService.cache[topic].forEach(function (cb, idx) {
                    if (cb === callback) {
                        MessageBusService.cache[topic].splice(idx, 1);
                        return;
                    }
                });
            };
            MessageBusService.cache = {};
            MessageBusService.$inject = [
                '$translate'
            ];
            return MessageBusService;
        }());
        Services.MessageBusService = MessageBusService;
        var EventObj = (function () {
            function EventObj() {
            }
            // Events primitives ======================
            EventObj.prototype.bind = function (event, fct) {
                this.myEvents = this.myEvents || {};
                this.myEvents[event] = this.myEvents[event] || [];
                this.myEvents[event].push(fct);
            };
            EventObj.prototype.unbind = function (event, fct) {
                this.myEvents = this.myEvents || {};
                if (event in this.myEvents === false)
                    return;
                this.myEvents[event].splice(this.myEvents[event].indexOf(fct), 1);
            };
            EventObj.prototype.unbindEvent = function (event) {
                this.myEvents = this.myEvents || {};
                this.myEvents[event] = [];
            };
            EventObj.prototype.unbindAll = function () {
                this.myEvents = this.myEvents || {};
                for (var event in this.myEvents)
                    this.myEvents[event] = false;
            };
            EventObj.prototype.trigger = function (event) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                this.myEvents = this.myEvents || {};
                if (event in this.myEvents === false)
                    return;
                for (var i = 0; i < this.myEvents[event].length; i++) {
                    this.myEvents[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
                }
            };
            EventObj.prototype.registerEvent = function (evtname) {
                this[evtname] = function (callback, replace) {
                    if (typeof callback === 'function') {
                        if (replace)
                            this.unbindEvent(evtname);
                        this.bind(evtname, callback);
                    }
                    return this;
                };
            };
            EventObj.prototype.registerEvents = function (evtnames) {
                var _this = this;
                evtnames.forEach(function (evtname) {
                    _this.registerEvent(evtname);
                });
            };
            return EventObj;
        }());
        Services.EventObj = EventObj;
        /**
          * Register service
          */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('messageBusService', csComp.Services.MessageBusService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=MessageBus.js.map
//# sourceMappingURL=AuthenticationService.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        /**
         * The action service can be used to execute certain actions, e.g. when clicking a feature.
         * It comes with some predefined actions, and can be enhanced with other actions from your application.
         */
        var ActionService = (function () {
            function ActionService(messageBusService, $timeout) {
                this.messageBusService = messageBusService;
                this.$timeout = $timeout;
                this.actions = {};
            }
            /** Initialize the default actions */
            ActionService.prototype.init = function (layerService) {
                var _this = this;
                this.layerService = layerService;
                // NOTE all action titles must be in lowercase
                this.actions['select feature'] = function () {
                    var rpt = csComp.Helpers.createRightPanelTab('featureprops', 'featureprops', null, 'Selected feature', '{{"FEATURE_INFO" | translate}}', 'info', false, true);
                    _this.messageBusService.publish('rightpanel', 'activate', rpt);
                    _this.layerService.visual.rightPanelVisible = true;
                };
                this.actions['select agenda'] = function () {
                    var rpt = csComp.Helpers.createRightPanelTab('agenda', 'agenda', null, 'Selected agenda', '{{"AGENDA_INFO" | translate}}', 'info', false, true);
                    _this.messageBusService.publish('rightpanel', 'activate', rpt);
                };
                this.actions['show style tab'] = function () {
                    _this.layerService.visual.leftPanelVisible = true;
                    $('#style-tab').click();
                };
                this.actions['activate timerange'] = function () {
                    console.log('Activate timerange action called');
                    _this.layerService.project.timeLine.start = new Date().getTime() - 1000 * 60 * 60 * 2;
                    _this.layerService.project.timeLine.end = new Date().getTime() + 1000 * 60 * 60 * 2;
                    _this.layerService.project.timeLine.focus = new Date().getTime();
                };
                this.actions['activate layer'] = function (options) {
                    console.log('Activate layer action called');
                    var pl = _this.layerService.findLayer(options.layerId);
                    if (typeof pl === 'undefined')
                        return;
                    _this.layerService.toggleLayer(pl);
                };
                this.actions['activate style'] = function (options) {
                    console.log('Activate style action called');
                    if (options.layerId) {
                        var pl = _this.layerService.findLayer(options.layerId);
                        if (typeof pl !== 'undefined') {
                            // If the layer is not loaded, activate style after loading.
                            if (!pl.enabled) {
                                _this.layerService.toggleLayer(pl, function () {
                                    _this.$timeout(function () {
                                        _this.activateStyle(options.groupId, options.propertyId);
                                    }, 50);
                                });
                                return;
                            }
                            else if (pl.isLoading) {
                                var handle = _this.messageBusService.subscribe('layer', function (a, l) {
                                    if (a === 'activated' && l.id === options.layerId) {
                                        _this.$timeout(function () {
                                            _this.activateStyle(options.groupId, options.propertyId);
                                        }, 50);
                                        _this.messageBusService.unsubscribe(handle);
                                    }
                                });
                                return;
                            }
                        }
                    }
                    _this.activateStyle(options.groupId, options.propertyId);
                };
                this.actions['activate baselayer'] = function (options) {
                    console.log('Activate baselayer action called');
                    var layer = _this.layerService.$mapService.getBaselayer(options.layerId);
                    _this.layerService.activeMapRenderer.changeBaseLayer(layer);
                    _this.layerService.$mapService.changeBaseLayer(options.layerId);
                };
                this.actions['zoom map'] = function (options) {
                    console.log('Zoom map action called');
                    if (!options['zoomLevel'])
                        return;
                    _this.$timeout(function () {
                        _this.layerService.map.getMap().setZoom(+options['zoomLevel']);
                    }, 0);
                };
                this.actions['center on map'] = function (options) {
                    console.log('Center map action called');
                    // Move map such that selected feature in the center of the map
                    _this.layerService.centerFeatureOnMap(_this.layerService.selectedFeatures);
                };
            };
            /** Call an action by name (lowercase), optionally providing it with additional parameters like group, layer or property id. */
            ActionService.prototype.execute = function (actionTitle, options) {
                var action = actionTitle.toLowerCase();
                if (!this.actions.hasOwnProperty(action)) {
                    console.log("Warning: action " + actionTitle + " is not defined!");
                    return;
                }
                this.actions[action](options);
            };
            /** Add your own action to the list of all actions. */
            ActionService.prototype.addAction = function (actionTitle, func) {
                if (this.actions.hasOwnProperty(actionTitle)) {
                    console.log("Warning: action " + actionTitle + " is already defined!");
                    return;
                }
                this.actions[actionTitle.toLowerCase()] = func;
            };
            /** Return a copy of all the actions. */
            ActionService.prototype.getActions = function () {
                var copy;
                ng.copy(this.actions, copy);
                return copy;
            };
            ActionService.prototype.activateStyle = function (groupId, propId) {
                var group = this.layerService.findGroupById(groupId);
                if (typeof group === 'undefined')
                    return;
                var propType = this.layerService.findPropertyTypeById(propId);
                if (typeof propType === 'undefined')
                    return;
                this.layerService.setGroupStyle(group, propType);
            };
            ActionService.$inject = [
                'messageBusService',
                '$timeout'
            ];
            return ActionService;
        }());
        Services.ActionService = ActionService;
        /**
          * Register service
          */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('actionService', csComp.Services.ActionService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=ActionService.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var propertySensordataGenerator = (function () {
            function propertySensordataGenerator($layerService, $dashboardService) {
                this.$layerService = $layerService;
                this.$dashboardService = $dashboardService;
                this.mb = this.$layerService.$messageBusService;
            }
            propertySensordataGenerator.prototype.start = function (ctrl) {
                var _this = this;
                this.ctrl = ctrl;
                this.options = ctrl.$scope.data.generator;
                ctrl.widget.enabled = false;
                $("#" + this.ctrl.widget.elementId + "-container").css("display", "none");
                this.mb.subscribe('timeline', function (action, range) {
                    if (action === "sensorLinkUpdated" && _this.lastSelectedFeature)
                        _this.selectFeature(_this.lastSelectedFeature);
                });
                this.mb.subscribe('feature', function (action, feature) {
                    switch (action) {
                        case 'onFeatureSelect':
                            _this.selectFeature(feature);
                            break;
                        default:
                            break;
                    }
                });
                ctrl.initChart();
            };
            propertySensordataGenerator.prototype.selectFeature = function (f) {
                if (!f.sensors) {
                    $("#" + this.ctrl.widget.elementId + "-container").css("display", "none");
                    return;
                }
                if (!this.options.hasOwnProperty("featureType") || this.options["featureType"] === f.fType.name) {
                    $("#" + this.ctrl.widget.elementId + "-container").css("display", "block");
                    this.lastSelectedFeature = f;
                    var properties = [];
                    if (this.options.hasOwnProperty("properties")) {
                        // set width/height using the widget width/height (must be set) 
                        var width = parseInt(this.ctrl.widget.width.toLowerCase().replace('px', '').replace('%', '')) - 50;
                        var height = parseInt(this.ctrl.widget.height.toLowerCase().replace('px', '').replace('%', '')) - 75;
                        // make sure we have an array of properties
                        if (this.options.properties instanceof Array) {
                            properties = this.options.properties;
                        }
                        else if (this.options.properties instanceof String) {
                            properties = [this.options.properties];
                        }
                        var values = [];
                        properties.forEach(function (p) {
                            if (f.sensors.hasOwnProperty(p)) {
                                var i = 0;
                                f.layer.timestamps.forEach(function (t) {
                                    var s = f.sensors[p][i];
                                    if (s === -1)
                                        s = null;
                                    if (f.sensors[p].length > i)
                                        values.push({ x: t, y: s, c: 0 });
                                    i += 1;
                                });
                            }
                        });
                        this.ctrl.widget.enabled = false;
                        var spec = {
                            "width": width,
                            "height": height,
                            "padding": { "top": 10, "left": 30, "bottom": 30, "right": 10 },
                            "data": [
                                {
                                    "values": values,
                                    "name": "table"
                                },
                                {
                                    "name": "stats",
                                    "source": "table",
                                    "transform": [
                                        {
                                            "type": "aggregate",
                                            "groupby": ["x"],
                                            "summarize": [{ "field": "y", "ops": ["sum"] }]
                                        }
                                    ]
                                }
                            ],
                            "scales": [
                                {
                                    "name": "x",
                                    "type": "time",
                                    "range": "width",
                                    "points": true,
                                    "domain": { "data": "table", "field": "x" },
                                    "domainMin": f.layer.timestamps[0],
                                    "domainMax": f.layer.timestamps[f.layer.timestamps.length - 1]
                                },
                                {
                                    "name": "y",
                                    "type": "linear",
                                    "range": "height",
                                    "nice": true,
                                    "domain": { "data": "stats", "field": "sum_y" }
                                },
                                {
                                    "name": "color",
                                    "type": "ordinal",
                                    "range": "category10",
                                    "domain": { "data": "table", "field": "c" }
                                }
                            ],
                            "axes": [
                                { "type": "x", "scale": "x", "ticks": 4 },
                                { "type": "y", "scale": "y" }
                            ],
                            "marks": [
                                {
                                    "type": "group",
                                    "from": {
                                        "data": "table",
                                        "transform": [
                                            { "type": "stack", "groupby": ["x"], "sortby": ["c"], "field": "y" },
                                            { "type": "facet", "groupby": ["c"] }
                                        ]
                                    },
                                    "marks": [
                                        {
                                            "type": "area",
                                            "properties": {
                                                "enter": {
                                                    "interpolate": { "value": "monotone" },
                                                    "x": { "scale": "x", "field": "x" },
                                                    "y": { "scale": "y", "field": "layout_start" },
                                                    "y2": { "scale": "y", "field": "layout_end" },
                                                    "fill": { "scale": "color", "field": "c" }
                                                },
                                                "update": {
                                                    "fillOpacity": { "value": 1 }
                                                },
                                                "hover": {
                                                    "fillOpacity": { "value": 0.5 }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        };
                        //console.log(JSON.stringify(spec));
                        this.ctrl.$scope.data._spec = spec;
                        this.ctrl.updateChart();
                    }
                }
            };
            propertySensordataGenerator.prototype.stop = function () {
                //alert('stop');
            };
            return propertySensordataGenerator;
        }());
        Services.propertySensordataGenerator = propertySensordataGenerator;
        var layerPropertySensordataGenerator = (function () {
            function layerPropertySensordataGenerator($layerService, $dashboardService) {
                this.$layerService = $layerService;
                this.$dashboardService = $dashboardService;
                this.mb = this.$layerService.$messageBusService;
            }
            layerPropertySensordataGenerator.prototype.start = function (ctrl) {
                var _this = this;
                this.ctrl = ctrl;
                this.options = ctrl.$scope.data.generator;
                this.mb.subscribe('timeline', function (action, range) {
                    if (action === "timeSpanUpdated")
                        _this.selectLayer(_this.layer);
                });
                this.mb.subscribe('layer', function (action, layer) {
                    switch (action) {
                        case 'onFeatureSelect':
                            break;
                        default:
                            _this.selectLayer(layer);
                            break;
                    }
                });
                ctrl.initChart();
            };
            layerPropertySensordataGenerator.prototype.selectLayer = function (layer) {
                this.layer = layer;
                if (this.options.hasOwnProperty("layer")) {
                    var properties = [];
                    if (this.options.hasOwnProperty("properties")) {
                        // set width/height using the widget width/height (must be set) 
                        var width = parseInt(this.ctrl.widget.width.toLowerCase().replace('px', '').replace('%', '')) - 50;
                        var height = parseInt(this.ctrl.widget.height.toLowerCase().replace('px', '').replace('%', '')) - 75;
                        // make sure we have an array of properties
                        if (this.options.properties instanceof Array) {
                            properties = this.options.properties;
                        }
                        else if (this.options.properties instanceof String) {
                            properties = [this.options.properties];
                        }
                        var values = [];
                        var mintime;
                        var maxtime;
                        properties.forEach(function (p) {
                            layer.data.features.forEach(function (f) {
                                if (f.sensors && f.sensors.hasOwnProperty(p)) {
                                    var i = 0;
                                    f.layer.timestamps.forEach(function (t) {
                                        if (typeof mintime === 'undefined' || mintime > t)
                                            mintime = t;
                                        if (typeof mintime === 'undefined' || maxtime < t)
                                            maxtime = t;
                                        var s = f.sensors[p][i];
                                        if (s === -1)
                                            s = null;
                                        if (f.sensors[p].length > i)
                                            values.push({ x: t, y: s, c: 0 });
                                        i += 1;
                                    });
                                }
                            });
                        });
                        var spec = {
                            "width": width,
                            "height": height,
                            "padding": { "top": 10, "left": 30, "bottom": 30, "right": 10 },
                            "data": [
                                {
                                    "values": values,
                                    "name": "table"
                                },
                                {
                                    "name": "stats",
                                    "source": "table",
                                    "transform": [
                                        {
                                            "type": "aggregate",
                                            "groupby": ["x"],
                                            "summarize": [{ "field": "y", "ops": ["sum"] }]
                                        }
                                    ]
                                }
                            ],
                            "scales": [
                                {
                                    "name": "x",
                                    "type": "time",
                                    "range": "width",
                                    "points": true,
                                    "domain": { "data": "table", "field": "x" },
                                    "domainMin": mintime,
                                    "domainMax": maxtime
                                },
                                {
                                    "name": "y",
                                    "type": "linear",
                                    "range": "height",
                                    "nice": true,
                                    "domain": { "data": "stats", "field": "sum_y" }
                                },
                                {
                                    "name": "color",
                                    "type": "ordinal",
                                    "range": "category10",
                                    "domain": { "data": "table", "field": "c" }
                                }
                            ],
                            "axes": [
                                { "type": "x", "scale": "x", "ticks": 4 },
                                { "type": "y", "scale": "y" }
                            ],
                            "marks": [
                                {
                                    "type": "group",
                                    "from": {
                                        "data": "table",
                                        "transform": [
                                            { "type": "stack", "groupby": ["x"], "sortby": ["c"], "field": "y" },
                                            { "type": "facet", "groupby": ["c"] }
                                        ]
                                    },
                                    "marks": [
                                        {
                                            "type": "area",
                                            "properties": {
                                                "enter": {
                                                    "interpolate": { "value": "monotone" },
                                                    "x": { "scale": "x", "field": "x" },
                                                    "y": { "scale": "y", "field": "layout_start" },
                                                    "y2": { "scale": "y", "field": "layout_end" },
                                                    "fill": { "scale": "color", "field": "c" }
                                                },
                                                "update": {
                                                    "fillOpacity": { "value": 1 }
                                                },
                                                "hover": {
                                                    "fillOpacity": { "value": 0.5 }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        };
                        //console.log(JSON.stringify(spec));
                        this.ctrl.$scope.data._spec = spec;
                        this.ctrl.updateChart();
                    }
                }
            };
            layerPropertySensordataGenerator.prototype.stop = function () {
                //alert('stop');
            };
            return layerPropertySensordataGenerator;
        }());
        Services.layerPropertySensordataGenerator = layerPropertySensordataGenerator;
        var layerKpiGenerator = (function () {
            function layerKpiGenerator($layerService, $dashboardService) {
                this.$layerService = $layerService;
                this.$dashboardService = $dashboardService;
                this.mb = this.$layerService.$messageBusService;
            }
            layerKpiGenerator.prototype.start = function (ctrl) {
                var _this = this;
                this.ctrl = ctrl;
                this.options = ctrl.$scope.data.generator;
                this.mb.subscribe('timeline', function (action, range) {
                    if (action === "sensorLinkUpdated")
                        _this.selectLayer(_this.layer);
                });
                this.mb.subscribe('layer', function (action, layer) {
                    switch (action) {
                        default:
                            _this.selectLayer(layer);
                            break;
                    }
                });
                ctrl.initChart();
            };
            layerKpiGenerator.prototype.selectLayer = function (layer) {
                this.layer = layer;
                if (!layer)
                    return;
                if (!_.isArray(layer.kpiTimestamps))
                    return;
                if (this.options.hasOwnProperty("layer")) {
                    var sensors = [];
                    if (this.options.hasOwnProperty("sensors")) {
                        // set width/height using the widget width/height (must be set) 
                        var width = parseInt(this.ctrl.widget.width.toLowerCase().replace('px', '').replace('%', '')) - 50;
                        var height = parseInt(this.ctrl.widget.height.toLowerCase().replace('px', '').replace('%', '')) - 75;
                        // make sure we have an array of properties
                        if (this.options.sensors instanceof Array) {
                            sensors = this.options.sensors;
                        }
                        else if (this.options.sensors instanceof String) {
                            sensors = [this.options.sensors];
                        }
                        var values = [];
                        if (!sensors)
                            return;
                        sensors.forEach(function (p) {
                            if (layer.sensors && layer.sensors.hasOwnProperty(p)) {
                                var i = 0;
                                layer.kpiTimestamps.forEach(function (t) {
                                    var s = layer.sensors[p][i];
                                    if (s === -1)
                                        s = null;
                                    if (layer.sensors[p].length > i)
                                        values.push({ x: t, y: s, c: 0 });
                                    i += 1;
                                });
                            }
                        });
                        var spec = {
                            "width": width,
                            "height": height,
                            "padding": { "top": 10, "left": 30, "bottom": 30, "right": 10 },
                            "data": [
                                {
                                    "values": values,
                                    "name": "table"
                                },
                                {
                                    "name": "stats",
                                    "source": "table",
                                    "transform": [
                                        {
                                            "type": "aggregate",
                                            "groupby": ["x"],
                                            "summarize": [{ "field": "y", "ops": ["sum"] }]
                                        }
                                    ]
                                }
                            ],
                            "scales": [
                                {
                                    "name": "x",
                                    "type": "time",
                                    "range": "width",
                                    "points": true,
                                    "domain": { "data": "table", "field": "x" },
                                    "domainMin": layer.kpiTimestamps[0],
                                    "domainMax": layer.kpiTimestamps[layer.kpiTimestamps.length - 1]
                                },
                                {
                                    "name": "y",
                                    "type": "linear",
                                    "range": "height",
                                    "nice": true,
                                    "domain": { "data": "stats", "field": "sum_y" }
                                },
                                {
                                    "name": "color",
                                    "type": "ordinal",
                                    "range": "category10",
                                    "domain": { "data": "table", "field": "c" }
                                }
                            ],
                            "axes": [
                                { "type": "x", "scale": "x", "ticks": 4 },
                                { "type": "y", "scale": "y" }
                            ],
                            "marks": [
                                {
                                    "type": "group",
                                    "from": {
                                        "data": "table",
                                        "transform": [
                                            { "type": "stack", "groupby": ["x"], "sortby": ["c"], "field": "y" },
                                            { "type": "facet", "groupby": ["c"] }
                                        ]
                                    },
                                    "marks": [
                                        {
                                            "type": "area",
                                            "properties": {
                                                "enter": {
                                                    "interpolate": { "value": "monotone" },
                                                    "x": { "scale": "x", "field": "x" },
                                                    "y": { "scale": "y", "field": "layout_start" },
                                                    "y2": { "scale": "y", "field": "layout_end" },
                                                    "fill": { "scale": "color", "field": "c" }
                                                },
                                                "update": {
                                                    "fillOpacity": { "value": 1 }
                                                },
                                                "hover": {
                                                    "fillOpacity": { "value": 0.5 }
                                                }
                                            }
                                        }
                                    ]
                                }
                            ]
                        };
                        this.ctrl.$scope.data._spec = spec;
                        this.ctrl.updateChart();
                    }
                }
            };
            layerKpiGenerator.prototype.stop = function () {
                //alert('stop');
            };
            return layerKpiGenerator;
        }());
        Services.layerKpiGenerator = layerKpiGenerator;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=ChartGenerators.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        /** Contains properties needed to describe right panel */
        var RightPanelTab = (function () {
            function RightPanelTab() {
                this.icon = 'tachometer';
                this.popover = '';
                this.open = true;
                this.replace = true;
                this.canClose = true;
            }
            return RightPanelTab;
        }());
        Services.RightPanelTab = RightPanelTab;
        /** service for managing dashboards */
        var DashboardService = (function () {
            function DashboardService($rootScope, $compile, $injector, $location, $timeout, $translate, $messageBusService, $layerService, $mapService, $localStorageService) {
                //$translate('FILTER_INFO').then((translation) => console.log(translation));
                // NOTE EV: private props in constructor automatically become fields, so mb and map are superfluous.
                var _this = this;
                this.$rootScope = $rootScope;
                this.$compile = $compile;
                this.$injector = $injector;
                this.$location = $location;
                this.$timeout = $timeout;
                this.$translate = $translate;
                this.$messageBusService = $messageBusService;
                this.$layerService = $layerService;
                this.$mapService = $mapService;
                this.$localStorageService = $localStorageService;
                this.widgetTypes = {};
                this.chartGenerators = {};
                /** Search status: if isActive is true, show the Navigate directive. */
                this._search = { isActive: false, query: '' };
                this.rightPanelTabs = {};
                //alert('init dashbard');
                this.mainDashboard = new csComp.Services.Dashboard();
                this.dashboards = [];
                this.dashboards['main'] = this.mainDashboard;
                this.touchMode = $localStorageService.get("touchmode");
                this.chartGenerators['sensordata'] = function () { return new csComp.Services.propertySensordataGenerator(_this.$layerService, _this); };
                this.chartGenerators['layerSensorData'] = function () { return new csComp.Services.layerPropertySensordataGenerator(_this.$layerService, _this); };
                this.chartGenerators['kpi'] = function () { return new csComp.Services.layerKpiGenerator(_this.$layerService, _this); };
                this.chartGenerators['top10'] = function () { return new csComp.Services.top10Generator(_this.$layerService, _this); };
                // this.$messageBusService.subscribe("dashboard", (event: string, id: string) => {
                //     //alert(event);
                // });
                this.$messageBusService.subscribe('rightpanel', function (event, tab) {
                    switch (event) {
                        case 'activate':
                            _this.activateTab(tab);
                            break;
                        case 'deactivate':
                            _this.deactivateTab(tab);
                            break;
                        case 'deactiveContainer':
                            _this.deactivateTabContainer(tab);
                            break;
                    }
                });
                this.widgetTypes['agenda'] = {
                    id: 'agenda',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/agenda.png',
                    description: 'Show an event calendar.'
                };
                this.widgetTypes['presentation'] = {
                    id: 'presentation',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/presentation.png',
                    description: 'Create and share presentations.'
                };
                this.widgetTypes['buttonwidget'] = {
                    id: 'buttonwidget',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/touchbutton.png',
                    description: 'Simple on/off button for executing an action.'
                };
                this.widgetTypes['focustimewidget'] = {
                    id: 'focustimewidget',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/touchbutton.png',
                    description: 'Widget showing focus time'
                };
                this.widgetTypes['indicators'] = {
                    id: 'indicators',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/indicators.png',
                    description: 'Showing sensor data using charts'
                };
                this.widgetTypes['charts'] = {
                    id: 'charts',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/markdown.png',
                    description: 'Show custom chart'
                };
                this.widgetTypes['markdownwidget'] = {
                    id: 'markdownwidget',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/markdown.png',
                    description: 'Show custom markdown or html content'
                };
                this.widgetTypes['headerwidget'] = {
                    id: 'headerwidget',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/markdown.png',
                    description: 'Shows a header'
                };
                this.widgetTypes['tablewidget'] = {
                    id: 'tablewidget',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/table.png',
                    description: 'Shows a data table'
                };
                this.widgetTypes['mcawidget'] = {
                    id: 'mcawidget',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/mca.png',
                    description: 'Show available MCA\'s'
                };
                this.widgetTypes['iframewidget'] = {
                    id: 'iframewidget',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/markdown.png',
                    description: 'Show custom iframe'
                };
                this.widgetTypes['kanbanboard'] = {
                    id: 'kanbanboard',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/markdown.png',
                    description: 'Show kanbanboard'
                };
                this.widgetTypes['legendDirective'] = {
                    id: 'legendDirective',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/markdown.png',
                    description: 'Show Legend'
                };
                this.widgetTypes['navigator'] = {
                    id: 'navigatorwidget',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/markdown.png',
                    description: 'Show navigator'
                };
                this.widgetTypes['postman'] = {
                    id: 'postman',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/Script.png',
                    description: 'POST messages'
                };
                this.widgetTypes['simtimecontroller'] = {
                    id: 'simtimecontroller',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/Media-Play.png',
                    description: 'Show simulation time controller'
                };
                this.widgetTypes['simstate'] = {
                    id: 'simstate',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/ServerStatus.png',
                    description: 'Show status of simulation services.'
                };
                this.widgetTypes['locationwidget'] = {
                    id: 'locationwidget',
                    icon: 'bower_components/csweb/dist-bower/images/widgets/search.png',
                    description: 'Show reverse geocode info.'
                };
            }
            Object.defineProperty(DashboardService.prototype, "search", {
                get: function () { return this._search; },
                set: function (s) {
                    this._search = s;
                    if (s.query && s.query.length > 0) {
                        $('#navigate_header').trigger('click');
                        this._search.isActive = s.isActive = this.$layerService.visual.leftPanelVisible = true;
                        this.$messageBusService.publish('search', 'update', s);
                    }
                    else {
                        if ($('#navigate_header').is(':visible'))
                            $('#left_menu_headers li:visible:first').next().trigger('click');
                        this._search.isActive = s.isActive = false;
                        this.$messageBusService.publish('search', 'reset');
                    }
                },
                enumerable: true,
                configurable: true
            });
            ;
            DashboardService.prototype.leftMenuVisible = function (id) {
                var d = this.$layerService.project.activeDashboard;
                if (!d.visibleLeftMenuItems)
                    return true;
                return (d.visibleLeftMenuItems.indexOf(id) >= 0);
            };
            DashboardService.prototype.selectDashboard = function (dashboard, container) {
                this.$location.search('dashboard', dashboard.id);
                if (!_.isUndefined(dashboard.refreshPage) && dashboard.refreshPage) {
                    location.reload();
                }
                else {
                    this.$messageBusService.publish('updatelegend', 'removelegend');
                    //this.$layerService.project.activeDashboard = dashboard;
                    dashboard._initialized = false;
                    this.$messageBusService.publish('dashboard-' + container, 'activated', dashboard);
                }
            };
            DashboardService.prototype.closeContainer = function () {
                alert('close container');
            };
            DashboardService.prototype.activateTab = function (t) {
                var _this = this;
                if (typeof t === 'string') {
                    $('#rightpanelTabs a[data-target="#' + t + '-content"]').tab('show');
                    this.$layerService.visual.rightPanelVisible = true;
                }
                else {
                    var tab = t;
                    if (!tab.hasOwnProperty('container'))
                        return;
                    var content = tab.container + '-content';
                    if (this.rightPanelTabs.hasOwnProperty(tab.container) && this.rightPanelTabs[tab.container].directive === tab.directive && !tab.replace) {
                        $('#rightpanelTabs a[data-target="#' + content + '"]').tab('show');
                        return;
                    }
                    $('#' + tab.container + '-tab').remove();
                    var c = $('#' + content);
                    try {
                        if (c)
                            c.remove();
                    }
                    catch (e) {
                        return;
                    }
                    var popoverString = '';
                    if (tab.popover !== '' && (this.$mapService.expertMode === Services.Expertise.Beginner || this.$mapService.expertMode === Services.Expertise.Intermediate)) {
                        popoverString = 'popover="' + tab.popover + '" popover-placement="left" popover-trigger="mouseenter" popover-append-to-body="true"';
                    }
                    $('#rightpanelTabs').append(this.$compile('<li id="' +
                        tab.container + '-tab" class="rightPanelTab rightPanelTabAnimated" ' +
                        popoverString + '><a id="' + tab.container + '-tab-a" data-target="#' +
                        content + '" data-toggle="tab"><span class="fa fa-' +
                        tab.icon + ' fa-lg"></span></a></li>')(this.$rootScope));
                    $('#rightpanelTabPanes').append('<div class="tab-pane" style="width:355px" id="' + content + '"></div>');
                    $('#' + tab.container + '-tab-a').click(function () {
                        _this.$layerService.visual.rightPanelVisible = true;
                        console.log('rp visible');
                        if (_this.$rootScope.$root.$$phase !== '$apply' && _this.$rootScope.$root.$$phase !== '$digest') {
                            _this.$rootScope.$apply();
                        }
                    });
                    var newScope = this.$rootScope;
                    newScope.data = tab.data;
                    var widgetElement = this.$compile('<' + tab.directive + '></' + tab.directive + '>')(newScope);
                    $('#' + content).append(widgetElement);
                    if (tab.canClose) {
                        $('#' + content).append('<div id="closebutton-' + tab.container + '" class="fa fa-times rightpanel-closebutton" />');
                        $('#closebutton-' + tab.container).click(function () {
                            _this.deactivateTabContainer(tab.container);
                        });
                    }
                    if (_.isUndefined(tab.open) || tab.open === true) {
                        $('#rightpanelTabs a[data-target="#' + content + '"]').tab('show');
                        this.$layerService.visual.rightPanelVisible = true;
                    }
                    this.rightPanelTabs[tab.container] = tab;
                }
            };
            DashboardService.prototype.deactivateTabContainer = function (container) {
                this.$layerService.visual.rightPanelVisible = false;
                delete this.rightPanelTabs[container];
                var content = container + '-content';
                $('#' + container + '-tab').remove();
                try {
                    var c = $('#' + content);
                    if (c) {
                        //var s = (<any>c).scope();
                        c.remove();
                    }
                }
                catch (e) {
                    return;
                }
                if (this.$rootScope.$root.$$phase !== '$apply' && this.$rootScope.$root.$$phase !== '$digest') {
                    this.$rootScope.$apply();
                }
            };
            DashboardService.prototype.deactivateTab = function (tab) {
                if (!tab.hasOwnProperty('container'))
                    return;
                this.deactivateTabContainer(tab.container);
            };
            DashboardService.prototype.editWidget = function (widget) {
                this.activeWidget = widget;
                this.editWidgetMode = true;
                var rpt = csComp.Helpers.createRightPanelTab('widget', 'widgetedit', widget, 'Edit widget', 'Edit widget', 'th-large');
                this.$messageBusService.publish('rightpanel', 'activate', rpt);
                // call widgetctrl edit function
                if (widget._ctrl)
                    widget._ctrl.startEdit();
                // check if editor exists
                if (this.$injector.has(widget.directive + 'EditDirective')) {
                    var rptc = csComp.Helpers.createRightPanelTab('widget-content', widget.directive + '-edit', widget, 'Edit widget', 'Edit widget', 'cog');
                    this.$messageBusService.publish('rightpanel', 'activate', rptc);
                }
                //(<any>$('#leftPanelTab a[data-target="#widgetedit"]')).tab('show'); // Select tab by name
            };
            DashboardService.prototype.stopEditWidget = function () {
                this.activeWidget = null;
                this.editWidgetMode = false;
                //this.$layerService.visual.rightPanelVisible = false;
                $('#widgetEdit').removeClass('active');
            };
            DashboardService.prototype.removeWidget = function () {
                var _this = this;
                if (this.activeWidget && this.mainDashboard) {
                    this.mainDashboard.widgets = this.mainDashboard.widgets.filter(function (w) { return w.id !== _this.activeWidget.id; });
                    this.activeWidget = null;
                    $('#leftPanelTab a[data-target="#basewidgets"]').tab('show'); // Select tab by name
                }
            };
            DashboardService.$inject = [
                '$rootScope',
                '$compile',
                '$injector',
                '$location',
                '$timeout',
                '$translate',
                'messageBusService',
                'layerService',
                'mapService',
                'localStorageService'
            ];
            return DashboardService;
        }());
        Services.DashboardService = DashboardService;
        /**
          * Register service
          */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('dashboardService', csComp.Services.DashboardService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=DashboardService.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var top10Generator = (function () {
            function top10Generator($layerService, $dashboardService) {
                this.$layerService = $layerService;
                this.$dashboardService = $dashboardService;
                this.mb = this.$layerService.$messageBusService;
            }
            top10Generator.prototype.start = function (ctrl) {
                var _this = this;
                this.ctrl = ctrl;
                this.options = ctrl.$scope.data.generator;
                ctrl.initChart();
                this.layerSub = this.mb.subscribe('layer', function (title, layer) {
                    switch (title) {
                        case 'deactivated':
                            if (_this.styleSub)
                                _this.mb.unsubscribe(_this.styleSub);
                            break;
                        case 'activated':
                            _this.layer = layer;
                            if (!_this.options.layer || layer.id === _this.options.layer) {
                                if (!_this.options.property) {
                                    _this.styleSub = _this.mb.subscribe('updatelegend', function (l, style) {
                                        if (l === 'updatedstyle') {
                                            _this.property = style.property;
                                            _this.updateChart(_this.layer);
                                        }
                                    });
                                }
                                else
                                    _this.property = _this.options.property;
                                _this.updateChart(_this.layer);
                            }
                            break;
                    }
                });
            };
            top10Generator.prototype.updateChart = function (layer) {
                var _this = this;
                if (!layer || !layer.data || !this.property)
                    return;
                // set width/height using the widget width/height (must be set) 
                var width = parseInt(this.ctrl.widget.width.toLowerCase().replace('px', '').replace('%', '')) - 50;
                var height = parseInt(this.ctrl.widget.height.toLowerCase().replace('px', '').replace('%', '')) - 80;
                this.ctrl.$scope.data.lite = false;
                var values = [];
                layer.data.features.forEach(function (f) {
                    if (f.properties.hasOwnProperty(_this.property) && f.properties.hasOwnProperty(f.fType.style.nameLabel)) {
                        var pr = { "value": f.properties[_this.property], "name": " " + f.properties[f.fType.style.nameLabel].toString() };
                        values.push(pr);
                    }
                });
                this.ctrl.$scope.data.spec =
                    {
                        "width": width,
                        "height": height,
                        "padding": "auto",
                        "data": [
                            {
                                "name": "source",
                                "values": _.first(_.sortBy(values, function (v) { return -v.value; }), 10),
                                "format": { "type": "json", "parse": { "value": "number" } },
                                "transform": [{ "type": "filter", "test": "datum.value!==null" }]
                            },
                            {
                                "name": "layout",
                                "source": "source",
                                "transform": [
                                    {
                                        "type": "aggregate",
                                        "summarize": [{ "field": "name", "ops": ["distinct"] }]
                                    },
                                    {
                                        "type": "formula",
                                        "field": "cellHeight",
                                        "expr": "(datum.distinct_name + 1) * 21"
                                    }
                                ]
                            }
                        ],
                        "marks": [
                            {
                                "name": "root",
                                "type": "group",
                                "from": { "data": "layout" },
                                "properties": {
                                    "update": {
                                        "width": { "value": 200 },
                                        "height": { "field": "cellHeight" }
                                    }
                                },
                                "marks": [
                                    {
                                        "type": "rect",
                                        "properties": {
                                            "update": {
                                                "x": { "scale": "x", "field": "value" },
                                                "x2": { "value": 0 },
                                                "yc": { "scale": "y", "field": "name" },
                                                "height": { "value": 21, "offset": -1 },
                                                "fill": { "value": "#4682b4" }
                                            }
                                        },
                                        "from": { "data": "source" }
                                    }
                                ],
                                "scales": [
                                    {
                                        "name": "x",
                                        "type": "linear",
                                        "domain": { "data": "source", "field": "value", "sort": true },
                                        "rangeMin": 0,
                                        "rangeMax": 200,
                                        "round": true,
                                        "clamp": true,
                                        "nice": true
                                    },
                                    {
                                        "name": "y",
                                        "type": "ordinal",
                                        "domain": { "data": "source", "field": "name" },
                                        "rangeMin": 0,
                                        "rangeMax": { "data": "layout", "field": "cellHeight" },
                                        "round": true,
                                        "clamp": true,
                                        "bandWidth": 21,
                                        "padding": 1,
                                        "points": true
                                    }
                                ],
                                "axes": [
                                    {
                                        "type": "x",
                                        "scale": "x",
                                        "format": "s",
                                        "grid": true,
                                        "layer": "back",
                                        "ticks": 5,
                                        "title": "value"
                                    },
                                    {
                                        "type": "y",
                                        "scale": "y",
                                        "grid": false,
                                        "title": "name",
                                        "properties": {
                                            "labels": {
                                                "text": { "template": "{{ datum.data | truncate:25}}" }
                                            }
                                        }
                                    }
                                ]
                            }
                        ]
                    };
                this.ctrl.$scope.data.title = this.property;
                // console.log(JSON.stringify(this.ctrl.$scope.data.spec));
                // this.ctrl.updateChart();
                this.ctrl.initChart();
            };
            top10Generator.prototype.stop = function () {
                this.mb.unsubscribe(this.layerSub);
                this.mb.unsubscribe(this.styleSub);
            };
            return top10Generator;
        }());
        Services.top10Generator = top10Generator;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=top10chart.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var Coordinates = (function () {
            function Coordinates() {
            }
            return Coordinates;
        }());
        Services.Coordinates = Coordinates;
        var Geoposition = (function () {
            function Geoposition() {
            }
            return Geoposition;
        }());
        Services.Geoposition = Geoposition;
        var GeoService = (function () {
            function GeoService(bus, $rootScope, $window, $q) {
                this.bus = bus;
                this.$rootScope = $rootScope;
                this.$window = $window;
                this.$q = $q;
                this.geolocation_msgs = {
                    'errors.location.unsupportedBrowser': 'Browser does not support location services',
                    'errors.location.permissionDenied': 'You have rejected access to your location',
                    'errors.location.positionUnavailable': 'Unable to determine your location',
                    'errors.location.timeout': 'Service timeout has been reached'
                };
            }
            GeoService.prototype.getLocation = function () {
                return this.position;
            };
            GeoService.prototype.start = function (opts) {
                var _this = this;
                if (!opts) {
                    opts = {
                        enableHighAccuracy: true,
                        maximumAge: 3000
                    };
                }
                if (this.$window.navigator && this.$window.navigator.geolocation) {
                    this.$window.navigator.geolocation.watchPosition(function (position) {
                        _this.position = position;
                        _this.bus.publish('geo', 'pos', position);
                    }, function (error) {
                        alert(error);
                        switch (error.code) {
                            case 1:
                                // this.$rootScope.$broadcast('error', this.geolocation_msgs['errors.location.permissionDenied']);
                                // this.$rootScope.$apply(function() {
                                //     deferred.reject(this.geolocation_msgs['errors.location.permissionDenied']);
                                // });
                                break;
                            case 2:
                                // this.$rootScope.$broadcast('error', this.geolocation_msgs['errors.location.positionUnavailable']);
                                // this.$rootScope.$apply(function() {
                                //     deferred.reject(this.geolocation_msgs['errors.location.positionUnavailable']);
                                // });
                                break;
                            case 3:
                                // this.$rootScope.$broadcast('error', this.geolocation_msgs['errors.location.timeout']);
                                // this.$rootScope.$apply(function() {
                                //     deferred.reject(this.geolocation_msgs['errors.location.timeout']);
                                // });
                                break;
                        }
                    }, opts);
                }
                else {
                }
                return;
            };
            GeoService.$inject = [
                'messageBusService',
                '$rootScope',
                '$window',
                '$q'
            ];
            return GeoService;
        }());
        Services.GeoService = GeoService;
        /**
          * Register service
          */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('geoService', csComp.Services.GeoService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=geolocation.js.map
//# sourceMappingURL=CISAction.js.map
var ContourAction;
(function (ContourAction) {
    var ContourActionModel = (function () {
        function ContourActionModel() {
            this.id = 'ContourActionModel';
        }
        ContourActionModel.prototype.stop = function () { };
        ContourActionModel.prototype.addFeature = function (feature) { };
        ContourActionModel.prototype.removeFeature = function (feature) { };
        ContourActionModel.prototype.selectFeature = function (feature) { };
        ContourActionModel.prototype.addLayer = function (layer) { };
        ContourActionModel.prototype.removeLayer = function (layer) { };
        ContourActionModel.prototype.getFeatureActions = function (feature) {
            return [];
        };
        ContourActionModel.prototype.getLayerActions = function (layer) {
            return null;
        };
        ContourActionModel.prototype.getFeatureHoverActions = function (feature) {
            if (!feature)
                return [];
            var showContourOption = {
                title: 'show'
            };
            showContourOption.callback = this.showContour;
            var hideContourOption = {
                title: 'hide'
            };
            hideContourOption.callback = this.hideContour;
            return [showContourOption, hideContourOption];
        };
        ContourActionModel.prototype.deselectFeature = function (feature) { };
        ContourActionModel.prototype.updateFeature = function (feuture) { };
        ContourActionModel.prototype.showContour = function (feature, layerService) {
            if (layerService.currentContour)
                layerService.map.map.removeLayer(layerService.currentContour); //remove old contour first
            var fType = layerService.getFeatureType(feature);
            if (fType && fType.hasOwnProperty('contourProperty') && feature.properties.hasOwnProperty(fType['contourProperty'])) {
                var contourProp = feature.properties[fType.contourProperty];
                var geoContour = typeof contourProp === 'object'
                    ? contourProp
                    : JSON.parse(contourProp);
                layerService.currentContour = L.geoJson(geoContour);
                layerService.currentContour.addTo(layerService.map.map);
            }
        };
        ContourActionModel.prototype.hideContour = function (feature, layerService) {
            if (layerService.currentContour)
                layerService.map.map.removeLayer(layerService.currentContour); //remove contour
        };
        ContourActionModel.prototype.init = function (layerService) {
            console.log('init ContourActionService');
        };
        return ContourActionModel;
    }());
    ContourAction.ContourActionModel = ContourActionModel;
})(ContourAction || (ContourAction = {}));
//# sourceMappingURL=ContourAction.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var ExpressionService = (function () {
            function ExpressionService($parse, messageBusService) {
                var _this = this;
                this.$parse = $parse;
                this.messageBusService = messageBusService;
                /**
                 * A common set of operations for parsing Angular expressions, such as:
                 * count, sum, average and standard deviation.
                 *
                 * Since Angular's $parse does not allow you to define a function or for loop, we use a hack to supply these
                 * functions through an object.
                 * See also http://glebbahmutov.com/blog/angularjs-parse-hacks/
                 */
                this.ops = {
                    /** Add a reference to the standard math library */
                    Math: Math,
                    /** Count the number of valid entries */
                    count: function (features, prop) {
                        var count = 0;
                        for (var _i = 0, features_1 = features; _i < features_1.length; _i++) {
                            var f = features_1[_i];
                            if (!f.properties.hasOwnProperty(prop))
                                continue;
                            count++;
                        }
                        return count;
                    },
                    /** Compute the minimum among all the valid entries */
                    min: function (features, prop) {
                        var min = Number.MAX_VALUE;
                        for (var _i = 0, features_2 = features; _i < features_2.length; _i++) {
                            var f = features_2[_i];
                            if (!f.properties.hasOwnProperty(prop))
                                continue;
                            min = Math.min(min, f.properties[prop]);
                        }
                        return min;
                    },
                    /** Compute the maximum among all the valid entries */
                    max: function (features, prop) {
                        var max = Number.MIN_VALUE;
                        for (var _i = 0, features_3 = features; _i < features_3.length; _i++) {
                            var f = features_3[_i];
                            if (!f.properties.hasOwnProperty(prop))
                                continue;
                            max = Math.max(max, f.properties[prop]);
                        }
                        return max;
                    },
                    /** Count the valid entries */
                    sum: function (features, prop) {
                        var sum = 0;
                        for (var _i = 0, features_4 = features; _i < features_4.length; _i++) {
                            var f = features_4[_i];
                            if (!f.properties.hasOwnProperty(prop))
                                continue;
                            sum += f.properties[prop];
                        }
                        return sum;
                    },
                    /** Compute the average over the valid entries */
                    avg: function (features, prop) {
                        var sum = 0, count = 0;
                        for (var _i = 0, features_5 = features; _i < features_5.length; _i++) {
                            var f = features_5[_i];
                            if (!f.properties.hasOwnProperty(prop))
                                continue;
                            sum += f.properties[prop];
                            count++;
                        }
                        return sum / count;
                    },
                    /** Compute the standard deviation of the valid entries */
                    std: function (features, prop) {
                        // Average function
                        var average = function (data) {
                            var sum = data.reduce(function (sum, value) {
                                return sum + value;
                            }, 0);
                            return sum / data.length;
                        };
                        // Extract all data
                        var data = [];
                        for (var _i = 0, features_6 = features; _i < features_6.length; _i++) {
                            var f = features_6[_i];
                            if (!f.properties.hasOwnProperty(prop))
                                continue;
                            data.push(f.properties[prop]);
                        }
                        var avg = average(data);
                        // Compute squared differences between value and average
                        var squareDiffs = data.map(function (value) {
                            return Math.pow(value - avg, 2);
                        });
                        var avgSquareDiff = average(squareDiffs);
                        return Math.sqrt(avgSquareDiff);
                    },
                    /** Calculate percentage of a with respect to b, i.e. a/b * 100% */
                    percentage: function (features, a, b) {
                        var sum_a = _this.ops.sum(features, a);
                        var sum_b = _this.ops.sum(features, b);
                        return sum_a / sum_b;
                    }
                };
            }
            /**
             * Evaluate the layer by evaluating any expressions.
             * @param  {ProjectLayer} layer
             */
            ExpressionService.prototype.evalLayer = function (layer, featureTypes) {
                var _this = this;
                if (!layer || !layer.data || !layer.data.features)
                    return;
                var defaultFeatureType = layer.typeUrl + '#' + layer.defaultFeatureType;
                if (defaultFeatureType && featureTypes.hasOwnProperty(defaultFeatureType)) {
                    var ft = featureTypes[defaultFeatureType];
                    ft._propertyTypeData.forEach(function (pt) { return _this.evalExpressions(pt, layer.data.features); });
                }
                layer.data.features.forEach(function (f) {
                    if (!f.properties.hasOwnProperty('featureTypeId'))
                        return;
                    var ftId = layer.url + f.properties['featureTypeId'];
                    if (!featureTypes.hasOwnProperty(ftId))
                        return;
                    var ft = featureTypes[ftId];
                    _this.evalExpressions(ft, layer.data.features, false);
                });
            };
            /**
             * Check whether the features contain an expressions, and if so, evaluate them.
             * @param  {ng.IParseService} $parse
             * @param  {csComp.Services.TypeResource} resource
             * @param  {IFeature[]} features
             */
            ExpressionService.prototype.evalResourceExpressions = function (resource, features) {
                if (!resource || !resource.propertyTypeData)
                    return;
                for (var k in resource.propertyTypeData) {
                    var propType = resource.propertyTypeData[k];
                    this.evalExpressions(propType, features);
                }
            };
            /**
             * Check whether the property type has an expression, and if so, evaluate it.
             * @param  {IPropertyType} propertyType
             * @param  {IFeature[]} features
             * @param  {boolean} isDefaultPropertyType: default true, indicating that the expression should be applied to all features that haven't explicitly specified their featureTypeId.
             */
            ExpressionService.prototype.evalExpressions = function (propertyType, features, isDefaultPropertyType) {
                if (isDefaultPropertyType === void 0) { isDefaultPropertyType = true; }
                if (!propertyType.expression)
                    return;
                var parsedExpression = this.$parse(propertyType.expression);
                var scope = {
                    features: features,
                    properties: {}
                };
                for (var _i = 0, features_7 = features; _i < features_7.length; _i++) {
                    var feature = features_7[_i];
                    if (!feature.properties)
                        continue;
                    var hasFeatureType = feature.properties.hasOwnProperty('featureTypeId');
                    if ((hasFeatureType && feature.properties['featureTypeId'] === propertyType.label)
                        || !hasFeatureType && isDefaultPropertyType) {
                        scope.properties = feature.properties;
                        feature.properties[propertyType.label] = parsedExpression(scope, this.ops);
                    }
                }
            };
            ExpressionService.prototype.evalExpression = function (expression, features, feature) {
                var parsedExpression = this.$parse(expression);
                var scope = {
                    features: features,
                    properties: feature ? feature.properties : null
                };
                return parsedExpression(scope, this.ops);
            };
            /** Evaluate the expression in a property */
            ExpressionService.prototype.evalPropertyType = function (pt, features, feature) {
                if (!pt.expression)
                    return null;
                return csComp.Helpers.convertPropertyInfo(pt, this.evalExpression(pt.expression, features, feature));
            };
            ExpressionService.$inject = [
                '$parse'
            ];
            return ExpressionService;
        }());
        Services.ExpressionService = ExpressionService;
        /**
         * Register service
         */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('expressionService', csComp.Services.ExpressionService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=ExpressionService.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        (function (ActionType) {
            ActionType[ActionType["Context"] = 0] = "Context";
            ActionType[ActionType["Hover"] = 1] = "Hover";
        })(Services.ActionType || (Services.ActionType = {}));
        var ActionType = Services.ActionType;
        var BasicActionService = (function () {
            function BasicActionService() {
            }
            BasicActionService.prototype.stop = function () { };
            BasicActionService.prototype.addFeature = function (feature) { };
            BasicActionService.prototype.removeFeature = function (feature) { };
            BasicActionService.prototype.selectFeature = function (feature) { };
            BasicActionService.prototype.getLayerActions = function (layer) {
                return [];
            };
            BasicActionService.prototype.getFeatureActions = function (feature) {
                return [];
            };
            BasicActionService.prototype.getFeatureHoverActions = function (feature) {
                return [];
            };
            BasicActionService.prototype.deselectFeature = function (feature) { };
            BasicActionService.prototype.addLayer = function (layer) { };
            BasicActionService.prototype.removeLayer = function (layer) { };
            BasicActionService.prototype.updateFeature = function (feuture) { };
            BasicActionService.prototype.search = function (query, result) {
                result(null, []);
            };
            BasicActionService.prototype.init = function (layerService) {
                this.layerService = layerService;
            };
            return BasicActionService;
        }());
        Services.BasicActionService = BasicActionService;
        var LayerActions = (function (_super) {
            __extends(LayerActions, _super);
            function LayerActions() {
                _super.apply(this, arguments);
                this.id = 'LayerActions';
            }
            LayerActions.prototype.addLayer = function (layer) {
                if (layer.fitToMap && layer.layerSource && _.isFunction(layer.layerSource.fitMap)) {
                    layer.layerSource.fitMap(layer);
                }
            };
            LayerActions.prototype.getLayerActions = function (layer) {
                var _this = this;
                if (!layer)
                    return;
                var res = [];
                if (layer.isEditable && this.layerService.$mapService.isExpert && layer.enabled)
                    res.push({
                        title: 'Edit Layer', icon: 'pencil', callback: function (l, ls) {
                            _this.layerService.$messageBusService.publish('layer', 'startEditing', l);
                        }
                    });
                if (layer.enabled && layer.layerSource) {
                    var refresh = { title: 'Refresh Layer', icon: 'refresh' };
                    refresh.callback = function (layer, layerService) {
                        layer.layerSource.refreshLayer(layer);
                    };
                    res.push(refresh);
                    if (_.isFunction(layer.layerSource.fitMap)) {
                        var fit = { title: 'Fit Map', icon: 'map' };
                        fit.callback = function (layer, layerService) {
                            layer.layerSource.fitMap(layer);
                        };
                        res.push(fit);
                    }
                }
                if (layer.enabled && layer.isEditable && !layer.isDynamic && layer.layerSource) {
                    var reset = { title: 'Reset Layer', icon: 'reset' };
                    reset.callback = function (layer, layerService) {
                        console.log('Resetting layer: ' + layer.title);
                        layer.data.features = [];
                        layer.layerSource.refreshLayer(layer);
                    };
                    res.push(reset);
                }
                if (this.layerService.$mapService.isAdminExpert) {
                    var remove = { title: 'Remove Layer', icon: 'trash' };
                    remove.callback = function (layer, layerService) {
                        layerService.$messageBusService.confirm('Delete layer', 'Are you sure', function (result) {
                            if (result)
                                layerService.removeLayer(layer, true);
                        });
                    };
                    res.push(remove);
                }
                return res;
            };
            LayerActions.prototype.getFeatureActions = function (feature) {
                var res = [];
                if (feature.timestamps && feature.timestamps.length > 0) {
                    var setTimelineZoomActionOption = {
                        title: 'Zoom on timeline'
                    };
                    setTimelineZoomActionOption.callback = this.zoomFeatureTimeline;
                    res.push(setTimelineZoomActionOption);
                }
                if (feature.layer.isDynamic) {
                    var setFilterActionOption = {
                        title: 'Edit'
                    };
                    setFilterActionOption.callback = this.setAsFilter;
                    res.push(setFilterActionOption);
                }
                return res;
            };
            LayerActions.prototype.getFeatureHoverActions = function (feature) {
                return [];
            };
            LayerActions.prototype.zoomFeatureTimeline = function (feature, layerService) {
                var s = new Date(feature.timestamps[0]);
                var e = new Date(feature.timestamps[feature.timestamps.length - 1]);
                layerService.$messageBusService.publish('timeline', 'updateTimerange', { start: s, end: e });
            };
            LayerActions.prototype.setAsFilter = function (feature, layerService) {
                layerService.editFeature(feature);
            };
            LayerActions.prototype.search = function (query, result) {
                var _this = this;
                var scoreMinThreshold = 0.5;
                var r = [];
                var temp = [];
                this.layerService.project.features.forEach(function (f) {
                    var title = csComp.Helpers.getFeatureTitle(f);
                    if (title) {
                        var score = title.toString().score(query.query, null);
                        if (score > scoreMinThreshold)
                            temp.push({ score: score, feature: f, title: title });
                    }
                });
                temp.sort(function (a, b) { return b.score - a.score; }).forEach(function (rs) {
                    if (r.length < 10) {
                        var f = rs.feature;
                        var res = {
                            title: rs.title,
                            description: f.layer.title,
                            feature: f,
                            score: rs.score,
                            icon: 'bower_components/csweb/dist-bower/images/large-marker.png',
                            service: _this.id,
                            click: function () {
                                _this.layerService.$mapService.zoomTo(f);
                                _this.layerService.selectFeature(f);
                            }
                        };
                        //if (f.fType && f.fType.name!=='default') res.description += ' (' + f.fType.name + ')';
                        r.push(res);
                    }
                });
                result(null, r);
            };
            LayerActions.prototype.init = function (layerService) {
                _super.prototype.init.call(this, layerService);
            };
            return LayerActions;
        }(BasicActionService));
        Services.LayerActions = LayerActions;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=LayerActions.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        /** layer service is responsible for reading and managing all project, layer and sensor related data */
        var LayerService = (function () {
            function LayerService($location, $compile, $translate, $messageBusService, $mapService, $rootScope, geoService, $http, expressionService, actionService) {
                var _this = this;
                this.$location = $location;
                this.$compile = $compile;
                this.$translate = $translate;
                this.$messageBusService = $messageBusService;
                this.$mapService = $mapService;
                this.$rootScope = $rootScope;
                this.geoService = geoService;
                this.$http = $http;
                this.expressionService = expressionService;
                this.actionService = actionService;
                /** true if no filters are active */
                this.noFilters = true;
                /** layers that are currently active */
                this.loadedLayers = {};
                this.actionServices = [];
                this.visual = new Services.VisualState();
                this.actionService.init(this);
                //$translate('FILTER_INFO').then((translation) => console.log(translation));
                // NOTE EV: private props in constructor automatically become fields, so mb and map are superfluous.
                this.mb = $messageBusService;
                this.map = $mapService;
                this.openSingleProject = false;
                this.emptySolutionUrl = 'data/api/defaultSolution.json';
                this.accentColor = '';
                this.title = '';
                this.typesResources = {};
                this._featureTypes = {};
                this.propertyTypeData = {};
                this.selectedFeatures = [];
                this.currentLocale = $translate.preferredLanguage();
                // init map renderers
                this.mapRenderers = {};
                this.visual = new Services.VisualState();
                // add renderers
                this.mapRenderers['leaflet'] = new Services.LeafletRenderer();
                this.mapRenderers['leaflet'].init(this);
                this.mapRenderers['cesium'] = new Services.CesiumRenderer();
                this.mapRenderers['cesium'].init(this);
                this.initLayerSources();
                this.throttleSensorDataUpdate = _.debounce(this.updateSensorData, 500);
                var delayFocusChange = _.debounce(function (date) {
                    _this.refreshActiveLayers();
                }, 500);
                $('body').keyup(function (e) {
                    if (e.keyCode === 46 && e.target.localName !== 'input') {
                        if (_this.selectedFeatures.length > 1) {
                            _this.$messageBusService.confirm('Delete objects', 'Do you want to remove all (' + _this.selectedFeatures.length + ') selected objects ?', function (r) {
                                _this.selectedFeatures.forEach(function (f) {
                                    _this.removeFeature(f, true);
                                });
                            });
                        }
                        else {
                            if (_this.selectedFeatures.length === 1) {
                                _this.$messageBusService.confirm('Delete object', 'Are you sure', function (r) {
                                    _this.removeFeature(_this.selectedFeatures[0], true);
                                });
                            }
                        }
                    }
                });
                $messageBusService.subscribe('timeline', function (trigger, date) {
                    switch (trigger) {
                        case 'focusChange':
                            _this.throttleSensorDataUpdate();
                            break;
                        case 'timeSpanUpdated':
                            _this.updateSensorLinks();
                            break;
                        case 'focusChange':
                            delayFocusChange(date);
                            break;
                    }
                });
                $messageBusService.subscribe('language', function (title, language) {
                    if (title !== 'newLanguage')
                        return;
                    _this.currentLocale = language;
                    $messageBusService.notifyWithTranslation('LAYER_SERVICE.RELOAD_PROJECT_TITLE', 'LAYER_SERVICE.RELOAD_PROJECT_MSG');
                    _this.openProject(_this.projectUrl);
                });
                $messageBusService.subscribe('mapbbox', function (title, bbox) {
                    if (title !== 'update')
                        return;
                    for (var l in _this.loadedLayers) {
                        var layer = _this.loadedLayers[l];
                        if (layer.refreshBBOX) {
                            // When any groupstyle(s) present, store and re-apply after refreshing the layer
                            // var oldStyles;
                            // if (layer.group && layer.group.styles && layer.group.styles.length > 0) {
                            //     oldStyles = layer.group.styles;
                            // }
                            layer.BBOX = bbox;
                            layer.layerSource.refreshLayer(layer);
                        }
                    }
                });
                $messageBusService.subscribe('menu', function (title, data) {
                    if (title === 'show' && typeof data === 'boolean')
                        _this.visual.leftPanelVisible = data;
                });
                this.addActionService(new Services.LayerActions());
                this.addActionService(new MatrixAction.MatrixActionModel());
                this.addActionService(new RelationAction.RelationActionModel());
                // var delayFocusChange = _.debounce((date) => {
                //     this.refreshActiveLayers();
                // }, 500);
                // $messageBusService.subscribe('timeline', (action: string, date: Date) => {
                //     if (action === 'focusChange') {
                //         delayFocusChange(date);
                //         //this.refreshActiveLayers();
                //     }
                // });
                this.checkMobile();
                this.enableDrop();
            }
            LayerService.prototype.refreshActiveLayers = function () {
                for (var l in this.loadedLayers) {
                    var layer = this.loadedLayers[l];
                    if (layer.timeDependent) {
                        layer.layerSource.refreshLayer(layer);
                    }
                }
            };
            LayerService.prototype.updateLayerKpiLink = function (layer) {
                var _this = this;
                if (layer.sensorLink && layer.sensorLink.kpiUrl) {
                    // create sensorlink
                    if (!_.isUndefined(layer._gui["loadingKpiLink"]) && layer._gui["loadingKpiLink"])
                        return;
                    var link = layer.sensorLink.kpiUrl;
                    if (!this.project.activeDashboard.isLive) {
                        link += "?tbox=" + this.project.timeLine.start + "," + this.project.timeLine.end;
                    }
                    else {
                        if (_.isUndefined(layer.sensorLink.liveInterval)) {
                            link += "?tbox=1h";
                        }
                        else {
                            link += "?tbox=" + layer.sensorLink.liveInterval;
                        }
                    }
                    console.log('kpi:' + link);
                    layer._gui["loadingKpiLink"] = true;
                    this.$http.get(link)
                        .success(function (data) {
                        layer._gui["loadingKpiLink"] = false;
                        layer.kpiTimestamps = data.timestamps;
                        if (typeof data.kpis !== 'undefined') {
                            layer.sensors = data.kpis;
                        }
                        _this.$messageBusService.publish("timeline", "sensorLinkUpdated");
                    })
                        .error(function (e) {
                        layer._gui["loadingKpiLink"] = false;
                        console.log('error loading sensor data');
                    });
                }
            };
            LayerService.prototype.updateLayerSensorLink = function (layer) {
                var _this = this;
                if (layer.sensorLink) {
                    // create sensorlink
                    if (!_.isUndefined(layer._gui["loadingSensorLink"]) && layer._gui["loadingSensorLink"])
                        return;
                    var link = layer.sensorLink.url;
                    if (!this.project.activeDashboard.isLive) {
                        link += "?tbox=" + this.project.timeLine.start + "," + this.project.timeLine.end;
                    }
                    else {
                        if (_.isUndefined(layer.sensorLink.liveInterval)) {
                            link += "?tbox=15m";
                        }
                        else {
                            link += "?tbox=" + layer.sensorLink.liveInterval;
                        }
                    }
                    layer._gui['lastSensorLink'] = link;
                    console.log('downloading ' + link);
                    layer._gui["loadingSensorLink"] = true;
                    this.$http.get(link)
                        .success(function (data) {
                        layer._gui["loadingSensorLink"] = false;
                        layer.timestamps = data.timestamps;
                        layer.data.features.forEach(function (f) {
                            f.sensors = {};
                            data.properties.forEach(function (s) { return f.sensors[s] = []; });
                        });
                        var t = 0;
                        var featureLookup = [];
                        var p = 0;
                        data.features.forEach(function (f) {
                            //var index = _.findIndex(layer.data.features, ((p: csComp.Services.IFeature) => p.properties[layer.sensorLink.linkid] === f));
                            //if (index !== -1) featureLookup.push(index);
                            featureLookup.push(p);
                            p += 1;
                        });
                        for (var s in data.data) {
                            var sensordata = data.data[s];
                            for (var ti = 0; ti < data.timestamps.length; ti++) {
                                if (sensordata.length > ti) {
                                    for (var fi = 0; fi < sensordata[ti].length; fi++) {
                                        // get feature
                                        var findex = featureLookup[fi];
                                        if (findex >= 0) {
                                            var f = layer.data.features[findex];
                                            if (f) {
                                                var value = sensordata[ti][fi];
                                                //if (value === -1) value = null;
                                                f.sensors[s].push(value);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        _this.throttleSensorDataUpdate();
                        _this.$messageBusService.publish("timeline", "sensorLinkUpdated");
                    })
                        .error(function (e) {
                        layer._gui["loadingSensorLink"] = false;
                        console.log('error loading sensor data');
                    });
                }
                this.updateLayerKpiLink(layer);
            };
            /**
             * Get external sensordata for loaded layers with sensor links enabled
             */
            LayerService.prototype.updateSensorLinks = function () {
                var updated = false;
                console.log('updating sensorlinks');
                for (var l in this.loadedLayers) {
                    var layer = this.loadedLayers[l];
                    this.updateLayerSensorLink(layer);
                    console.log(layer.title);
                }
                ;
            };
            LayerService.prototype.enableDrop = function () {
                var _this = this;
                var w = window;
                if (w.File && w.FileList && w.FileReader) {
                    var obj = $('body');
                    obj.on('dragenter', function (e) {
                        e.stopPropagation();
                        e.preventDefault();
                        $(_this).css('border', '2px solid #0B85A1');
                    });
                    obj.on('dragover', function (e) {
                        e.stopPropagation();
                        e.preventDefault();
                    });
                    obj.on('drop', function (e) {
                        $(_this).css('border', '2px dotted #0B85A1');
                        e.preventDefault();
                        var ev = e.originalEvent;
                        var files = ev.dataTransfer.files;
                        if (files.length > 1) {
                            _this.$messageBusService.notify('File upload', 'Only one file at a time permitted');
                        }
                        else {
                            _this.handleFileUpload(files, obj);
                        }
                        //We need to send dropped files to Server
                    });
                }
            };
            LayerService.prototype.handleFileUpload = function (files, obj) {
                var _this = this;
                for (var i = 0; i < files.length; i++) {
                    var file = files[i];
                    console.log(file);
                    var reader = new FileReader();
                    reader.onload = function (e) {
                        // get file content
                        var text = e.target.result;
                        var obj = JSON.parse(text);
                        if (obj && obj.type && ['featurecollection', 'geojson', 'dynamicgeojson'].indexOf(obj.type.toLowerCase()) >= 0) {
                            var newLayer = new csComp.Services.ProjectLayer();
                            var id = file.name.toLowerCase().replace('.json', '').replace('.geojson', '');
                            newLayer.id = id;
                            newLayer.title = id;
                            newLayer.type = 'dynamicgeojson';
                            newLayer.groupId = _this.project.groups[0].id;
                            newLayer.group = _this.project.groups[0];
                            newLayer.data = obj;
                            _this.$messageBusService.publish('layerdrop', 'new', newLayer);
                        }
                        else {
                            _this.$messageBusService.notify('File upload', 'File format not recognized');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            LayerService.prototype.checkMobile = function () {
                if (screen.width <= 719) {
                    this.isMobile = true;
                }
            };
            LayerService.prototype.getActions = function (feature, type) {
                if (!feature || typeof type !== 'number')
                    return;
                var options = [];
                if (type === Services.ActionType.Context) {
                    this.actionServices.forEach(function (as) {
                        var asOptions = as.getFeatureActions(feature);
                        if (asOptions)
                            options = options.concat(asOptions);
                    });
                    options.forEach(function (a) {
                        a.feature = feature;
                    });
                }
                else if (type === Services.ActionType.Hover) {
                    this.actionServices.forEach(function (as) {
                        var asOptions = as.getFeatureHoverActions(feature);
                        if (asOptions)
                            options = options.concat(asOptions);
                    });
                    options.forEach(function (a) {
                        a.feature = feature;
                    });
                }
                return options;
            };
            LayerService.prototype.addActionService = function (as) {
                var asAlreadyExists = false;
                this.actionServices.some(function (actServ) {
                    if (actServ.id === as.id) {
                        asAlreadyExists = true;
                        return true;
                    }
                    return false;
                });
                if (asAlreadyExists) {
                    console.log('Actionservice ' + as.id + ' already exists.');
                }
                else {
                    this.actionServices.push(as);
                    as.init(this);
                }
            };
            LayerService.prototype.removeActionService = function (as) {
                as.stop();
            };
            LayerService.prototype.checkViewBounds = function () {
                if (this.project && this.project.activeDashboard && this.project.activeDashboard.viewBounds) {
                    this.activeMapRenderer.fitBounds(this.project.activeDashboard.viewBounds);
                }
                else if (this.project && this.project.viewBounds) {
                    this.activeMapRenderer.fitBounds(this.project.viewBounds);
                }
                else if (this.solution && this.solution.viewBounds) {
                    this.activeMapRenderer.fitBounds(this.solution.viewBounds);
                }
            };
            /** Find a dashboard by ID */
            LayerService.prototype.findDashboardById = function (dashboardId) {
                var dashboard;
                this.project.dashboards.some(function (d) {
                    if (d.id !== dashboardId)
                        return false;
                    dashboard = d;
                    return true;
                });
                return dashboard;
            };
            /** Find a widget by ID, optionally supplying its parent dashboard id. */
            LayerService.prototype.findWidgetById = function (widgetId, dashboardId) {
                var dashboard;
                var widget;
                if (dashboardId) {
                    dashboard = this.findDashboardById(dashboardId);
                    if (!dashboard)
                        return null;
                    dashboard.widgets.some(function (w) {
                        if (w.id !== widgetId)
                            return false;
                        widget = w;
                        return true;
                    });
                }
                else {
                    this.project.dashboards.some(function (d) {
                        d.widgets.some(function (w) {
                            if (w.id !== widgetId)
                                return false;
                            widget = w;
                            return true;
                        });
                        if (!widget)
                            return false;
                        return true;
                    });
                }
                return widget;
            };
            /**
             * Initialize the available layer sources
             */
            LayerService.prototype.initLayerSources = function () {
                // init layer sources
                this.layerSources = {};
                // add a topo/geojson source
                var geojsonsource = new Services.GeoJsonSource(this, this.$http);
                this.layerSources['geojson'] = geojsonsource;
                this.layerSources['topojson'] = geojsonsource;
                this.layerSources['editablegeojson'] = new Services.EditableGeoJsonSource(this, this.$http);
                this.layerSources['dynamicgeojson'] = new Services.DynamicGeoJsonSource(this, this.$http);
                this.layerSources['esrijson'] = new Services.EsriJsonSource(this, this.$http);
                // add kml source
                var kmlDataSource = new Services.KmlDataSource(this, this.$http);
                this.layerSources['kml'] = kmlDataSource;
                this.layerSources['gpx'] = kmlDataSource;
                // add wms source
                this.layerSources['wms'] = new Services.WmsSource(this);
                //add tile layer
                this.layerSources['tilelayer'] = new Services.TileLayerSource(this);
                //add heatmap layer
                this.layerSources['heatmap'] = new Services.HeatmapSource(this);
                //add hierarchy layer
                this.layerSources['hierarchy'] = new Services.HierarchySource(this, this.$http);
                //add grid layer
                this.layerSources['grid'] = new Services.GridDataSource(this, this.$http);
                //add day or night data source
                this.layerSources['daynight'] = new Services.NightDayDataSource(this, this.$http);
                // add RSS data source
                this.layerSources['rss'] = new Services.RssDataSource(this, this.$http);
                // add Database data source
                this.layerSources['database'] = new Services.DatabaseSource(this);
                // add VectorTile data source
                this.layerSources['vectortile'] = new Services.VectorTileSource(this, this.$http);
                // check for every feature (de)select if layers should automatically be activated
                this.checkFeatureSubLayers();
            };
            LayerService.prototype.removeSubLayers = function (feature) {
                var _this = this;
                if (!feature || !feature.fType)
                    return;
                var props = csComp.Helpers.getPropertyTypes(feature.fType, this.propertyTypeData);
                props.forEach(function (prop) {
                    if (prop.type === 'layer' && feature.properties.hasOwnProperty(prop.label)) {
                        var l = feature.properties[prop.label];
                        if (_this.loadedLayers.hasOwnProperty(l)) {
                            var layer = _this.loadedLayers[l];
                            _this.removeLayer(_this.loadedLayers[l], true);
                        }
                    }
                });
            };
            /**
            * Check for every feature (de)select if layers should automatically be activated
            */
            LayerService.prototype.checkFeatureSubLayers = function () {
                var _this = this;
                this.$messageBusService.subscribe('feature', function (action, feature) {
                    if (!feature || !feature.fType)
                        return;
                    switch (action) {
                        case 'onFeatureDeselect':
                            break;
                        case 'onFeatureSelect':
                            var props = csComp.Helpers.getPropertyTypes(feature.fType, _this.propertyTypeData);
                            props.forEach(function (prop) {
                                if (prop.type === 'layer' && feature.properties.hasOwnProperty(prop.label)) {
                                    if (prop.layerProps && prop.layerProps.activation === 'automatic')
                                        _this.removeSubLayers(feature.layer._lastSelectedFeature);
                                    if (typeof prop.layerProps.dashboard === 'undefined' || prop.layerProps.dashboard === _this.project.activeDashboard.id) {
                                        feature.layer._lastSelectedFeature = feature;
                                        var l = feature.properties[prop.label];
                                        var pl = _this.findLayer(l);
                                        if (pl) {
                                            _this.addLayer(pl);
                                        }
                                        else {
                                            if (typeof l === 'string') {
                                                pl = new Services.ProjectLayer();
                                                pl.url = l;
                                            }
                                            else {
                                                pl = l;
                                            }
                                            if (!pl.id)
                                                pl.id = l;
                                            pl.groupId = prop.layerProps.groupId;
                                            if (!pl.group) {
                                                if (pl.groupId) {
                                                    pl.group = _this.findGroupById(pl.groupId);
                                                }
                                                else {
                                                    pl.group = feature.layer.group;
                                                }
                                            }
                                            else {
                                                if (typeof pl.group === 'string') {
                                                    pl.group = _this.findGroupById(pl.group);
                                                }
                                            }
                                            if (!pl.type)
                                                pl.type = feature.layer.type;
                                            if (!pl.title)
                                                pl.title = feature.properties['Name'] + ' ' + prop.title;
                                            if (!pl.defaultFeatureType)
                                                pl.defaultFeatureType = prop.layerProps.defaultFeatureType;
                                            if (!pl.typeUrl)
                                                pl.typeUrl = prop.layerProps.typeUrl;
                                            if (!pl.defaultLegendProperty)
                                                pl.defaultLegendProperty = prop.layerProps.defaultLegendProperty;
                                            pl.hasSensorData = true;
                                            //pl.parentFeature = feature;
                                            pl.group.layers.push(pl);
                                        }
                                        _this.addLayer(pl);
                                    }
                                }
                            });
                            break;
                    }
                });
            };
            LayerService.prototype.loadRequiredLayers = function (layer) {
                var _this = this;
                // find layer source, and activate layer
                var layerSource = layer.type.toLowerCase();
                // if a layer is depends on other layers, load those first
                if (this.layerSources.hasOwnProperty(layerSource)) {
                    if (this.layerSources[layerSource].requiresLayer) {
                        var requiredLayers = this.layerSources[layerSource].getRequiredLayers(layer) || [];
                        requiredLayers.forEach(function (l) {
                            _this.addLayer(l);
                        });
                    }
                }
            };
            LayerService.prototype.addLayer = function (layer, layerloaded, data) {
                var _this = this;
                if (data === void 0) { data = null; }
                if (this.loadedLayers.hasOwnProperty(layer.id) && (!layer.quickRefresh || layer.quickRefresh === false))
                    return;
                if (layer.isLoading)
                    return;
                layer.isLoading = true;
                this.$messageBusService.publish('layer', 'loading', layer);
                var disableLayers = [];
                async.series([
                    function (callback) {
                        // check if in this group only one layer can be active
                        // make sure all existising active layers are disabled
                        if (layer.group.oneLayerActive) {
                            layer.group.layers.forEach(function (l) {
                                if (l.id !== layer.id && l.enabled) {
                                    disableLayers.push(l);
                                }
                            });
                        }
                        callback(null, null);
                    },
                    function (callback) {
                        // console.log('loading types: ' + layer.typeUrl);
                        if (layer.typeUrl) {
                            // TODO Check if we haven't loaded it already
                            _this.loadTypeResources(layer.typeUrl, layer.dynamicResource || false, function () { return callback(null, null); });
                        }
                        else {
                            callback(null, null);
                        }
                    },
                    function (callback) {
                        // load required feature layers, if applicable
                        _this.loadRequiredLayers(layer);
                        // suport for loading default geojson
                        if (layer.type.toLowerCase() === 'featurecollection')
                            layer.type = 'geojson';
                        // find layer source, and activate layer
                        var layerSource = layer.type.toLowerCase();
                        if (!_this.layerSources.hasOwnProperty(layerSource)) {
                            // We don't know how to deal with an unknown layer source, so stop here.
                            layer.isLoading = false;
                            _this.$messageBusService.publish('layer', 'error', layer);
                            callback(null, null);
                            // TODO Stop spinner
                            return;
                        }
                        layer.layerSource = _this.layerSources[layerSource];
                        layer.layerSource.addLayer(layer, function (l) {
                            if (l.enabled) {
                                _this.loadedLayers[layer.id] = l;
                                _this.updateSensorData();
                                _this.activeMapRenderer.addLayer(layer);
                                if (layer.defaultLegendProperty)
                                    _this.checkLayerLegend(layer, layer.defaultLegendProperty);
                                _this.checkLayerTimer(layer);
                                if (_this.actionServices)
                                    _this.actionServices.forEach(function (as) {
                                        if (as.addLayer)
                                            as.addLayer(layer);
                                    });
                                _this.updateLayerSensorLink(layer);
                                _this.updateLayerSensorData(layer, _this.project.timeLine.focusDate());
                                _this.$messageBusService.publish('layer', 'activated', layer);
                                _this.$messageBusService.publish('updatelegend', 'updatedstyle');
                                // if (layerloaded) layerloaded(layer);
                                _this.expressionService.evalLayer(l, _this._featureTypes);
                            }
                            if (layerloaded)
                                layerloaded(layer);
                        }, data);
                        if (layer.timeAware)
                            _this.$messageBusService.publish('timeline', 'updateFeatures');
                        callback(null, null);
                    },
                    function (callback) {
                        // now remove the layers that need to be disabled
                        disableLayers.forEach(function (l) {
                            _this.removeLayer(l);
                            l.enabled = false;
                        });
                        callback(null, null);
                    }
                ]);
            };
            /// If a layer has a default legend defined it will lookup the resource and return the legend
            LayerService.prototype.getLayerLegend = function (l) {
                var tr = this.findResourceByLayer(l);
                if (tr && tr.legends) {
                    if (tr.legends.hasOwnProperty(l.defaultLegend))
                        return tr.legends[l.defaultLegend];
                }
                return null;
            };
            LayerService.prototype.evaluateLayerExpressions = function (l, fTypes) {
                this.expressionService.evalLayer(l, fTypes);
            };
            LayerService.prototype.evaluateFeatureExpressions = function (f) {
                this.expressionService.evalResourceExpressions(this.findResourceByFeature(f), [f]);
            };
            /** save a resource back to the api */
            LayerService.prototype.saveResource = function (resource) {
                console.log('saving feature type');
                if (resource.url) {
                    this.$http.put('/api/resources', csComp.Helpers.cloneWithoutUnderscore(resource))
                        .success(function (data) {
                        console.log('resource saved');
                    })
                        .error(function (e) {
                        console.log('error saving resource');
                    });
                }
            };
            LayerService.prototype.expandGroup = function (layer) {
                // expand the group in the layerlist if it is collapsed
                if (!layer || !layer.group) {
                    return;
                }
                var id = '#layergroup_' + layer.group.id;
                $(id).collapse('show');
                $('*[data-target="' + id + '"]').removeClass('collapsed');
                this.apply();
            };
            LayerService.prototype.collapseAll = function () {
                this.project.groups.forEach(function (g) {
                    var layerEnabled = false;
                    g.layers.some(function (l) {
                        if (l.enabled)
                            layerEnabled = true;
                        return l.enabled;
                    });
                    if (!layerEnabled) {
                        var id = '#layergroup_' + g.id;
                        $(id).collapse('hide');
                        $('*[data-target="' + id + '"]').addClass('collapsed');
                    }
                });
            };
            LayerService.prototype.expandAll = function () {
                this.project.groups.forEach(function (g) {
                    var id = '#layergroup_' + g.id;
                    if (!$(id).hasClass('in')) {
                        $(id).collapse('show');
                        $('*[data-target="' + id + '"]').removeClass('collapsed');
                    }
                });
            };
            /** load external type resource for a project or layer */
            LayerService.prototype.loadTypeResources = function (url, requestReload, callback) {
                var _this = this;
                if (url) {
                    // todo check for list of type resources
                    if (typeof url === 'string') {
                        if (!this.typesResources.hasOwnProperty(url) || requestReload) {
                            var success = false;
                            this.$http.get(url)
                                .success(function (resource) {
                                success = true;
                                if (!resource || (typeof resource === 'string' && resource !== 'null')) {
                                    _this.$messageBusService.notifyError('Error loading resource type', url);
                                }
                                else {
                                    var r = resource;
                                    if (r) {
                                        r.url = url;
                                        _this.initTypeResources(r);
                                        _this.$messageBusService.publish('typesource', url, r);
                                    }
                                }
                                callback();
                            })
                                .error(function (err) {
                                _this.$messageBusService.notifyError('ERROR loading TypeResources', 'While loading: ' + url);
                                console.log(err);
                            });
                            setTimeout(function () {
                                if (!success) {
                                    callback();
                                }
                            }, 3000);
                        }
                        else {
                            //make sure featureTypes in typeResources are initialized,
                            //which is not the case when switching projects
                            this.initTypeResources(this.typesResources[url]);
                            callback();
                        }
                    }
                    else {
                        callback();
                    }
                }
            };
            /**
             * returns a list of all project layers in all groups
             */
            LayerService.prototype.allLayers = function () {
                var res = [];
                if (this.project == null || this.project.groups == null)
                    return [];
                this.project.groups.forEach(function (p) {
                    if (p.layers)
                        res = res.concat(p.layers);
                });
                return res;
            };
            /** add a types resource (project, resource file or layer) */
            LayerService.prototype.initTypeResources = function (source) {
                this.typesResources[source.url] = source;
                if (!source.title)
                    source.title = source.url;
                // if url starts with  'api/' this is a dynamic resource
                if (typeof (source.isDynamic) === "undefined") {
                    source.isDynamic = (source.url.indexOf('api/') === 0) || (source.url.indexOf('/api/') === 0);
                }
                var featureTypes = source.featureTypes;
                if (source.propertyTypeData) {
                    for (var key in source.propertyTypeData) {
                        var propertyType = source.propertyTypeData[key];
                        propertyType.id = source.url + '#' + key;
                        this.initPropertyType(propertyType);
                        if (!propertyType.label)
                            propertyType.label = key;
                        // EV Check that this doesn't cause errors when two different resource files define the same key. Shouldn't we use the id?
                        this.propertyTypeData[key] = propertyType;
                    }
                }
                if (featureTypes) {
                    for (var typeName in featureTypes) {
                        var tn = source.url + '#' + typeName;
                        //if (!this._featureTypes.hasOwnProperty(tn)) continue;
                        var featureType = featureTypes[typeName];
                        featureType.id = tn;
                        this.initFeatureType(featureType, source.propertyTypeData);
                        this._featureTypes[tn] = featureType;
                    }
                }
            };
            LayerService.prototype.getLayerPropertyTypes = function (layer) {
                var res = [];
                // TODO Check this - doesn't seem to do anything
                // if (layer.typeUrl && layer.defaultFeatureType) {
                //     var t = this.getFeatureTypeById(layer.typeUrl + '#' + layer.defaultFeatureType);
                //     if (t.propertyTypeKeys) { }
                // }
                return res;
            };
            LayerService.prototype.checkLayerLegend = function (layer, property) {
                var _this = this;
                var ptd = this.propertyTypeData[property];
                if (ptd && ptd.legend) {
                    var gs;
                    if (layer.group.styles && (layer.group.styles.length > 0)) {
                        gs = layer.group.styles[0]; // TODO: when do we need a different one than the first?
                    }
                    else {
                        gs = new Services.GroupStyle(this.$translate);
                        layer.group.styles.push(gs);
                    }
                    gs.title = ptd.title;
                    gs.id = csComp.Helpers.getGuid();
                    gs.activeLegend = ptd.legend;
                    gs.group = layer.group;
                    gs.property = ptd.label;
                    gs.legends[ptd.title] = ptd.legend;
                    gs.colorScales[ptd.title] = ['purple', 'purple'];
                    gs.enabled = true;
                    gs.visualAspect = (ptd.legend.visualAspect)
                        ? ptd.legend.visualAspect
                        : 'strokeColor'; // TODO: let this be read from the propertyTypeData
                    this.saveStyle(layer.group, gs);
                    this.project.features.forEach(function (fe) {
                        if (fe.layer === layer) {
                            _this.calculateFeatureStyle(fe);
                            _this.activeMapRenderer.updateFeature(fe);
                        }
                    });
                    // upon deactivation of the layer? (but other layers can also have active styles)
                    this.mb.publish('updatelegend', 'title', property);
                }
                else {
                    //when no layer is defined, set the given propertytype as styled property (and trigger creating a dynamic legend subsequently)
                    this.project.features.some(function (f) {
                        if (f.properties.hasOwnProperty(property)) {
                            var pt = _this.getPropertyType(f, property);
                            _this.setStyle({ feature: f, property: property, key: pt.title || property });
                            return true;
                        }
                        return false;
                    });
                }
            };
            /**
             * Check whether we need to enable the timer to refresh the layer.
             */
            LayerService.prototype.checkLayerTimer = function (layer) {
                if (!layer.refreshTimeInterval)
                    return;
                if (layer.enabled) {
                    if (!layer.timerToken) {
                        layer.timerToken = setInterval(function () {
                            layer.layerSource.refreshLayer(layer);
                        }, layer.refreshTimeInterval * 1000);
                        console.log("Timer started for " + layer.title + ": " + layer.timerToken);
                    }
                }
                else if (layer.timerToken) {
                    clearInterval(layer.timerToken);
                    layer.timerToken = null;
                }
            };
            LayerService.prototype.removeStyle = function (style) {
                var g = style.group;
                g.styles = g.styles.filter(function (s) { return s.id !== style.id; });
                this.$messageBusService.publish('updatelegend', 'updatedstyle');
                this.updateGroupFeatures(g);
            };
            LayerService.prototype.updatePropertyStyle = function (k, v, parent) {
                // method of class LayerService
                /* k, v is key-value pair of style.colorScales => key is a string */
                /* value is in most cases a list of two strings. actually it is not used in this function */
                /* parent is a ??which class??  ($parent in stylelist.tpl.html) */
                //alert('key = ' + k + '; value = ' + v);
                var l;
                l = parent.style.legends[k];
                if (l && (l.legendEntries.length > 0)) {
                    var e1 = l.legendEntries[0];
                    var e2 = l.legendEntries[l.legendEntries.length - 1];
                    parent.style.colors = [e1.color, e2.color];
                }
                else {
                    parent.style.colors = v;
                }
                parent.style.activeLegend = l;
                this.$messageBusService.publish('updatelegend', 'updatedstyle');
            };
            LayerService.prototype.updateStyle = function (style) {
                //console.log('update style ' + style.title);
                if (style == null)
                    return;
                if (style.property && style.property === 'gridlayer') {
                    if (!style.group || !style.group.layers)
                        return;
                    style.group.layers.forEach(function (l) {
                        if (l.mapLayer && l.enabled) {
                            var mapLayers = l.mapLayer.getLayers();
                            mapLayers.forEach(function (ml) {
                                if (ml.redraw && typeof ml.redraw === 'function') {
                                    ml.params({ minColor: style.colors[0], maxColor: style.colors[1], areColorsUpdated: true });
                                    ml.redraw();
                                }
                            });
                        }
                    });
                }
                else {
                    if (style.group != null && style.group.styles[0] != null) {
                        if (style.group.styles[0].fixedColorRange) {
                            style.info = style.group.styles[0].info;
                        }
                        else {
                            style.info = this.calculatePropertyInfo(style.group, style.property);
                        }
                        style.canSelectColor = style.visualAspect.toLowerCase().indexOf('color') > -1;
                        this.updateGroupFeatures(style.group);
                    }
                }
            };
            LayerService.prototype.updateGroupFeatures = function (group) {
                var _this = this;
                if (!group)
                    return;
                this.project.features.forEach(function (f) {
                    if (f.layer.group === group) {
                        _this.calculateFeatureStyle(f);
                        _this.activeMapRenderer.updateFeature(f);
                    }
                });
            };
            /**
             * Recompute the style of the layer features, e.g. after changing the opacity or after
             * zooming to a level outside the layers' range.
             */
            LayerService.prototype.updateLayerFeatures = function (layer) {
                var _this = this;
                if (!layer)
                    return;
                this.project.features.forEach(function (f) {
                    if (f.layer.id === layer.id) {
                        _this.calculateFeatureStyle(f);
                        _this.activeMapRenderer.updateFeature(f);
                    }
                });
            };
            LayerService.prototype.updateCanvasOverlay = function (layer) {
                if (!layer || !layer.mapLayer)
                    return;
                var mapLayers = layer.mapLayer.getLayers();
                mapLayers.forEach(function (ml) {
                    if (ml.redraw && typeof ml.redraw === 'function') {
                        var layerOpacity = (+layer.opacity) / 100;
                        layerOpacity = Math.min(1, Math.max(0, layerOpacity)); //set bounds to 0 - 1
                        ml.params({ opacity: layerOpacity });
                        ml.redraw();
                    }
                });
            };
            LayerService.prototype.updateFeatureTypes = function (featureType) {
                var _this = this;
                this.project.features.forEach(function (f) {
                    if (f.featureTypeName === featureType.id) {
                        _this.calculateFeatureStyle(f);
                        _this.activeMapRenderer.updateFeature(f);
                    }
                });
            };
            LayerService.prototype.selectRenderer = function (renderer) {
                if (!renderer)
                    return;
                if (this.activeMapRenderer && this.activeMapRenderer.title === renderer)
                    return;
                if (this.mapRenderers.hasOwnProperty(renderer)) {
                    if (this.activeMapRenderer)
                        this.activeMapRenderer.disable();
                    this.activeMapRenderer = this.mapRenderers[renderer];
                    this.activeMapRenderer.enable(this.$mapService.activeBaseLayer);
                }
            };
            LayerService.prototype.centerFeatureOnMap = function (selFeatures) {
                if (!selFeatures || !_.isArray(selFeatures) || selFeatures.length === 0)
                    return;
                var f = selFeatures[0];
                var center;
                if (f.geometry.type.toLowerCase() === 'point') {
                    center = f.geometry.coordinates;
                }
                else {
                    center = csComp.Helpers.GeoExtensions.getCentroid(f.geometry.coordinates);
                }
                this.map.getMap().panTo(new L.LatLng(center.coordinates[1], center.coordinates[0]));
            };
            LayerService.prototype.editFeature = function (feature, select) {
                if (select === void 0) { select = true; }
                feature._gui['editMode'] = true;
                this.updateFeature(feature);
                if (select)
                    this.selectFeature(feature);
            };
            LayerService.prototype.deselectFeature = function (feature) {
                feature.isSelected = false;
                this.calculateFeatureStyle(feature);
                this.activeMapRenderer.updateFeature(feature);
            };
            /** Called when a feature is selected. */
            LayerService.prototype.selectFeature = function (feature, multi, force) {
                var _this = this;
                if (multi === void 0) { multi = false; }
                if (force === void 0) { force = false; }
                if (force) {
                    feature.isSelected = true;
                }
                else {
                    feature.isSelected = !feature.isSelected;
                }
                feature._gui['title'] = csComp.Helpers.getFeatureTitle(feature);
                // deselect last feature and also update
                if (this.lastSelectedFeature != null && this.lastSelectedFeature !== feature && !multi) {
                    this.deselectFeature(this.lastSelectedFeature);
                    this.actionServices.forEach(function (as) { return as.deselectFeature(feature); });
                    this.$messageBusService.publish('feature', 'onFeatureDeselect', this.lastSelectedFeature);
                }
                this.actionServices.forEach(function (as) {
                    if (feature.isSelected) {
                        as.selectFeature(feature);
                    }
                    else {
                        as.deselectFeature(feature);
                    }
                });
                if (feature.isSelected)
                    this.lastSelectedFeature = feature;
                // select new feature, set selected style and bring to front
                this.calculateFeatureStyle(feature);
                this.activeMapRenderer.updateFeature(feature);
                if (multi) {
                    if (feature.isSelected) {
                        if (this.selectedFeatures.indexOf(feature) === -1) {
                            this.selectedFeatures.push(feature);
                        }
                    }
                    else {
                        if (this.selectedFeatures.indexOf(feature) >= 0) {
                            this.selectedFeatures = this.selectedFeatures.filter(function (f) { return f.id !== feature.id; });
                        }
                    }
                }
                else {
                    this.selectedFeatures.forEach(function (f) { if (f !== feature)
                        _this.deselectFeature(f); });
                    this.selectedFeatures = (feature.isSelected) ? [feature] : [];
                }
                if (!feature.isSelected) {
                    this.$messageBusService.publish('feature', 'onFeatureDeselect', feature);
                }
                else {
                    if (!feature.fType.selectActions) {
                        this.actionService.execute('Select feature');
                    }
                    else {
                        feature.fType.selectActions.forEach(function (action) {
                            _this.actionService.execute(action, {
                                layerId: feature.layerId
                            });
                        });
                    }
                    // var rpt = csComp.Helpers.createRightPanelTab('featureprops', 'featureprops', null, 'Selected feature', '{{"FEATURE_INFO" | translate}}', 'info', true);
                    // var rpt = csComp.Helpers.createRightPanelTab('featureprops', 'featureprops', null, 'Selected feature', '{{"FEATURE_INFO" | translate}}', 'info', false, true);
                    // this.$messageBusService.publish('rightpanel', 'activate', rpt);
                    //this.visual.rightPanelVisible = true; // otherwise, the rightpanel briefly flashes open before closing.
                    // var rpt = csComp.Helpers.createRightPanelTab('featurerelations', 'featurerelations', feature, 'Related features', '{{'RELATED_FEATURES' | translate}}', 'link');
                    // this.$messageBusService.publish('rightpanel', 'activate', rpt);
                    // var rpt = csComp.Helpers.createRightPanelTab('featureprops', 'featureprops', feature, 'Selected feature', '{{'FEATURE_INFO' | translate}}', 'info');
                    // this.$messageBusService.publish('rightpanel', 'activate', rpt);
                    this.$messageBusService.publish('feature', 'onFeatureSelect', feature);
                }
            };
            LayerService.prototype.lookupLog = function (logs, timestamp) {
                if (!logs || logs.length === 0)
                    return {};
                var d = logs; //_.sortBy(logs, 'ts');
                if (timestamp <= d[0].ts)
                    return d[0];
                if (timestamp >= d[logs.length - 1].ts)
                    return d[d.length - 1];
                var res = {};
                for (var i = 0; i < d.length; i++) {
                    if (d[i].ts > timestamp) {
                        res = d[i];
                        break;
                    }
                }
                return res;
            };
            LayerService.prototype.updateLog = function (f) {
                var date = this.project.timeLine.focus;
                var changed = false;
                if (f.logs && !this.isLocked(f)) {
                    // find all keys
                    for (var key in f.logs) {
                        // lookup value
                        var l = this.lookupLog(f.logs[key], date);
                        if (key === '~geometry') {
                            if (l.value !== f.geometry) {
                                f.geometry = l.value;
                                changed = true;
                            }
                        }
                        else {
                            if (!f.properties.hasOwnProperty(key)) {
                                f.properties[key] = l.value;
                                changed = true;
                            }
                            else {
                                if (f.properties[key] !== l.value) {
                                    f.properties[key] = l.value;
                                    changed = true;
                                }
                            }
                        }
                    }
                    if (changed) {
                        this.updateFeature(f);
                    }
                }
            };
            LayerService.prototype.updateFeature = function (feature) {
                this.calculateFeatureStyle(feature);
                this.activeMapRenderer.updateFeature(feature);
                if (feature === this.lastSelectedFeature) {
                    this.$messageBusService.publish('feature', 'onFeatureUpdated');
                }
            };
            LayerService.prototype.getSensorIndex = function (d, timestamps) {
                for (var i = 1; i < timestamps.length; i++) {
                    if (timestamps[i] > d) {
                        return i - 1;
                    }
                }
                return timestamps.length - 1;
            };
            ;
            /// calculate sensor data for a specific feature
            LayerService.prototype.updateFeatureSensorData = function (f, date) {
                var l = f.layer;
                if (f.sensors || f.coordinates) {
                    var pos = 0;
                    if (f.timestamps) {
                        pos = this.getSensorIndex(date, f.timestamps);
                    }
                    else if (l.timestamps) {
                        if (l._gui.hasOwnProperty("timestampIndex")) {
                            pos = l._gui["timestampIndex"];
                        }
                        else {
                            pos = this.getSensorIndex(date, l.timestamps);
                            l._gui["timestampIndex"] = pos;
                            l._gui["timestamp"] = l.timestamps[pos];
                        }
                    }
                    // check if a new coordinate is avaiable
                    if (f.coordinates && f.geometry && f.coordinates.length > pos && f.coordinates[pos] !== f.geometry.coordinates) {
                        f.geometry.coordinates = f.coordinates[pos];
                        // get marker
                        if (l.group.markers.hasOwnProperty(f.id)) {
                            var m = l.group.markers[f.id];
                            // update position
                            m.setLatLng(new L.LatLng(f.geometry.coordinates[1], f.geometry.coordinates[0]));
                        }
                    }
                    if (f.sensors) {
                        for (var sensorTitle in f.sensors) {
                            var sensor = f.sensors[sensorTitle];
                            var value = sensor[pos];
                            f.properties[sensorTitle] = value;
                        }
                        this.calculateFeatureStyle(f);
                        this.activeMapRenderer.updateFeature(f);
                        if (f.isSelected)
                            this.$messageBusService.publish('feature', 'onFeatureUpdated', f);
                    }
                }
            };
            LayerService.prototype.updateLayerSensorData = function (l, date) {
                var _this = this;
                delete l._gui["timestampIndex"];
                delete l._gui["timestamp"];
                if ((l.hasSensorData || l.sensorLink) && l.data.features) {
                    l.data.features.forEach(function (f) {
                        _this.updateFeatureSensorData(f, date);
                    });
                    this.mb.publish("layer", "sensordataUpdated", l);
                }
                if (l.isDynamic && l.useLog) {
                    l.data.features.forEach(function (f) {
                        _this.updateLog(f);
                    });
                }
            };
            /** update for all features the active sensor data values and update styles */
            LayerService.prototype.updateSensorData = function () {
                if (this.project == null || this.project.timeLine == null || this.project.features == null)
                    return;
                var date = this.project.timeLine.focus;
                for (var ll in this.loadedLayers) {
                    var l = this.loadedLayers[ll];
                    if (this.project.activeDashboard.isLive) {
                        if (!_.isUndefined(l.timestamps) && _.isArray(l.timestamps)) {
                            date = l.timestamps[l.timestamps.length - 1];
                            this.updateLayerSensorData(l, date);
                        }
                    }
                    else {
                        this.updateLayerSensorData(l, date);
                    }
                }
                ;
            };
            /***
             * get list of properties that are part of the filter collection
             */
            LayerService.prototype.filterProperties = function (group) {
                var result = [];
                if (group.filters != null && group.filters.length > 0) {
                    group.filters.forEach(function (f) {
                        result.push(f.property);
                    });
                }
                ;
                return result;
            };
            /**
             * init feature (add to feature list, crossfilter)
             */
            LayerService.prototype.initFeature = function (feature, layer, applyDigest, publishToTimeline) {
                if (applyDigest === void 0) { applyDigest = false; }
                if (publishToTimeline === void 0) { publishToTimeline = true; }
                if (!feature._isInitialized) {
                    feature._isInitialized = true;
                    feature.type = "Feature";
                    feature._gui = {
                        included: true
                    };
                    if (!feature.logs)
                        feature.logs = {};
                    if (feature.properties == null)
                        feature.properties = {};
                    feature.index = layer.count++;
                    // make sure it has an id
                    if (feature.id == null)
                        feature.id = csComp.Helpers.getGuid();
                    feature.layerId = layer.id;
                    feature.layer = layer;
                    // add feature to global list of features
                    this.project.features.push(feature);
                    // add to crossfilter
                    layer.group.ndx.add([feature]);
                    // resolve feature type
                    feature.fType = this.getFeatureType(feature);
                    if (!feature.properties.hasOwnProperty('Name'))
                        csComp.Helpers.setFeatureName(feature, this.propertyTypeData);
                    if (feature.sensors) {
                        for (var s in feature.sensors) {
                            var propType = this.getPropertyType(feature, s);
                            if (propType && propType.sensorNull)
                                for (var i = 0; i < feature.sensors[s].length; i++) {
                                    if (feature.sensors[s][i] === propType.sensorNull)
                                        feature.sensors[s][i] = 0;
                                }
                        }
                    }
                    this.calculateFeatureStyle(feature);
                    feature.propertiesOld = {};
                    if (layer.useLog)
                        this.trackFeature(feature);
                    if (applyDigest)
                        this.apply();
                    if (layer.timeAware && publishToTimeline)
                        this.$messageBusService.publish('timeline', 'updateFeatures');
                }
                return feature.fType;
            };
            /** remove feature */
            LayerService.prototype.removeFeature = function (feature, save) {
                if (save === void 0) { save = false; }
                this.project.features = this.project.features.filter(function (f) { return f !== feature; });
                feature.layer.data.features = feature.layer.data.features.filter(function (f) { return f !== feature; });
                if (feature.layer.group.filterResult)
                    feature.layer.group.filterResult = feature.layer.group.filterResult.filter(function (f) { return f !== feature; });
                feature.layer.group.ndx.remove([feature]);
                this.activeMapRenderer.removeFeature(feature);
                this.$messageBusService.publish('feature', 'onFeatureRemoved', feature);
                if (save && feature.layer.isDynamic) {
                    var s = new LayerUpdate();
                    s.layerId = feature.layerId;
                    s.action = LayerUpdateAction.deleteFeature;
                    s.item = feature.id;
                    this.$messageBusService.serverSendMessageAction('layer', s);
                }
            };
            /**
            * Calculate the effective feature style.
            */
            LayerService.prototype.calculateFeatureStyle = function (feature) {
                var s = csComp.Helpers.getDefaultFeatureStyle(feature);
                var ft = this.getFeatureType(feature);
                var style = ft.style;
                var properties = feature.properties;
                if (style) {
                    if (style.nameLabel)
                        s.nameLabel = style.nameLabel;
                    if (style.marker)
                        s.marker = style.marker;
                    if (style.iconUri)
                        s.iconUri = style.iconUri;
                    if (style.fillOpacity >= 0)
                        s.fillOpacity = style.fillOpacity;
                    if (style.strokeOpacity >= 0)
                        s.strokeOpacity = style.strokeOpacity;
                    if (style.opacity >= 0)
                        s.opacity = style.opacity;
                    if (style.fillColor)
                        s.fillColor = csComp.Helpers.getColorString(style.fillColor);
                    // Stroke is a boolean property, so you have to check whether it is undefined.
                    if (typeof style.stroke !== 'undefined')
                        s.stroke = style.stroke;
                    if (style.strokeColor)
                        s.strokeColor = csComp.Helpers.getColorString(style.strokeColor, '#fff');
                    // StrokeWidth can be 0 (interpreted as false), so you have to check whether it is undefined.
                    if (typeof style.strokeWidth !== 'undefined')
                        s.strokeWidth = style.strokeWidth;
                    if (style.selectedStrokeColor)
                        s.selectedStrokeColor = csComp.Helpers.getColorString(style.selectedStrokeColor, '#000');
                    if (style.selectedFillColor)
                        s.selectedFillColor = csComp.Helpers.getColorString(style.selectedFillColor);
                    if (style.selectedStrokeWidth)
                        s.selectedStrokeWidth = style.selectedStrokeWidth;
                    if (style.iconWidth)
                        s.iconWidth = style.iconWidth;
                    if (style.iconHeight)
                        s.iconHeight = style.iconHeight;
                    if (style.heightAboveSeaProperty)
                        s.heightAboveSeaProperty = style.heightAboveSeaProperty;
                    if (style.modelUri)
                        s.modelUri = style.modelUri;
                    if (style.modelScale)
                        s.modelScale = style.modelScale;
                    if (style.modelMinimumPixelSize)
                        s.modelMinimumPixelSize = style.modelMinimumPixelSize;
                    if (style.innerTextProperty)
                        s.innerTextProperty = style.innerTextProperty;
                    if (style.innerTextSize)
                        s.innerTextSize = style.innerTextSize;
                    if (style.cornerRadius)
                        s.cornerRadius = style.cornerRadius;
                    if (style.rotateProperty && properties.hasOwnProperty(style.rotateProperty)) {
                        s.rotate = Number(properties[style.rotateProperty]);
                    }
                    if (style.heightProperty && properties.hasOwnProperty(style.heightProperty)) {
                        s.height = Number(properties[style.heightProperty]);
                    }
                    else {
                        s.height = style.height;
                    }
                    // For Cesium
                    if (style.modelUriProperty && properties.hasOwnProperty(style.modelUriProperty)) {
                        s.modelUri = properties[style.modelUriProperty];
                    }
                    else {
                        s.modelUri = style.modelUri;
                    }
                    if (style.modelScaleProperty && properties.hasOwnProperty(style.modelScaleProperty)) {
                        s.modelScale = properties[style.modelScaleProperty];
                    }
                    else {
                        s.modelScale = style.modelScale;
                    }
                    if (style.modelMinimumPixelSizeProperty && properties.hasOwnProperty(style.modelMinimumPixelSizeProperty)) {
                        s.modelMinimumPixelSize = properties[style.modelMinimumPixelSizeProperty];
                    }
                    else {
                        s.modelMinimumPixelSize = style.modelMinimumPixelSize;
                    }
                }
                feature._gui['style'] = {};
                if (feature.layer) {
                    s.opacity = (feature.layer.isTransparent) ? 0 : s.opacity * (feature.layer.opacity / 100);
                    s.fillOpacity = (feature.layer.isTransparent) ? 0 : s.fillOpacity * (feature.layer.opacity / 100);
                }
                if (feature.layer && feature.layer.group && feature.layer.group.styles) {
                    feature.layer.group.styles.forEach(function (gs) {
                        if (gs.enabled && feature.properties.hasOwnProperty(gs.property)) {
                            //delete feature.gui[gs.property];
                            var v = Number(feature.properties[gs.property]);
                            try {
                                if (!isNaN(v)) {
                                    switch (gs.visualAspect) {
                                        case 'strokeColor':
                                            s.strokeColor = csComp.Helpers.getColor(v, gs);
                                            feature._gui['style'][gs.property] = s.strokeColor;
                                            break;
                                        case 'fillColor':
                                            s.fillColor = csComp.Helpers.getColor(v, gs);
                                            feature._gui['style'][gs.property] = s.fillColor;
                                            if (feature.geometry && feature.geometry.type && feature.geometry.type.toLowerCase() === 'linestring') {
                                                s.strokeColor = s.fillColor; //s.strokeColor = s.fillColor;
                                            }
                                            break;
                                        case 'strokeWidth':
                                            s.strokeWidth = ((v - gs.info.min) / (gs.info.max - gs.info.min) * 10) + 1;
                                            break;
                                        case 'height':
                                            s.height = ((v - gs.info.min) / (gs.info.max - gs.info.min) * 25000);
                                            break;
                                    }
                                }
                                else {
                                    var ss = feature.properties[gs.property];
                                    switch (gs.visualAspect) {
                                        case 'strokeColor':
                                            s.strokeColor = csComp.Helpers.getColorFromStringValue(ss, gs);
                                            feature._gui['style'][gs.property] = s.strokeColor;
                                            break;
                                        case 'fillColor':
                                            s.fillColor = csComp.Helpers.getColorFromStringValue(ss, gs);
                                            feature._gui['style'][gs.property] = s.fillColor;
                                            break;
                                    }
                                }
                            }
                            catch (e) {
                                console.log('Error setting style for feature ' + e.message);
                            }
                        }
                    });
                }
                if (feature.isSelected) {
                    s.strokeWidth = s.selectedStrokeWidth || 3;
                    s.strokeColor = s.selectedStrokeColor || 'black';
                    if (s.selectedFillColor)
                        s.fillColor = s.selectedFillColor;
                }
                feature.effectiveStyle = s;
            };
            /**
            * Initialize the feature type and its property types by setting default property values, and by localizing it.
            */
            LayerService.prototype.initFeatureType = function (ft, propertyTypes) {
                if (ft._isInitialized)
                    return;
                ft._isInitialized = true;
                this.initIconUri(ft);
                if (ft.languages != null && this.currentLocale in ft.languages) {
                    var locale = ft.languages[this.currentLocale];
                    if (locale.name)
                        ft.name = locale.name;
                }
                if (!ft._propertyTypeData || ft._propertyTypeData.length === 0) {
                    ft._propertyTypeData = [];
                    if (ft.propertyTypeKeys && ft.propertyTypeKeys.length > 0) {
                        ft.propertyTypeKeys.split(/[,;]+/).forEach(function (key) {
                            if (propertyTypes && propertyTypes.hasOwnProperty(key))
                                ft._propertyTypeData.push(propertyTypes[key]);
                        });
                    }
                }
            };
            /** Set the iconUri for remote servers (newIconUri = server/oldIconUri) */
            LayerService.prototype.initIconUri = function (ft) {
                if (!ft.style.iconUri)
                    return;
                var testForRemoteServerRegex = /^(http[s]?:\/\/[:a-zA-Z0-9_\.]+)\/.*$/g;
                var matches = testForRemoteServerRegex.exec(ft.id);
                if (matches && matches.length > 1) {
                    ft.style.iconUri = matches[1] + "/" + ft.style.iconUri;
                }
            };
            /**
            * Initialize the property type with default values, and, if applicable, localize it.
            */
            LayerService.prototype.initPropertyType = function (pt) {
                this.setDefaultPropertyType(pt);
                if (pt.languages != null)
                    this.localizePropertyType(pt);
            };
            /**
            * Set default PropertyType's properties:
            * type              = text
            * visibleInCallout  = true
            * canEdit           = false
            * isSearchable      = true
            */
            LayerService.prototype.setDefaultPropertyType = function (pt) {
                if (!pt.type)
                    pt.type = 'text';
                if (typeof pt.title === 'undefined')
                    pt.title = pt.label;
                if (typeof pt.canEdit === 'undefined')
                    pt.canEdit = false;
                if (typeof pt.visibleInCallOut === 'undefined')
                    pt.visibleInCallOut = true;
                if (typeof pt.isSearchable === 'undefined' && pt.type === 'text')
                    pt.isSearchable = true;
                if (pt.options && _.isArray(pt.options)) {
                    var oo = pt.options;
                    pt.options = {};
                    var i = 0;
                    oo.forEach(function (o) {
                        pt.options[i] = o;
                        i += 1;
                    });
                }
            };
            LayerService.prototype.localizePropertyType = function (pt) {
                if (pt.languages != null && this.currentLocale in pt.languages) {
                    var locale = pt.languages[this.currentLocale];
                    if (locale.title)
                        pt.title = locale.title;
                    if (locale.description)
                        pt.description = locale.description;
                    if (locale.section)
                        pt.section = locale.section;
                    if (locale.options != null)
                        pt.options = locale.options;
                }
                ;
            };
            LayerService.prototype.findResourceByLayer = function (layer) {
                if (layer && layer.typeUrl) {
                    if (this.typesResources.hasOwnProperty(layer.typeUrl)) {
                        return this.typesResources[layer.typeUrl];
                    }
                    else
                        return null;
                }
                else
                    return null;
            };
            LayerService.prototype.findResourceByFeature = function (feature) {
                if (feature.layer && feature.layer.typeUrl) {
                    var typeUrl = feature.layer.typeUrl;
                    if (this.typesResources.hasOwnProperty(typeUrl)) {
                        return this.typesResources[typeUrl];
                    }
                    else
                        return null;
                }
                else
                    return null;
            };
            LayerService.prototype.findPropertyTypeById = function (id) {
                if (id.indexOf('#') === -1)
                    return null;
                for (var r in this.typesResources) {
                    if (id.indexOf(r) === 0) {
                        var res = this.typesResources[r].propertyTypeData;
                        var k = id.split('#')[1];
                        if (res.hasOwnProperty(k))
                            return res[k];
                    }
                }
                return null;
            };
            /**
             * find a filter for a specific group/property combination
             */
            LayerService.prototype.findFilter = function (group, property) {
                if (!group || !property)
                    return;
                if (group.filters == null)
                    group.filters = [];
                var r = group.filters.filter(function (f) { return f.property === property; });
                if (r.length > 0)
                    return r[0];
                return null;
            };
            /**
             * Find a feature by layerId and FeatureId.
             * @layerId {string}
             * @featureIndex {number}
             */
            LayerService.prototype.findFeatureByIndex = function (layerId, featureIndex) {
                for (var i = 0; i < this.project.features.length; i++) {
                    var feature = this.project.features[i];
                    if (featureIndex === feature.index && layerId === feature.layerId)
                        return feature;
                }
            };
            /**
             * Find a feature by layerId and FeatureId.
             * @layerId {string}
             * @featureIndex {number}
             */
            LayerService.prototype.findFeatureById = function (featureId) {
                return _.find(this.project.features, function (f) { return f.id === featureId; });
            };
            /**
             * Find a feature by layerId and FeatureId.
             * @property {string}
             * @value {number}
             */
            LayerService.prototype.findFeatureByPropertyValue = function (property, value) {
                return _.find(this.project.features, function (f) { return f.properties.hasOwnProperty(property) && f.properties[property] === value; });
            };
            /**
             * Find a feature by layerId and FeatureId.
             * @layer {ProjectLayer}
             * @featureId {number}
             */
            LayerService.prototype.findFeature = function (layer, featureId) {
                if (!layer.data || !layer.data.features)
                    return null;
                return _.find(layer.data.features, function (f) { return f.id === featureId; });
            };
            /**
             * Find a group by id
             */
            LayerService.prototype.findGroupById = function (id) {
                for (var i = 0; i < this.project.groups.length; i++) {
                    if (this.project.groups[i].id === id)
                        return this.project.groups[i];
                }
                return null;
            };
            /**
             * Find a group by id
             */
            LayerService.prototype.findGroupByLayerId = function (layer) {
                if (!layer.id)
                    return null;
                var matchedGroup;
                this.project.groups.some(function (group) {
                    if (group.layers) {
                        group.layers.some(function (l) {
                            if (l.id === layer.id) {
                                matchedGroup = group;
                                return true;
                            }
                            return false;
                        });
                    }
                    if (matchedGroup)
                        return true;
                    return false;
                });
                return matchedGroup;
            };
            /**
             * Find the feature by name.
             */
            LayerService.prototype.findFeatureByName = function (name) {
                for (var i = 0; i < this.project.features.length; i++) {
                    var feature = this.project.features[i];
                    if (feature.hasOwnProperty('Name') && name === feature.properties['Name'])
                        return feature;
                }
            };
            /**
            * Find a loaded layer with a specific id.
            */
            LayerService.prototype.findLoadedLayer = function (id) {
                if (this.loadedLayers.hasOwnProperty(id))
                    return this.loadedLayers[id];
                return null;
            };
            /**
             * Find a layer with a specific id.
             */
            LayerService.prototype.findLayer = function (id) {
                if (this.loadedLayers.hasOwnProperty(id))
                    return this.loadedLayers[id];
                //return null;
                var r;
                this.project.groups.forEach(function (g) {
                    g.layers.forEach(function (l) {
                        if (l.id === id) {
                            r = l;
                        }
                    });
                });
                return r;
            };
            LayerService.prototype.setGroupStyle = function (group, property) {
                var _this = this;
                if (typeof property === 'undefined' || property === null)
                    return;
                if (typeof group === 'undefined' || group === null)
                    return;
                var gs = new Services.GroupStyle(this.$translate);
                gs.id = csComp.Helpers.getGuid();
                gs.title = property.title;
                gs.visualAspect = 'fillColor';
                gs.canSelectColor = gs.visualAspect.toLowerCase().indexOf('color') > -1;
                gs.info = this.calculatePropertyInfo(group, property.label);
                gs.enabled = true;
                gs.property = property.label;
                gs.group = group;
                if (property.legend) {
                    gs.activeLegend = property.legend;
                }
                else {
                    gs.colors = ['white', '#FF5500'];
                }
                this.saveStyle(group, gs);
                this.project.features.forEach(function (fe) {
                    if (fe.layer.group === group) {
                        _this.calculateFeatureStyle(fe);
                        _this.activeMapRenderer.updateFeature(fe);
                    }
                });
                this.$messageBusService.publish('updatelegend', 'updatedstyle', gs);
            };
            LayerService.prototype.setStyleForProperty = function (layer, property) {
                this.setStyle({
                    feature: {
                        featureTypeName: layer.url + '#' + property,
                        layer: layer
                    },
                    property: property,
                    key: property,
                }, false);
            };
            /**
             * Creates a GroupStyle based on a property and adds it to a group.
             * If the group already has a style which contains legends, those legends are copied into the newly created group.
             * Already existing groups (for the same visualAspect) are replaced by the new group.
             * Restoring a previously used groupstyle is possible by sending that GroupStyle object.
             */
            LayerService.prototype.setStyle = function (property, openStyleTab, customStyleInfo, groupStyle) {
                var _this = this;
                if (openStyleTab === void 0) { openStyleTab = false; }
                // parameter property is of the type ICallOutProperty. explicit declaration gives the red squigglies
                var f = property.feature;
                if (f != null) {
                    var ft = this.getFeatureType(f);
                    // use the groupstyle that was passed along, or create a new groupstyle if none is present
                    var gs;
                    if (groupStyle) {
                        gs = groupStyle;
                        gs.info = this.calculatePropertyInfo(f.layer.group, property.property);
                    }
                    else {
                        gs = new Services.GroupStyle(this.$translate);
                        gs.id = csComp.Helpers.getGuid();
                        gs.title = property.key;
                        gs.meta = property.meta;
                        gs.visualAspect = (ft.style && ft.style.drawingMode && ft.style.drawingMode.toLowerCase() === 'line')
                            ? 'strokeColor'
                            : 'fillColor';
                        gs.canSelectColor = gs.visualAspect.toLowerCase().indexOf('color') > -1;
                        gs.property = property.property;
                        if (customStyleInfo) {
                            gs.info = customStyleInfo;
                            gs.fixedColorRange = true;
                        }
                        else {
                            if (gs.info == null)
                                gs.info = this.calculatePropertyInfo(f.layer.group, property.property);
                        }
                        gs.enabled = true;
                        gs.group = f.layer.group;
                        gs.meta = property.meta;
                        var ptd = this.propertyTypeData[property.property];
                        if (ptd && ptd.legend) {
                            gs.activeLegend = ptd.legend;
                            if (ptd.legend.visualAspect)
                                gs.visualAspect = ptd.legend.visualAspect;
                            gs.legends[ptd.title] = ptd.legend;
                            gs.colorScales[ptd.title] = ['purple', 'purple'];
                        }
                        if (ft.style && ft.style.fillColor) {
                            gs.colors = ['white', '#FF5500'];
                        }
                        else {
                            gs.colors = ['red', 'white', 'blue'];
                        }
                    }
                    this.saveStyle(f.layer.group, gs);
                    this.project.features.forEach(function (fe) {
                        if (fe.layer.group === f.layer.group) {
                            _this.calculateFeatureStyle(fe);
                            _this.activeMapRenderer.updateFeature(fe);
                        }
                    });
                    if (openStyleTab)
                        $('#leftPanelTab a[data-target="#styles"]').tab('show'); // Select tab by name
                    this.$messageBusService.publish('updatelegend', 'updatedstyle', gs);
                    return gs;
                }
                return null;
            };
            LayerService.prototype.toggleStyle = function (property, group, openStyleTab, customStyleInfo) {
                var _this = this;
                if (openStyleTab === void 0) { openStyleTab = false; }
                var s = property.feature.layer.group.styles;
                if (!s.some(function (s) { return s.property === property.property; })) {
                    this.setStyle(property, openStyleTab, customStyleInfo);
                }
                else {
                    s.filter(function (s) { return s.property === property.property; }).forEach(function (st) { return _this.removeStyle(st); });
                }
                this.$messageBusService.publish('updatelegend', 'updatedstyle');
            };
            /**
             * checks if there are other styles that affect the same visual aspect, removes them (it)
             * and then adds the style to the group's styles
             */
            LayerService.prototype.saveStyle = function (group, style) {
                var oldStyles = group.styles.filter(function (s) { return s.visualAspect === style.visualAspect; });
                if (oldStyles.length > 0) {
                    var pos = group.styles.indexOf(oldStyles[0]);
                    group.styles.splice(pos, 1); // RS, 2015-04-04: why delete only one style? (what if oldStyles.length > 1)
                }
                group.styles.push(style);
            };
            /** checks if there are any filters available, used to show/hide filter tab leftpanel menu */
            LayerService.prototype.updateFilterAvailability = function () {
                var _this = this;
                this.noFilters = true;
                this.project.groups.forEach(function (g) {
                    if (g.filters.length > 0 && _this.noFilters)
                        _this.noFilters = false;
                });
            };
            LayerService.prototype.addFilter = function (group, prop) {
                var filter = this.findFilter(group, prop);
                if (filter == null) {
                    var gf = new Services.GroupFilter();
                    gf.property = prop;
                    //gf.filterType = 'row';
                    gf.title = prop;
                    gf.rangex = [0, 1];
                    group.filters.push(gf);
                }
                else {
                    var pos = group.filters.indexOf(filter);
                    if (pos !== -1)
                        group.filters.slice(pos, 1);
                }
                $('#leftPanelTab a[data-target="#filters"]').tab('show'); // Select tab by name
            };
            /**
             * enable a filter for a specific property
             */
            LayerService.prototype.setFilter = function (filter, group) {
                filter.group = group;
                group.filters.push(filter);
                $('#leftPanelTab a[data-target="#filters"]').tab('show'); // Select tab by name
                this.triggerUpdateFilter(group.id);
            };
            LayerService.prototype.setLocationFilter = function (group) {
                if (group.filters.some(function (f) { return f.filterType === 'location'; }))
                    return;
                var gf = new Services.GroupFilter();
                gf.id = csComp.Helpers.getGuid();
                gf.group = group;
                gf.filterType = 'location';
                gf.title = 'Location';
                gf.rangex = [0, 1];
                group.filters.push(gf);
                $('#leftPanelTab a[data-target="#filters"]').tab('show'); // Select tab by name
                this.triggerUpdateFilter(group.id);
            };
            LayerService.prototype.setFeatureAreaFilter = function (f) {
                this.project.groups.forEach(function (g) {
                    if (g.id === f.layer.group.id)
                        return;
                    if (!g.filters.some(function (f) { return f.filterType === 'area'; })) {
                        var gf = new Services.GroupFilter();
                        gf.id = csComp.Helpers.getGuid();
                        gf.group = g;
                        gf.filterType = 'area';
                        gf.title = 'Area';
                        gf.rangex = [0, 1];
                        gf.value = f;
                        g.filters.push(gf);
                        g.filterResult = g.filterResult || [];
                    }
                });
                // if (this.$rootScope.$root.$$phase != '$apply' && this.$rootScope.$root.$$phase != '$digest') { this.$rootScope.$apply(); }
                this.triggerUpdateFilter(f.layer.group.id);
            };
            LayerService.prototype.resetFeatureAreaFilter = function () {
                var _this = this;
                this.project.groups.forEach(function (g) {
                    g.filters.some(function (f) {
                        if (f.filterType === 'area') {
                            _this.removeFilter(f);
                            return true;
                        }
                        return false;
                    });
                });
            };
            /**
            * enable a filter for a specific property
            */
            LayerService.prototype.setPropertyFilter = function (property) {
                var prop = property.property;
                var f = property.feature;
                if (f != null) {
                    var layer = f.layer;
                    if (layer != null) {
                        var filter = this.findFilter(layer.group, prop);
                        if (filter == null) {
                            var gf = new Services.GroupFilter();
                            gf.property = prop;
                            gf.id = csComp.Helpers.getGuid();
                            gf.group = layer.group;
                            gf.meta = property.propertyType;
                            gf.filterType = 'bar';
                            if (gf.meta != null) {
                                if (gf.meta.filterType != null) {
                                    gf.filterType = gf.meta.filterType;
                                }
                                else {
                                    switch (gf.meta.type) {
                                        case 'boolean':
                                            gf.filterType = 'boolean';
                                            break;
                                        case 'date':
                                            gf.filterType = 'date';
                                            break;
                                        case 'number':
                                            gf.filterType = 'bar';
                                            break;
                                        case 'options':
                                            gf.filterType = 'row';
                                            gf.filterLabel = f.properties[prop];
                                            break;
                                        //case 'rank':
                                        //    gf.filterType  = 'bar';
                                        //    gf.value = property.value.split(',')[0];
                                        //    break;
                                        case 'text':
                                            gf.filterType = 'row';
                                            gf.filterLabel = f.properties[prop];
                                            break;
                                        default:
                                            gf.filterType = 'text';
                                            gf.stringValue = property.value;
                                            gf.value = property.value;
                                            break;
                                    }
                                }
                            }
                            gf.title = property.key;
                            gf.rangex = [0, 1];
                            // add filter
                            layer.group.filters.push(gf);
                        }
                        else {
                            this.removeFilter(filter);
                        }
                    }
                    $('#leftPanelTab a[data-target="#filters"]').tab('show'); // Select tab by name
                }
                this.triggerUpdateFilter(layer.group.id);
            };
            LayerService.prototype.createScatterFilter = function (group, prop1, prop2) {
                //console.log('create scatter ' + prop1 + '-' + prop2);
                var gf = new Services.GroupFilter();
                gf.property = prop1;
                gf.property2 = prop2;
                gf.id = csComp.Helpers.getGuid();
                gf.group = group;
                //gf.meta = property.meta;
                gf.filterType = 'scatter';
                // if (gf.meta != null) {
                //     if (gf.meta.filterType != null) {
                //         gf.filterType = gf.meta.filterType;
                //     } else {
                //         switch (gf.meta.type) {
                //             case 'date':
                //                 gf.filterType = 'date';
                //                 break;
                //             case 'number':
                //             case 'options':
                //                 gf.filterType = 'bar';
                //                 break;
                //             //case 'rank':
                //             //    gf.filterType  = 'bar';
                //             //    gf.value = property.value.split(',')[0];
                //             //    break;
                //             default:
                //                 gf.filterType = 'text';
                //                 gf.stringValue = property.value;
                //                 gf.value = property.value;
                //                 break;
                //         }
                //     }
                // }
                gf.title = 'Scatter';
                gf.rangex = [0, 1];
                // add filter
                group.filters.push(gf);
                $('#leftPanelTab a[data-target="#filters"]').tab('show'); // Select tab by name
                this.triggerUpdateFilter(group.id);
            };
            LayerService.prototype.triggerUpdateFilter = function (groupId) {
                this.mb.publish('filters', 'updated', groupId);
                this.updateFilterAvailability();
            };
            /** remove filter from group */
            LayerService.prototype.removeFilter = function (filter) {
                // dispose crossfilter dimension
                filter.group.filterResult = filter.dimension.filterAll().top(Infinity);
                filter.dimension.dispose();
                filter.group.filters = filter.group.filters.filter(function (f) { return f !== filter; });
                this.resetMapFilter(filter.group);
                this.updateMapFilter(filter.group);
                this.triggerUpdateFilter(filter.group.id);
            };
            /**
             * Returns PropertyType for a specific property in a feature
             */
            LayerService.prototype.getPropertyType = function (feature, property) {
                var res;
                // search for local propertytypes in featuretype
                if (feature.fType && feature.fType._propertyTypeData && feature.fType._propertyTypeData.length > 0) {
                    res = _.find(feature.fType._propertyTypeData, function (pt) { return pt.label === property; });
                    if (res)
                        return res;
                }
                if (!feature.layer.typeUrl || !this.typesResources.hasOwnProperty(feature.layer.typeUrl))
                    return res;
                // if (feature.fType.propertyTypeKeys && typeof feature.fType.propertyTypeKeys === 'string') {
                //     feature.fType.propertyTypeKeys.split(';').forEach((key: string) => {
                //         if (rt.propertyTypeData.hasOwnProperty(key) && rt.propertyTypeData[key].label === property) res = rt.propertyTypeData[key];
                //     });
                // }
                if (!res) {
                    var rt = this.typesResources[feature.layer.typeUrl];
                    res = _.find(rt.propertyTypeData, function (pt) { return pt.label === property; });
                }
                return res;
            };
            /**
            Returns the featureTypeId for specific feature.
            It looks for the FeatureTypeId property, defaultFeatureType of his layer
            and checks if it should be found in a resource file or within his own layer
            */
            LayerService.prototype.getFeatureTypeId = function (feature) {
                if (!feature.hasOwnProperty('layer'))
                    feature['layer'] = new Services.ProjectLayer();
                var ftId = feature.properties['FeatureTypeId'] || feature.properties['featureTypeId'] || feature.layer.defaultFeatureType || 'Default';
                // if (name.toLowerCase().startsWith('http://')) return name;
                // if (csComp.Helpers.startsWith(name.toLowerCase(), 'http://')) return name;
                if (/^http:\/\//.test(ftId.toLowerCase()))
                    return ftId;
                if (feature.layer.typeUrl)
                    return feature.layer.typeUrl + '#' + ftId;
                return feature.layer.url
                    ? feature.layer.url + '#' + ftId
                    : this.project.url + '#' + ftId;
            };
            /**
             * Find a feature type by its ID (of the format 'featuretypeurl + # + featuretypename').
             * If it does not exist, return null.
             */
            LayerService.prototype.getFeatureTypeById = function (featureTypeId) {
                if (this._featureTypes.hasOwnProperty(featureTypeId)) {
                    return this._featureTypes[featureTypeId];
                }
                else {
                    return;
                }
            };
            /**
             * Return the feature style for a specific feature.
             * First, look for a layer specific feature type, otherwise, look for a project-specific feature type.
             * In case both fail, create a default feature type at the layer level.
             *
             * If the feature type contains a _{xxx} part, replace the {xxx} with the value of feature.property['xxx']
             * if it exists, otherwise remove it.
             */
            LayerService.prototype.getFeatureType = function (feature) {
                if (!feature.featureTypeName) {
                    feature.featureTypeName = this.getFeatureTypeId(feature);
                }
                var isPropertyBasedFeatureType = feature.featureTypeName.indexOf('_{') >= 0;
                if (!isPropertyBasedFeatureType && feature.fType)
                    return feature.fType;
                var featureTypeName = feature.featureTypeName;
                if (isPropertyBasedFeatureType) {
                    // Feature type depends on a property, so substite the property placeholder with its value,
                    // e.g. featureTypeId='default_{state}', and property state='failed', look for featureTypeId=default_failed
                    // If state is not defined, featureTypeId=default.
                    var re = /_{([a-zA-Z_0-9]+)}/g;
                    var matches = re.exec(featureTypeName);
                    if (matches) {
                        for (var i = 1; i < matches.length; i++) {
                            var match = matches[i];
                            featureTypeName = feature.properties.hasOwnProperty(match)
                                ? featureTypeName.replace("{" + match + "}", feature.properties[match])
                                : featureTypeName.replace("_{" + match + "}", '');
                        }
                    }
                }
                if (!this._featureTypes.hasOwnProperty(featureTypeName)) {
                    this.createMissingFeatureType(feature);
                }
                feature.fType = this._featureTypes[featureTypeName];
                return feature.fType;
            };
            LayerService.prototype.createMissingFeatureType = function (feature) {
                var _this = this;
                var ftKeys = Object.getOwnPropertyNames(this._featureTypes);
                var featureTypes = ftKeys.map(function (key) { return _this._featureTypes[key]; }).filter(function (ft) { return ft.name === feature.featureTypeName; });
                if (featureTypes.length > 0) {
                    this._featureTypes[feature.featureTypeName] = featureTypes[0];
                }
                else {
                    this._featureTypes[feature.featureTypeName] = csComp.Helpers.createDefaultType(feature, null);
                }
            };
            LayerService.prototype.resetFilters = function () {
                dc.filterAll();
                dc.redrawAll();
            };
            LayerService.prototype.getGroupFeatures = function (g) {
                // find active layers
                var ls = [];
                g.layers.forEach(function (l) { if (l.enabled)
                    ls.push(l.id); });
                // add active features
                var r = this.project.features.filter(function (k) { return ls.indexOf(k.layerId) > -1; });
                return r;
            };
            LayerService.prototype.rebuildFilters = function (g) {
                // remove all data from crossfilter group
                g.ndx = crossfilter([]);
                var features = this.getGroupFeatures(g);
                g.ndx.add(features);
            };
            /**
             * deactivate layer
             */
            LayerService.prototype.removeLayer = function (layer, removeFromGroup) {
                if (removeFromGroup === void 0) { removeFromGroup = false; }
                var m;
                var g = layer.group;
                layer.enabled = false;
                layer.isLoading = false;
                layer._gui.more = false;
                //if (layer.refreshTimer) layer.stop();
                // make sure the timers are disabled
                this.checkLayerTimer(layer);
                delete this.loadedLayers[layer.id];
                // find layer source, and remove layer
                if (!layer.layerSource)
                    layer.layerSource = this.layerSources[layer.type.toLowerCase()];
                layer.layerSource.removeLayer(layer);
                if (this.lastSelectedFeature != null && this.lastSelectedFeature.layerId === layer.id) {
                    this.lastSelectedFeature = null;
                    this.visual.rightPanelVisible = false;
                    this.$messageBusService.publish('feature', 'onFeatureDeselect');
                }
                if (this.selectedFeatures.length > 0) {
                    this.selectedFeatures = this.selectedFeatures.filter(function (f) { return f.layerId !== layer.id; });
                }
                this.activeMapRenderer.removeLayer(layer);
                this.project.features = this.project.features.filter(function (k) { return k.layerId !== layer.id; });
                var layerName = layer.id + '_';
                var featureTypes = this._featureTypes;
                // EV What should this have done?
                // for (var poiTypeName in featureTypes) {
                //     if (!featureTypes.hasOwnProperty(poiTypeName)) continue;
                // }
                // check if there are no more active layers in group and remove filters/styles
                this.removeAllFilters(g);
                this.removeAllStyles(g);
                this.rebuildFilters(g);
                if (removeFromGroup)
                    layer.group.layers = layer.group.layers.filter(function (pl) { return pl !== layer; });
                this.apply();
                this.$messageBusService.publish('layer', 'deactivate', layer);
                this.$messageBusService.publish('rightpanel', 'deactiveContainer', 'edit');
                if (layer.timeAware)
                    this.$messageBusService.publish('timeline', 'updateFeatures');
                if (removeFromGroup)
                    this.saveProject();
            };
            LayerService.prototype.removeAllFilters = function (g) {
                var _this = this;
                // if (g.layers.filter((l: ProjectLayer) => { return (l.enabled); }).length === 0 || g.oneLayerActive === true) {
                g.filters.forEach(function (gf) {
                    _this.removeFilter(gf);
                });
                g.filters.length = 0;
                // }
            };
            LayerService.prototype.removeAllStyles = function (g) {
                var _this = this;
                g.styles.forEach(function (s) { _this.removeStyle(s); });
                g.styles.length = 0;
            };
            /***
             * Open solution file with references to available baselayers and projects
             * @params url: URL of the solution
             * @params layers: Optionally provide a semi-colon separated list of layer IDs that should be opened.
             * @params initialProject: Optionally provide a project name that should be loaded, if omitted the first project in the definition will be loaded
             */
            LayerService.prototype.openSolution = function (url, layers, initialProject) {
                var _this = this;
                //console.log('layers (openSolution): ' + JSON.stringify(layers));
                this.loadedLayers = {};
                var searchParams = this.$location.search();
                if (searchParams.hasOwnProperty('project')) {
                    url = this.emptySolutionUrl;
                    this.openSingleProject = true;
                }
                this.$http.get(url)
                    .success(function (solution) {
                    if (typeof solution !== 'object') {
                        console.log('Error: obtained solution is not a json object!');
                        return;
                    }
                    if (solution.maxBounds) {
                        _this.maxBounds = solution.maxBounds;
                        _this.$mapService.map.setMaxBounds(new L.LatLngBounds(L.latLng(solution.maxBounds.southWest[0], solution.maxBounds.southWest[1]), L.latLng(solution.maxBounds.northEast[0], solution.maxBounds.northEast[1])));
                    }
                    if (solution.viewBounds) {
                        _this.activeMapRenderer.fitBounds(solution.viewBounds);
                    }
                    if (solution.baselayers) {
                        solution.baselayers.forEach(function (b) {
                            var baselayer = new Services.BaseLayer();
                            if (b.subdomains != null)
                                baselayer.subdomains = b.subdomains;
                            if (b.maxZoom != null)
                                baselayer.maxZoom = b.maxZoom;
                            if (b.minZoom != null)
                                baselayer.minZoom = b.minZoom;
                            if (b.maxNativeZoom != null)
                                baselayer.maxNativeZoom = b.maxNativeZoom;
                            if (b.errorTileUrl != null)
                                baselayer.errorTileUrl = b.errorTileUrl;
                            if (b.attribution != null)
                                baselayer.attribution = b.attribution;
                            if (b.id != null)
                                baselayer.id = b.id;
                            if (b.title != null)
                                baselayer.title = b.title;
                            if (b.subtitle != null)
                                baselayer.subtitle = b.subtitle;
                            if (b.preview != null)
                                baselayer.preview = b.preview;
                            if (b.url != null)
                                baselayer.url = b.url;
                            if (b.cesium_url != null)
                                baselayer.cesium_url = b.cesium_url;
                            if (b.cesium_tileUrl != null)
                                baselayer.cesium_tileUrl = b.cesium_tileUrl;
                            if (b.cesium_maptype != null)
                                baselayer.cesium_maptype = b.cesium_maptype;
                            _this.$mapService.baseLayers[b.title] = baselayer;
                            if (b.isDefault) {
                                _this.activeMapRenderer.changeBaseLayer(baselayer);
                                _this.$mapService.changeBaseLayer(b.title);
                            }
                        });
                    }
                    if (_this.openSingleProject) {
                        var projectId_1 = searchParams['project'];
                        // By default, look for an API project
                        var u_1 = 'api/projects/' + projectId_1;
                        if (!initialProject) {
                            var foundProject = solution.projects.some(function (p) {
                                // If the solution already specifies a project, use that instead.
                                if (p.id !== projectId_1)
                                    return false;
                                initialProject = p.title;
                                //u = p.url;
                                return true;
                            });
                            if (!foundProject) {
                                _this.$http.get(u_1)
                                    .success(function (data) {
                                    if (data) {
                                        _this.parseProject(data, { title: data.title, url: data.url, dynamic: true }, []);
                                    }
                                })
                                    .error(function (data) {
                                    _this.$messageBusService.notify('ERROR loading project', 'while loading: ' + u_1);
                                });
                            }
                        }
                        else {
                            _this.$http.get(u_1)
                                .success(function (data) {
                                if (data) {
                                    _this.parseProject(data, { title: data.title, url: data.url, dynamic: true }, []);
                                }
                            })
                                .error(function (data) {
                                _this.$messageBusService.notify('ERROR loading project', 'while loading: ' + u_1);
                            });
                        }
                    }
                    if (solution.projects && solution.projects.length > 0) {
                        var p = solution.projects.filter(function (aProject) { return aProject.title === initialProject; })[0];
                        if (p != null) {
                            _this.openProject(p, layers);
                        }
                        else {
                            _this.openProject(solution.projects[0], layers);
                        }
                    }
                    // make sure a default WidgetStyle exists
                    if (!solution.widgetStyles)
                        solution.widgetStyles = {};
                    if (!solution.widgetStyles.hasOwnProperty('default')) {
                        var defaultStyle = new Services.WidgetStyle();
                        defaultStyle.background = 'red';
                        solution.widgetStyles['default'] = defaultStyle;
                    }
                    _this.solution = solution;
                })
                    .error(function () {
                    _this.$messageBusService.notify('ERROR loading solution', 'while loading: ' + url);
                });
            };
            /**
            * Clear all layers.
            */
            LayerService.prototype.clearLayers = function () {
                var _this = this;
                if (this.project == null || this.project.groups == null)
                    return;
                this.project.groups.forEach(function (group) {
                    group.layers.forEach(function (layer) {
                        if (layer.enabled) {
                            _this.removeLayer(layer);
                            layer.enabled = false;
                        }
                    });
                });
            };
            /**
             * Open project
             * @params url: URL of the project
             * @params layers: Optionally provide a semi-colon separated list of layer IDs that should be opened.
             * @params project: Optionally provide the project that should be parsed. If not provided, it will be requested using the solution url.
             */
            LayerService.prototype.openProject = function (solutionProject, layers, project) {
                var _this = this;
                this.projectUrl = solutionProject;
                var layerIds = [];
                if (layers) {
                    layers.split(';').forEach(function (layerId) { layerIds.push(layerId.toLowerCase()); });
                }
                this.clearLayers();
                this._featureTypes = {};
                this.propertyTypeData = {};
                //typesResources
                var s = this.$location.search();
                if (s.hasOwnProperty('dashboard')) {
                    this.startDashboardId = s['dashboard'];
                }
                if (!project) {
                    this.$http.get(solutionProject.url)
                        .success(function (prj) {
                        _this.parseProject(prj, solutionProject, layerIds);
                        //alert('project open ' + this.$location.absUrl());
                    })
                        .error(function () {
                        _this.$messageBusService.notify('ERROR loading project', 'while loading: ' + solutionProject.url);
                    });
                }
                else {
                    this.parseProject(project, solutionProject, layerIds);
                }
            };
            LayerService.prototype.parseProject = function (prj, solutionProject, layerIds) {
                var _this = this;
                prj.solution = this.solution;
                this.project = new Services.Project().deserialize(prj);
                this.$mapService.initDraw(this);
                if (typeof this.project.isDynamic === 'undefined')
                    this.project.isDynamic = solutionProject.dynamic;
                if (!this.project.timeLine) {
                    this.project.timeLine = new Services.DateRange();
                }
                else {
                    // Set range
                    this.$messageBusService.publish('timeline', 'updateTimerange', this.project.timeLine);
                }
                if (this.project.viewBounds) {
                    this.activeMapRenderer.fitBounds(this.project.viewBounds);
                }
                this.$messageBusService.publish('map', 'showScale', this.project.showScale);
                this.$messageBusService.publish('map', 'showLocation', this.project.showLocation);
                this.initTypeResources(this.project);
                if (this.project.eventTab) {
                    var rpt = csComp.Helpers.createRightPanelTab('eventtab', 'eventtab', {}, 'Events', '{{"EVENT_INFO" | translate}}', 'book');
                    this.$messageBusService.publish('rightpanel', 'activate', rpt);
                }
                // if no dashboards defined, create one
                if (!this.project.dashboards) {
                    this.project.dashboards = [];
                    var d = new Services.Dashboard();
                    d.id = 'map';
                    d.name = 'Home';
                    d.showMap = true;
                    d.showLeftmenu = true;
                    d.widgets = [];
                    this.project.dashboards.push(d);
                    var d2 = new Services.Dashboard();
                    d2.id = 'datatable';
                    d2.name = 'Table';
                    d2.showMap = false;
                    d2.showLeftmenu = false;
                    d2.showRightmenu = false;
                    d2.showTimeline = false;
                    d2.widgets = [{
                            id: 'datatable_id',
                            directive: 'datatable',
                            elementId: 'widget-datatable_id',
                            enabled: true,
                            width: '100%',
                            height: '100%'
                        }];
                    this.project.dashboards.push(d2);
                }
                else {
                    // initialize dashboards
                    this.project.dashboards.forEach(function (d) {
                        if (!d.id) {
                            d.id = csComp.Helpers.getGuid();
                        }
                        if (d.widgets && d.widgets.length > 0)
                            d.widgets.forEach(function (w) {
                                if (!w.id)
                                    w.id = csComp.Helpers.getGuid();
                                if (!w.enabled)
                                    w.enabled = true;
                            });
                    });
                }
                async.series([
                    function (callback) {
                        // load extra type resources
                        if (_this.project.typeUrls && _this.project.typeUrls.length > 0) {
                            async.eachSeries(_this.project.typeUrls, function (item, cb) {
                                _this.loadTypeResources(item, false, function () { return cb(null); });
                            }, function () {
                                callback(null, null);
                            });
                        }
                        else {
                            callback(null, null);
                        }
                    },
                    function (callback) {
                        // load data resources
                        if (!_this.project.datasources)
                            _this.project.datasources = [];
                        // this.project.datasources.forEach((ds: DataSource) => {
                        //     if (ds.url) {
                        //         DataSource.LoadData(this.$http, ds, () => {
                        //             if (ds.type === 'dynamic') { this.checkDataSourceSubscriptions(ds); }
                        //             for (var s in ds.sensors) {
                        //                 var ss: SensorSet = ds.sensors[s];
                        //                 /// check if there is an propertytype available for this sensor
                        //                 if (ss.propertyTypeKey != null && this.propertyTypeData.hasOwnProperty(ss.propertyTypeKey)) {
                        //                     ss.propertyType = this.propertyTypeData[ss.propertyTypeKey];
                        //                 } else { // else create a new one and store in project
                        //                     var id = 'sensor-' + Helpers.getGuid();
                        //                     var pt: IPropertyType = {};
                        //                     pt.title = s;
                        //                     ss.propertyTypeKey = id;
                        //                     this.project.propertyTypeData[id] = pt;
                        //                     ss.propertyType = pt;
                        //                 }
                        //                 if (ss.values && ss.values.length > 0) {
                        //                     ss.activeValue = ss.values[ss.values.length - 1];
                        //                 }
                        //             }
                        //         });
                        //     }
                        // });
                    }
                ]);
                if (!this.project.dataSets) {
                    this.project.dataSets = [];
                }
                this.project.features = [];
                if (this.project.groups && this.project.groups.length > 0) {
                    this.project.groups.forEach(function (group) {
                        _this.initGroup(group, layerIds);
                        if (prj.startposition) {
                            _this.$mapService.zoomToLocation(new L.LatLng(prj.startposition.latitude, prj.startposition.longitude));
                        }
                    });
                }
                if (this.project.isDynamic) {
                    if (!this.project.layerDirectory)
                        this.project.layerDirectory = '/api/layers';
                    // check connection
                    this.$messageBusService.initConnection('', '', function () {
                        var handle = _this.$messageBusService.subscribe('keyupdate', function (key, msg) {
                            if (msg.action === 'key') {
                                var id = 'keys/' + msg.data.keyId;
                                _this.findSensorSet(id, function (ss) {
                                    var time = new Date().getTime();
                                    if (msg.data.item.hasOwnProperty('time')) {
                                        time = msg.data.item['time'];
                                    }
                                    else {
                                        ss.timestamps = [];
                                        ss.values = [];
                                    }
                                    ss.addValue(new Date().getTime(), msg.data.item);
                                    ss.activeValue = msg.data.item;
                                });
                            }
                            // console.log('got it');
                            // console.log(msg);
                        });
                        //     if (msg.action !== 'subscribed') {
                        //         if (msg.data) {
                        //             var id = 'keys/' + msg.data.keyId;
                        //             this.findSensorSet(id, (ss: SensorSet) => {
                        //                 var time = new Date().getTime();
                        //                 if (msg.data.item.hasOwnProperty('time')) {
                        //                     time = msg.data.item['time'];
                        //                 }
                        //                 else {
                        //                     ss.timestamps = [];
                        //                     ss.values = [];
                        //                 }
                        //                 ss.addValue(new Date().getTime(), msg.data.item);
                        //                 ss.activeValue = msg.data.item;
                        //             });
                        //             this.$messageBusService.publish(id, 'update', msg.data.item);
                        //         }
                        //         //this.project.dataSets
                        //     }
                        //
                        // });
                        // setTimeout(() => {
                        //     for (var ll in this.loadedLayers) {
                        //         var layer = <ProjectLayer>this.loadedLayers[ll];
                        //         if (layer && layer.layerSource && layer.layerSource.title.toLowerCase() === 'dynamicgeojson') {
                        //             layer.layerSource.refreshLayer(layer);
                        //         }
                        //     }
                        // }, 5000);
                    });
                }
                // check if project is dynamic
                if (solutionProject.dynamic) {
                    // listen to directory updates
                    //
                    if (!this.directoryHandle) {
                        this.directoryHandle = this.$messageBusService.serverSubscribe('', 'directory', function (sub, msg) {
                            if (msg.action === 'subscribed')
                                return;
                            // received layer update
                            if (msg.action === 'layer' && msg.data && msg.data.item) {
                                // Disabled for single-project-solutions, as layers from excel2map get updated twice: on layer update and on project update
                                if (_this.openSingleProject === false) {
                                    var layer = msg.data.item;
                                    if (layer) {
                                        var l = _this.findLayer(layer.id);
                                        if (!l) {
                                        }
                                        else {
                                        }
                                    }
                                }
                            }
                            // received project update
                            if (msg.action === 'project' && msg.data && msg.data.item) {
                                var project = msg.data.item;
                                if (project) {
                                    var p = (_this.project.id === project.id);
                                    if (!p && !_this.openSingleProject) {
                                        _this.$messageBusService.notify('New project available', project.title);
                                        if (project.url && project.url.substring(project.url.length - 4) !== 'json')
                                            project.url = '/data' + project.url + '.json';
                                        if (!_this.solution.projects.some(function (sp) { return (sp.title === project.title); })) {
                                            _this.solution.projects.push({ title: project.title, url: project.url, dynamic: true });
                                        }
                                        else {
                                            console.log('Project already exists (' + project.title + ')');
                                        }
                                    }
                                    else {
                                        if (project.id === _this.project.id) {
                                            _this.$messageBusService.confirm('New update available for project ' + project.title, 'Do you want to reload the project?', function (r) {
                                                if (r) {
                                                    _this.openProject(solutionProject, null, project);
                                                }
                                            });
                                        }
                                    }
                                }
                            }
                        });
                    }
                    if (!this.$messageBusService.getConnection(this.project.id)) {
                        this.$messageBusService.serverSubscribe(this.project.id, 'project', function (sub, msg) {
                            if (msg.action === 'layer-update') {
                                msg.data.layer.forEach(function (l) {
                                    var g;
                                    // find group
                                    if (l.groupId) {
                                        g = _this.findGroupById(l.groupId);
                                    }
                                    else {
                                        l.groupId = 'main';
                                    }
                                    if (!g) {
                                        g = new Services.ProjectGroup();
                                        g.id = l.groupId;
                                        g.title = msg.data.group.title;
                                        g.clustering = msg.data.group.clustering;
                                        g.clusterLevel = msg.data.group.clusterLevel;
                                        _this.project.groups.push(g);
                                        _this.initGroup(g);
                                    }
                                    else {
                                        g.clustering = msg.data.group.clustering;
                                        g.clusterLevel = msg.data.group.clusterLevel;
                                    }
                                    var layerExists = false;
                                    var layerIndex = 0;
                                    g.layers.forEach(function (gl, index) {
                                        if (gl.id === l.id) {
                                            layerExists = true;
                                            layerIndex = index;
                                        }
                                    });
                                    if (!layerExists) {
                                        g.layers.push(l);
                                        _this.initLayer(g, l);
                                        if (!l.layerSource) {
                                            l.layerSource = _this.layerSources[l.type.toLowerCase()];
                                        }
                                        l.layerSource.refreshLayer(g.layers[g.layers.length - 1]);
                                    }
                                    else {
                                        var currentStyle = g.styles;
                                        if (_this.lastSelectedFeature && _this.lastSelectedFeature.isSelected)
                                            _this.selectFeature(_this.lastSelectedFeature);
                                        if (!l.layerSource)
                                            l.layerSource = _this.layerSources[l.type.toLowerCase()];
                                        l.group = g;
                                        //l.layerSource.refreshLayer(g.layers[layerIndex]);
                                        _this.removeLayer(g.layers[layerIndex]);
                                        _this.addLayer(g.layers[layerIndex], function () {
                                            if (currentStyle && currentStyle.length > 0)
                                                _this.setStyle({
                                                    feature: {
                                                        featureTypeName: l.url + '#' + l.defaultFeatureType,
                                                        layer: l
                                                    },
                                                    property: currentStyle[0].property,
                                                    key: currentStyle[0].title,
                                                    meta: currentStyle[0].meta
                                                }, false, null, currentStyle[0]);
                                        });
                                    }
                                    _this.apply();
                                });
                            }
                            if (msg.action === 'layer-remove') {
                                msg.data.forEach(function (l) {
                                    var g;
                                    // find group
                                    if (l.groupId) {
                                        g = _this.findGroupById(l.groupId);
                                    }
                                    else {
                                        l.groupId = 'main';
                                    }
                                    if (g != null) {
                                        g.layers.forEach(function (layer) {
                                            if (layer.id === l.id) {
                                                _this.removeLayer(layer, true);
                                            }
                                        });
                                        if (g.layers.length === 0) {
                                            _this.removeGroup(g);
                                        }
                                    }
                                });
                            }
                        });
                    }
                }
                if (prj.hasOwnProperty('collapseAllLayers') && prj.collapseAllLayers === true) {
                    this.apply();
                    this.collapseAll();
                }
                this.$messageBusService.publish('project', 'loaded', this.project);
                if (this.project.dashboards && this.project.dashboards.length > 0) {
                    var startd = this.project.dashboards[Object.keys(this.project.dashboards)[0]];
                    // find dashboard from url
                    if (this.startDashboardId && this.findDashboardById(this.startDashboardId)) {
                        startd = this.findDashboardById(this.startDashboardId);
                    }
                    this.$messageBusService.publish('dashboard-main', 'activated', startd);
                }
                // Add search providers
                this.project.searchProviders.forEach(function (searchProvider) {
                    switch (searchProvider.name.toLowerCase()) {
                        case 'offline':
                            _this.addActionService(new Services.OfflineSearchActions(_this.$http, searchProvider.url));
                            break;
                        case 'bag':
                            _this.addActionService(new Services.OnlineSearchActions(_this.$http, searchProvider.url));
                            break;
                        case 'bing':
                            if (!searchProvider.key)
                                break;
                            _this.addActionService(new Services.BingSearchAction(_this.$http, searchProvider.key, searchProvider.url, searchProvider.data));
                            break;
                        case 'opencagedata':
                            if (!searchProvider.key)
                                break;
                            var data = searchProvider.data;
                            if (!data) {
                                data = {
                                    countrycode: 'nl',
                                    //(min long, min lat, max long, max lat).
                                    //NL: [[[3.357962,50.7503838],[3.357962,53.5551999],[7.2275102,53.5551999],[7.2275102,50.7503838],[3.357962,50.7503838]]]
                                    bounds: '3.357962,50.7503838,7.2275102,53.5551999'
                                };
                            }
                            data.messageBus = _this.$messageBusService;
                            _this.addActionService(new Services.OpenCageDataSearchAction(_this.$http, searchProvider.key, searchProvider.url, data));
                            break;
                    }
                });
            };
            LayerService.prototype.apply = function () {
                if (this.$rootScope.$root.$$phase !== '$apply' && this.$rootScope.$root.$$phase !== '$digest')
                    this.$rootScope.$apply();
            };
            /** toggle layer enabled/disabled */
            LayerService.prototype.toggleLayer = function (layer, loaded) {
                if (_.isUndefined(layer.enabled) || layer.enabled === false) {
                    layer.enabled = true;
                    this.addLayer(layer, function () { if (loaded)
                        loaded(); });
                }
                else {
                    layer.enabled = !layer.enabled;
                    this.removeLayer(layer);
                    if (loaded)
                        loaded();
                }
            };
            LayerService.prototype.removeGroup = function (group) {
                var _this = this;
                if (group.layers) {
                    group.layers.forEach(function (l) {
                        if (l.enabled)
                            _this.removeLayer(l, true);
                    });
                }
                group.ndx = null;
                this.project.groups = this.project.groups.filter(function (g) { return g !== group; });
                this.apply();
            };
            /** initializes project group (create crossfilter index, clustering, initializes layers) */
            LayerService.prototype.initGroup = function (group, layerIds) {
                var _this = this;
                if (group.id == null)
                    group.id = csComp.Helpers.getGuid();
                group.ndx = crossfilter([]);
                if ((group.styles) && (group.styles.length > 0)) {
                    var styleId = group.styles[0].id;
                }
                ;
                if (group.styles == null)
                    group.styles = [];
                if (group.filters == null)
                    group.filters = [];
                group.markers = {};
                if (group.languages != null && this.currentLocale in group.languages) {
                    var locale = group.languages[this.currentLocale];
                    if (locale.title)
                        group.title = locale.title;
                    if (locale.description)
                        group.description = locale.description;
                }
                this.activeMapRenderer.addGroup(group);
                if (!group.layers)
                    group.layers = [];
                group.layers.forEach(function (layer) {
                    _this.initLayer(group, layer, layerIds);
                });
                group.styles.forEach(function (style) {
                    if (style.id != null)
                        style.id = csComp.Helpers.getGuid();
                });
                group.filters.forEach(function (filter) {
                    if (filter.id != null)
                        filter.id = csComp.Helpers.getGuid();
                });
            };
            /** initializes a layer (check for id, language, references group, add to active map renderer) */
            LayerService.prototype.initLayer = function (group, layer, layerIds) {
                if (layer.id == null)
                    layer.id = csComp.Helpers.getGuid();
                layer.type = (layer.type) ? layer.type.toLowerCase() : 'geojson';
                layer._gui = {};
                layer.renderType = (layer.renderType) ? layer.renderType.toLowerCase() : layer.type;
                if (layer.type === 'dynamicgeojson')
                    layer.isDynamic = true;
                if (layer.type === 'editablegeojson' || layer.isDynamic)
                    layer.isEditable = true;
                if (layer.reference == null)
                    layer.reference = layer.id; //Helpers.getGuid();
                if (layer.title == null)
                    layer.title = layer.id;
                if (layer.languages != null && this.currentLocale in layer.languages) {
                    var locale = layer.languages[this.currentLocale];
                    if (locale.title)
                        layer.title = locale.title;
                    if (locale.description)
                        layer.description = locale.description;
                }
                layer.group = group;
                if (!layer.groupId)
                    layer.groupId = group.id;
                if (layer.enabled || (layerIds && layerIds.indexOf(layer.reference.toLowerCase()) >= 0)) {
                    layer.enabled = true;
                    this.addLayer(layer);
                }
            };
            LayerService.prototype.checkDataSourceSubscriptions = function (ds) {
                var _this = this;
                for (var s in ds.sensors) {
                    this.$messageBusService.serverSubscribe(s, 'sensor', function (sub, msg) {
                        if (msg.action === 'sensor-update') {
                            var d = msg.data[0];
                            var ss = ds.sensors[d.sensor];
                            if (ss != null) {
                                ss.timestamps.push(d.date);
                                ss.values.push(d.value);
                                while (ss.timestamps.length > 30) {
                                    ss.timestamps.shift();
                                    ss.values.shift();
                                }
                                ss.activeValue = d.value;
                                _this.$messageBusService.publish('sensor-' + ds.id + '/' + d.sensor, 'update', ss.activeValue);
                                _this.apply();
                            }
                        }
                    });
                }
            };
            LayerService.prototype.checkSubscriptions = function () {
                var _this = this;
                this.project.datasources.forEach(function (ds) {
                    if (ds.url && ds.type === 'dynamic') {
                        _this.checkDataSourceSubscriptions(ds);
                    }
                });
            };
            LayerService.prototype.closeProject = function () {
                var _this = this;
                if (this.project == null)
                    return;
                this.project.groups.forEach(function (group) {
                    group.layers.forEach(function (layer) {
                        if (layer.enabled) {
                            _this.removeLayer(layer);
                        }
                    });
                });
            };
            /** Find a sensor set for a specific source/sensor combination. Key should be something like datasource/sensorid */
            LayerService.prototype.findSensorSet = function (key, callback) {
                var kk = key.split('/');
                if (kk.length === 2) {
                    var dataSourceId = kk[0];
                    var sensorId = kk[1];
                    var dss = this.project.datasources.filter(function (ds) { return ds.id === dataSourceId; });
                    if (dss.length === 0) {
                        var ds = new Services.DataSource();
                        ds.id = dataSourceId;
                        ds.type = 'dynamic';
                        ds.sensors = {};
                        dss.push(ds);
                        this.project.datasources.push(ds);
                    }
                    ds = dss[0];
                    if (ds.sensors.hasOwnProperty(sensorId)) {
                        callback(ds.sensors[sensorId]);
                    }
                    else {
                        var ss = new Services.SensorSet();
                        ss.id = sensorId;
                        ss.title = sensorId;
                        ss.timestamps = [];
                        ss.values = [];
                        ds.sensors[sensorId] = ss;
                        callback(ss);
                    }
                }
                return null;
            };
            //private zoom(data: any) {
            //    //var a = data;
            //}
            LayerService.prototype.getPropertyValues = function (layer, property) {
                var r = [];
                var features = [];
                if (this.selectedFeatures.length > 1) {
                    features = this.selectedFeatures;
                }
                else {
                    features = (layer.group.filterResult) ? layer.group.filterResult : layer.data.features;
                }
                if (features)
                    features.forEach(function (f) { if (f.layerId === layer.id)
                        r.push(f.properties); });
                if (r.length === 0)
                    r = layer.data.features;
                return r;
            };
            /**
             * Calculate min/max/count/mean/varience/sd for a specific property in a group
             */
            LayerService.prototype.calculatePropertyInfo = function (group, property) {
                var _this = this;
                var r = {
                    count: 0,
                    max: Number.MIN_VALUE,
                    min: Number.MAX_VALUE
                };
                var sumOfElements = 0;
                var sumOfSquares = 0;
                group.layers.forEach(function (l) {
                    if (l.enabled) {
                        _this.project.features.forEach(function (f) {
                            if (f.layerId === l.id && f.properties.hasOwnProperty(property)) {
                                var v = Number(f.properties[property]);
                                if (isNaN(v))
                                    return;
                                r.count++;
                                sumOfElements += v;
                                sumOfSquares += v * v;
                                if (v > r.max)
                                    r.max = v;
                                if (v < r.min)
                                    r.min = v;
                            }
                        });
                    }
                });
                if (!isNaN(sumOfElements) && r.count !== 0) {
                    r.mean = sumOfElements / r.count;
                    r.varience = sumOfSquares / r.count - r.mean * r.mean;
                    r.sd = Math.sqrt(r.varience);
                }
                if (this.propertyTypeData.hasOwnProperty(property)) {
                    var mid = this.propertyTypeData[property];
                    r.userMin = mid.min;
                    r.userMax = mid.max;
                }
                return r;
            };
            LayerService.prototype.updateFilterGroupCount = function (group) {
                if (group.filterResult != null)
                    $('#filtergroupcount_' + group.id).text(group.filterResult.length + ' objecten geselecteerd');
            };
            LayerService.prototype.trackGeometry = function (f, result) {
                var key = '~geometry';
                var log = {
                    ts: new Date().getTime(), prop: key, value: f.geometry
                };
                f.propertiesOld[key] = JSON.parse(JSON.stringify(f.geometry));
                if (!f.logs.hasOwnProperty(key))
                    f.logs[key] = [];
                if (!result.hasOwnProperty(key))
                    result[key] = [];
                f.logs[key].push(log);
                result[key].push(log);
                f._gui['lastUpdate'] = log.ts;
            };
            /**
             * Check for property changes for a specific key inside a feature, return a set of logs in result
             */
            LayerService.prototype.trackPropertyLog = function (f, key, result) {
                var log = {
                    ts: new Date().getTime(), prop: key, value: f.properties[key]
                };
                f.propertiesOld[key] = JSON.parse(JSON.stringify(f.properties[key]));
                if (!f.logs.hasOwnProperty(key)) {
                    f.logs[key] = [];
                }
                if (!result.hasOwnProperty(key)) {
                    result[key] = [];
                }
                f.logs[key].push(log);
                result[key].push(log);
                f._gui['lastUpdate'] = log.ts;
            };
            /** Check for property changes inside a feature, return a set of logs in result */
            LayerService.prototype.trackFeature = function (feature) {
                var result = {};
                for (var key in feature.properties) {
                    if (!feature.propertiesOld.hasOwnProperty(key)) {
                        this.trackPropertyLog(feature, key, result);
                    }
                    else if (JSON.stringify(feature.propertiesOld[key]) !== JSON.stringify(feature.properties[key])) {
                        this.trackPropertyLog(feature, key, result);
                    }
                }
                if (JSON.stringify(feature.propertiesOld['~geometry']) !== JSON.stringify(feature.geometry)) {
                    this.trackGeometry(feature, result);
                }
                return result;
            };
            LayerService.prototype.isLocked = function (f) {
                return f._gui.hasOwnProperty('lock') || (f._gui.hasOwnProperty('editMode') && f._gui['editMode']);
            };
            /**
             * Set a lock property on the feature to signal others prevent feature updates
             */
            LayerService.prototype.lockFeature = function (f) {
                if (f._gui.hasOwnProperty('lock')) {
                    return false;
                }
                else {
                    f._gui['lock'] = true;
                    return true;
                }
            };
            LayerService.prototype.unlockFeature = function (f) {
                delete f._gui['lock'];
            };
            LayerService.prototype.stopEditingLayer = function (layer) {
                var _this = this;
                this.project.groups.forEach(function (g) {
                    delete g._gui['editing'];
                    g.layers.forEach(function (l) {
                        delete layer._gui['editing'];
                        delete layer._gui['featureTypes'];
                        if (layer.data && layer.data.features && _.isArray(layer.data.features)) {
                            layer.data.features.forEach(function (f) {
                                delete f._gui['editMode'];
                                _this.updateFeature(f);
                                _this.saveFeature(f);
                            });
                        }
                    });
                });
                this.editing = false;
            };
            /* save project back to api */
            LayerService.prototype.saveProject = function () {
                var _this = this;
                // if project is not dynamic, don't save it
                if (!this.project.isDynamic)
                    return;
                console.log('saving project');
                setTimeout(function () {
                    var data = _this.project.serialize();
                    var url = _this.projectUrl.url;
                    var pu = { projectId: _this.project.id, action: ProjectUpdateAction.updateProject, item: data };
                    _this.$messageBusService.serverSendMessageAction('project', pu);
                    //.substr(0, this.$layerService.projectUrl.url.indexOf('/project.json'));
                    // console.log('URL: ' + url);
                    // $.ajax({
                    //     url: url,
                    //     type: 'PUT',
                    //     data: data,
                    //     contentType: 'application/json',
                    //     complete: (d) => {
                    //         if (d.error) {
                    //             console.error('Error update project.json: ' + JSON.stringify(d));
                    //         } else {
                    //             console.log('Project.json updated succesfully!');
                    //         }
                    //     }
                    // });
                }, 0);
            };
            LayerService.prototype.updateProjectReady = function (data) { };
            /** Create a new feature and save it to the server. */
            LayerService.prototype.createFeature = function (feature, layer) {
                if (!layer.isDynamic)
                    return;
                layer.data.features.push(feature);
                this.initFeature(feature, layer);
                this.activeMapRenderer.addFeature(feature);
                this.saveFeature(feature);
            };
            /**
             * Save feature back to the server. Does not create it, use createFeature for that.
             */
            LayerService.prototype.saveFeature = function (f, logs) {
                if (logs === void 0) { logs = false; }
                f.properties['updated'] = new Date().getTime();
                // check if feature is in dynamic layer
                if (f.layer.isDynamic) {
                    if (f.layer.useLog) {
                        var l = this.trackFeature(f);
                        var s = new LayerUpdate();
                        s.layerId = f.layerId;
                        s.action = LayerUpdateAction.updateLog;
                        s.item = { featureId: f.id, logs: l };
                        //this.$messageBusService.serverPublish('layer', s);
                        this.$messageBusService.serverSendMessageAction('layer', s);
                    }
                    else {
                        var s = new LayerUpdate();
                        s.layerId = f.layerId;
                        s.action = LayerUpdateAction.updateFeature;
                        s.item = Services.Feature.serialize(f);
                        this.$messageBusService.serverSendMessageAction('layer', s);
                    }
                }
            };
            /**
             * Update the filter status of a feature, i.e. the _gui.included property.
             * When a filter is applied, and the feature is not shown anymore, the feature._gui.included = false.
             * In all other cases, it is true. */
            LayerService.prototype.updateFilterStatusFeature = function (group) {
                //console.time('Filter');
                this.project.features.forEach(function (f) {
                    if (f.layer.group === group)
                        f._gui.included = false;
                });
                group.filterResult.forEach(function (f) {
                    f._gui.included = true;
                });
                //console.timeEnd('Filter');
            };
            /***
             * Update map markers in cluster after changing filter
             */
            LayerService.prototype.updateMapFilter = function (group) {
                this.updateFilterStatusFeature(group);
                this.activeMapRenderer.updateMapFilter(group);
                // update timeline list
                this.$messageBusService.publish('timeline', 'updateFeatures', group.id);
            };
            LayerService.prototype.resetMapFilter = function (group) {
                var _this = this;
                this.updateFilterStatusFeature(group);
                $.each(group.markers, function (key, marker) {
                    if (group.clustering) {
                        if (!group._cluster.hasLayer(marker))
                            group._cluster.addLayer(marker);
                    }
                    else {
                        if (!_this.map.map.hasLayer(marker))
                            _this.map.map.addLayer(marker);
                    }
                });
            };
            LayerService.$inject = [
                '$location',
                '$compile',
                '$translate',
                'messageBusService',
                'mapService',
                '$rootScope',
                'geoService',
                '$http',
                'expressionService',
                'actionService'
            ];
            return LayerService;
        }());
        Services.LayerService = LayerService;
        /**
         * object for sending layer messages over socket.io channel
         */
        var LayerUpdate = (function () {
            function LayerUpdate() {
            }
            return LayerUpdate;
        }());
        Services.LayerUpdate = LayerUpdate;
        /**
         * List of available action for sending/receiving layer actions over socket.io channel
         */
        (function (LayerUpdateAction) {
            LayerUpdateAction[LayerUpdateAction["updateFeature"] = 0] = "updateFeature";
            LayerUpdateAction[LayerUpdateAction["updateLog"] = 1] = "updateLog";
            LayerUpdateAction[LayerUpdateAction["deleteFeature"] = 2] = "deleteFeature";
            LayerUpdateAction[LayerUpdateAction["updateLayer"] = 3] = "updateLayer";
            LayerUpdateAction[LayerUpdateAction["deleteLayer"] = 4] = "deleteLayer";
            LayerUpdateAction[LayerUpdateAction["addUpdateFeatureBatch"] = 5] = "addUpdateFeatureBatch";
        })(Services.LayerUpdateAction || (Services.LayerUpdateAction = {}));
        var LayerUpdateAction = Services.LayerUpdateAction;
        /** Type of change in an ApiEvent */
        (function (ChangeType) {
            ChangeType[ChangeType["Create"] = 0] = "Create";
            ChangeType[ChangeType["Update"] = 1] = "Update";
            ChangeType[ChangeType["Delete"] = 2] = "Delete";
        })(Services.ChangeType || (Services.ChangeType = {}));
        var ChangeType = Services.ChangeType;
        /**
         * List of available action for sending/receiving project actions over socket.io channel
         */
        (function (ProjectUpdateAction) {
            ProjectUpdateAction[ProjectUpdateAction["updateProject"] = 0] = "updateProject";
            ProjectUpdateAction[ProjectUpdateAction["deleteProject"] = 1] = "deleteProject";
        })(Services.ProjectUpdateAction || (Services.ProjectUpdateAction = {}));
        var ProjectUpdateAction = Services.ProjectUpdateAction;
        /**
         * object for sending project messages over socket.io channel
         */
        var ProjectUpdate = (function () {
            function ProjectUpdate() {
            }
            return ProjectUpdate;
        }());
        Services.ProjectUpdate = ProjectUpdate;
        /**
          * Register service
          */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('layerService', csComp.Services.LayerService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=LayerService.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var MatrixAction;
(function (MatrixAction) {
    var MatrixActionModel = (function (_super) {
        __extends(MatrixActionModel, _super);
        function MatrixActionModel() {
            _super.apply(this, arguments);
            this.id = 'MatrixActionModel';
        }
        MatrixActionModel.prototype.init = function (layerService) {
            _super.prototype.init.call(this, layerService);
        };
        MatrixActionModel.prototype.selectFeature = function (feature) {
            var _this = this;
            var props = csComp.Helpers.getPropertyTypes(feature.fType, this.layerService.propertyTypeData);
            props.forEach(function (prop) {
                if (prop.type === 'matrix' && feature.properties.hasOwnProperty(prop.label)) {
                    var matrix = feature.properties[prop.label];
                    _this.layerService.project.features.forEach(function (f) {
                        if (f.layer === feature.layer && f.properties.hasOwnProperty(prop.targetid) && matrix.hasOwnProperty(f.properties[prop.targetid])) {
                            var newValue = matrix[f.properties[prop.targetid]];
                            for (var val in newValue) {
                                f.properties[val] = newValue[val];
                            }
                        }
                    });
                    _this.layerService.updateGroupFeatures(feature.layer.group);
                }
            });
        };
        MatrixActionModel.prototype.addLayer = function (layer) {
            var _this = this;
            if (!layer.data || !layer.data.features)
                return;
            layer.data.features.forEach(function (feature) {
                var props = csComp.Helpers.getPropertyTypes(feature.fType, _this.layerService.propertyTypeData);
                props.forEach(function (prop) {
                    if (prop.type === 'matrix' && feature.properties.hasOwnProperty(prop.label)) {
                        var m = feature.properties[prop.label];
                        for (var f in m) {
                            var kb = m[f];
                            if (kb.hasOwnProperty('b') && kb.b > 0 && kb.hasOwnProperty('h') && kb.h > 0) {
                                var tf = _this.layerService.findFeatureByPropertyValue(prop.targetid, f);
                                if (tf) {
                                    var lh = prop.label + '_h';
                                    var lb = prop.label + '_b';
                                    if (!tf.properties.hasOwnProperty(lh))
                                        tf.properties[lh] = 0;
                                    if (!tf.properties.hasOwnProperty(lb))
                                        tf.properties[lb] = 0;
                                    tf.properties[lh] += kb.h;
                                    tf.properties[lb] += kb.b;
                                }
                            }
                        }
                    }
                });
            });
            //alert('add layer');
        };
        return MatrixActionModel;
    }(csComp.Services.BasicActionService));
    MatrixAction.MatrixActionModel = MatrixActionModel;
})(MatrixAction || (MatrixAction = {}));
//# sourceMappingURL=MatrixAction.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var RelationAction;
(function (RelationAction) {
    /**
     * When a feature is selected, its propertyTypes will be searched for 'relation' propertyTypes.
     * If present, related features of these propTypes will be looked up and stored in
     * the _gui.relations property of the feature as an IRelation-dictionary.
     */
    var RelationActionModel = (function (_super) {
        __extends(RelationActionModel, _super);
        function RelationActionModel() {
            _super.apply(this, arguments);
            this.id = 'RelationActionModel';
        }
        RelationActionModel.prototype.init = function (layerService) {
            _super.prototype.init.call(this, layerService);
        };
        RelationActionModel.prototype.selectFeature = function (feature) {
            var _this = this;
            var props = csComp.Helpers.getPropertyTypes(feature.fType, this.layerService.propertyTypeData);
            if (!feature._gui)
                feature._gui = {};
            feature._gui['relations'] = {};
            if (!props || !_.isArray(props))
                return;
            var results = [];
            props.forEach(function (prop) {
                if (prop.type !== 'relation')
                    return;
                var useTargetID = (!prop.target) ? true : false;
                var useSubjectID = (!prop.subject) ? true : false;
                // Search for the property when it is defined as subject, otherwise search for id.
                var searchValue = (useSubjectID) ? feature.id : feature.properties[prop.subject];
                var searchFeatures = [];
                if (!prop.targetlayers) {
                    searchFeatures = feature.layer.data.features || [];
                }
                else if (prop.targetlayers.length > 0 && prop.targetlayers[0] === '*') {
                    searchFeatures = _this.layerService.project.features;
                }
                else {
                    prop.targetlayers.forEach(function (layerID) {
                        var l = _this.layerService.findLayer(layerID);
                        if (l && l.data && l.data.features) {
                            searchFeatures = searchFeatures.concat(l.data.features);
                        }
                    });
                }
                results = searchFeatures.filter(function (f) {
                    if (useTargetID) {
                        if (f.id === searchValue && f.id !== feature.id) {
                            return true;
                        }
                    }
                    else {
                        if (f.properties && f.properties.hasOwnProperty(prop.target) && f.properties[prop.target] === searchValue) {
                            if (f.id !== feature.id) {
                                return true;
                            }
                        }
                    }
                    return false;
                });
                feature._gui['relations'][prop.label] = results;
            });
        };
        RelationActionModel.prototype.addLayer = function (layer) { };
        return RelationActionModel;
    }(csComp.Services.BasicActionService));
    RelationAction.RelationActionModel = RelationActionModel;
})(RelationAction || (RelationAction = {}));
//# sourceMappingURL=RelationAction.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        /*
         * Singleton service that holds a reference to the map.
         * In case other controllers need access to the map, they can inject this service.
         */
        var MapService = (function () {
            function MapService($localStorageService, $timeout, $messageBusService) {
                var _this = this;
                this.$localStorageService = $localStorageService;
                this.$timeout = $timeout;
                this.$messageBusService = $messageBusService;
                this.showLocation = false;
                this.mapVisible = true;
                this.rightMenuVisible = true;
                this._timelineVisible = false;
                this.initExpertMode();
                this.baseLayers = {};
                $messageBusService.subscribe('timeline', function (title, data) {
                    switch (title) {
                        case 'isEnabled':
                            _this.timelineVisible = data;
                            if (_this.timelineVisible) {
                                _this.$timeout(function () {
                                    _this.$messageBusService.publish('timeline', 'loadProjectTimeRange');
                                }, 100);
                            }
                            break;
                    }
                });
                var mapClicked = function (e) { return _this.mapClicked(e); };
                $messageBusService.subscribe('map', function (action, data) {
                    switch (action.toLowerCase()) {
                        case 'setextent':
                            // console.log(data);
                            // take the navbar and leftpanel into account using padding (50px height, 370px left)
                            _this.map.fitBounds(new L.LatLngBounds(data.southWest, data.northEast), { paddingTopLeft: new L.Point(370, 50) });
                            break;
                        case 'setzoom':
                            // Zoom to a location on the map.
                            _this.map.setZoomAround(data.loc, data.zoom || 16);
                            break;
                        case 'showscale':
                            if (data) {
                                _this.scale = L.control.scale({
                                    // Position, i.e. bottomleft, topright, topleft, bottomright
                                    position: 'bottomleft',
                                    maxWidth: 100,
                                    metric: true,
                                    imperial: false,
                                    // If true, the control is updated on moveend, otherwise it's always up-to-date (updated on move).
                                    updateWhenIdle: true
                                }).addTo(_this.map);
                            }
                            else if (_this.scale) {
                                _this.map.removeControl(_this.scale);
                            }
                            break;
                        case 'showlocation':
                            if (typeof data !== 'undefined')
                                _this.showLocation = !data; // Use !data, since the normal behaviour is to toggle.
                            if (_this.showLocation) {
                                _this.showLocation = false;
                                _this.map.off('click', mapClicked);
                            }
                            else {
                                _this.showLocation = true;
                                _this.map.on('click', mapClicked);
                            }
                            break;
                    }
                });
            }
            Object.defineProperty(MapService.prototype, "timelineVisible", {
                get: function () { return this._timelineVisible; },
                set: function (val) {
                    var _this = this;
                    this._timelineVisible = val;
                    setTimeout(function () {
                        var windowHeight = $(window).height();
                        $('#map').height(windowHeight - (_this._timelineVisible ? $('#timeline').height() : 0));
                    }, 300);
                },
                enumerable: true,
                configurable: true
            });
            MapService.prototype.mapClicked = function (e) {
                if (this.$messageBusService)
                    this.$messageBusService.publish('geocoding', 'reverselookup', e.latlng);
            };
            /**
             * The expert mode can either be set manually, e.g. using this directive, or by setting the expertMode property in the
             * project.json file. In neither are set, we assume that we are dealing with an expert, so all features should be enabled.
             *
             * Precedence:
             * - when a declaration is absent, assume Expert.
             * - when the mode is set in local storage, take that value.
             * - when the mode is set in the project.json file, take that value.
             */
            MapService.prototype.initExpertMode = function () {
                var _this = this;
                this.expertMode = this.$localStorageService.get(MapService.expertModeKey);
                if (!this.expertMode) {
                    this.expertMode = Services.Expertise.Expert; // Default behaviour
                    // When a project defines the expert mode, overrules default behaviour
                    this.$messageBusService.subscribe('project', function (title, project) {
                        switch (title) {
                            case 'loaded':
                                if (project != null && typeof project.expertMode !== 'undefined')
                                    _this.$messageBusService.publish('expertMode', 'newExpertise', project.expertMode);
                                break;
                        }
                    });
                }
                this.$messageBusService.subscribe('expertMode', function (title, expertMode) {
                    if (title !== 'newExpertise')
                        return;
                    _this.expertMode = expertMode;
                    _this.$localStorageService.set(csComp.Services.MapService.expertModeKey, expertMode); // You first need to set the key
                });
            };
            Object.defineProperty(MapService.prototype, "isExpert", {
                get: function () {
                    return this.expertMode === Services.Expertise.Expert || this.expertMode === Services.Expertise.Admin;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapService.prototype, "isIntermediate", {
                get: function () {
                    return this.expertMode === Services.Expertise.Expert
                        || this.expertMode === Services.Expertise.Intermediate || this.expertMode === Services.Expertise.Admin;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapService.prototype, "isAdminExpert", {
                get: function () {
                    return this.expertMode === Services.Expertise.Admin;
                },
                enumerable: true,
                configurable: true
            });
            MapService.prototype.getBaselayer = function (layer) {
                var layerObj = this.baseLayers[layer];
                return layerObj;
            };
            MapService.prototype.changeBaseLayer = function (layer) {
                var layerObj = this.getBaselayer(layer);
                this.activeBaseLayer = layerObj;
                this.activeBaseLayerId = layer;
                this.$messageBusService.publish("baselayer", "activated", layer);
            };
            MapService.prototype.invalidate = function () {
                this.map.invalidateSize(true);
            };
            /**
             * Zoom to a location on the map.
             */
            MapService.prototype.zoomToLocation = function (center, zoomFactor) {
                this.map.setView(center, zoomFactor || 14);
            };
            /**
             * Zoom to a feature on the map.
             */
            MapService.prototype.zoomTo = function (feature, zoomLevel) {
                var _this = this;
                if (zoomLevel === void 0) { zoomLevel = 14; }
                try {
                    var center;
                    if (feature.geometry.type.toUpperCase() === 'POINT') {
                        center = new L.LatLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]);
                        this.map.setView(center, zoomLevel);
                    }
                    else {
                        var bb;
                        if (feature.geometry.type.toUpperCase().indexOf('MULTI') < 0) {
                            bb = this.getBoundingBox(feature.geometry.coordinates[0]);
                        }
                        else {
                            bb = [1000, -1000, 1000, -1000];
                            feature.geometry.coordinates.forEach(function (c) {
                                var b = _this.getBoundingBox(c[0]);
                                bb = [Math.min(bb[0], b[0]), Math.max(bb[1], b[1]), Math.min(bb[2], b[2]), Math.max(bb[3], b[3])];
                            });
                        }
                        var spacingLon = 0.05; // extra spacing left and right, where the menus are.
                        var southWest = L.latLng(Math.min(bb[2], bb[3]), Math.min(bb[0], bb[1]) - spacingLon);
                        var northEast = L.latLng(Math.max(bb[2], bb[3]), Math.max(bb[0], bb[1]) + spacingLon);
                        this.map.fitBounds(new L.LatLngBounds(southWest, northEast));
                    }
                    this.$messageBusService.publish('sidebar', 'show');
                    this.$messageBusService.publish('feature', 'onFeatureSelect', feature);
                }
                catch (e) {
                    console.log('error zooming to feature');
                }
            };
            //private getCentroid(arr) {
            //    return arr.reduce((x, y) => [x[0] + y[0] / arr.length, x[1] + y[1] / arr.length], [0, 0]);
            //}
            /**
             * Compute the bounding box.
             * Returns [min_x, max_x, min_y, max_y]
             */
            MapService.prototype.getBoundingBox = function (arr) {
                // p is the previous value of the callback, c the current element of the array.
                return arr.reduce(function (p, c) { return [Math.min(p[0], c[0]), Math.max(p[1], c[0]), Math.min(p[2], c[1]), Math.max(p[3], c[1])]; }, [1000, -1000, 1000, -1000]);
            };
            MapService.prototype.getMap = function () { return this.map; };
            MapService.prototype.initDraw = function (layerService) {
                var _this = this;
                this.map.on('draw:created', function (e) {
                    if (_this.drawingLayer) {
                        if (_this.drawingNotification)
                            _this.drawingNotification.remove();
                        var geometryType = "Point";
                        var c = [];
                        switch (_this.drawingFeatureType.style.drawingMode) {
                            case "Line":
                                geometryType = "LineString";
                                e.layer._latlngs.forEach(function (ll) {
                                    c.push([ll.lng, ll.lat]);
                                });
                                break;
                            case "Polygon":
                                geometryType = "Polygon";
                                e.layer._latlngs.forEach(function (g) {
                                    var inner = [];
                                    g.forEach(function (ll) {
                                        inner.push([ll.lng, ll.lat]);
                                    });
                                    //Make sure first and last point are the same
                                    if (inner.length > 1 && !_.isEqual(_.first(inner), _.last(inner))) {
                                        inner.push(_.first(inner));
                                    }
                                    c.push(inner);
                                });
                                break;
                        }
                        var f = {
                            type: "Feature",
                            geometry: { type: geometryType, "coordinates": c },
                            fType: _this.drawingFeatureType,
                            properties: {}
                        };
                        f.properties["featureTypeId"] = csComp.Helpers.getFeatureTypeName(_this.drawingFeatureType.id);
                        // Initialize properties
                        if (_.isArray(_this.drawingFeatureType._propertyTypeData)) {
                            for (var k in _this.drawingFeatureType._propertyTypeData) {
                                var pt = _this.drawingFeatureType._propertyTypeData[k];
                                _this.drawingFeatureType._propertyTypeData.forEach(function (pt) {
                                    f.properties[pt.label] = _.isUndefined(pt.defaultValue) ? "" : pt.defaultValue;
                                });
                            }
                        }
                        var l = _this.drawingLayer;
                        if (!l.data)
                            l.data = {};
                        if (!l.data.features)
                            l.data.features = [];
                        l.data.features.push(f);
                        layerService.initFeature(f, l);
                        layerService.calculateFeatureStyle(f);
                        layerService.activeMapRenderer.addFeature(f);
                        f.type = "Feature";
                        layerService.saveFeature(f);
                        console.log(f);
                    }
                    _this.drawInstance.removeHooks();
                    _this.drawingFeatureType = null;
                });
            };
            /** start drawing line/polygon */
            MapService.prototype.startDraw = function (layer, featureType) {
                var _this = this;
                if (this.drawingFeatureType)
                    return;
                this.drawingLayer = layer;
                this.drawingFeatureType = featureType;
                var opts = {
                    stroke: true,
                    color: this.drawingFeatureType.style.strokeColor,
                    weight: 4,
                    opacity: 0.5,
                    fill: false,
                    clickable: true
                };
                switch (featureType.style.drawingMode) {
                    case "Line":
                        this.drawInstance = new L.Draw.Polyline(this.map, opts);
                        break;
                    case "Polygon":
                        opts.showArea = true;
                        this.drawInstance = new L.Draw.Polygon(this.map, opts);
                        opts.fill = true;
                        break;
                }
                this.drawInstance.addHooks();
                this.drawingNotification = this.$messageBusService.confirm("Drawing started", "Use double-click or one of these options to end your drawing", function (r) {
                    if (r) {
                        _this.drawInstance.completeShape();
                    }
                    else {
                        _this.drawInstance.removeHooks();
                        _this.drawingFeatureType = null;
                    }
                });
            };
            MapService.expertModeKey = 'expertMode';
            MapService.$inject = [
                'localStorageService',
                '$timeout',
                'messageBusService'
            ];
            return MapService;
        }());
        Services.MapService = MapService;
        /**
          * Register service
          */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('mapService', csComp.Services.MapService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=MapService.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        /*
         * Singleton service that holds a reference to the map.
         * In case other controllers need access to the map, they can inject this service.
         */
        var ProfileService = (function () {
            function ProfileService($localStorageService, $timeout, $messageBusService) {
                this.$localStorageService = $localStorageService;
                this.$timeout = $timeout;
                this.$messageBusService = $messageBusService;
            }
            ProfileService.prototype.startLogin = function () {
                var rpt = csComp.Helpers.createRightPanelTab('profile', 'profiletab', null, 'Selected feature', '{{"FEATURE_INFO" | translate}}', 'user', true, false);
                this.$messageBusService.publish('rightpanel', 'activate', rpt);
            };
            ProfileService.prototype.validateUser = function (userName, userPassword) {
                var _this = this;
                if (_.isFunction(this.validate)) {
                    this.validate(userName, userPassword, function (status, profile) {
                        _this.loggedIn = status;
                        if (!_this.loggedIn) {
                            _this.$messageBusService.notify("Login Result", "Login Failed");
                        }
                    });
                }
            };
            ProfileService.prototype.logoutUser = function () {
                this.loggedIn = false;
                if (_.isFunction(this.logout)) {
                    this.logout();
                }
            };
            ProfileService.$inject = [
                'localStorageService',
                '$timeout',
                'messageBusService'
            ];
            return ProfileService;
        }());
        Services.ProfileService = ProfileService;
        /**
          * Register service
          */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('profileService', csComp.Services.ProfileService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=ProfileService.js.map
var csComp;
(function (csComp) {
    var Search;
    (function (Search) {
        var SearchFormCtrl = (function () {
            function SearchFormCtrl($scope, $mapService) {
                this.$scope = $scope;
                this.$mapService = $mapService;
                $scope.vm = this;
                $scope.location = new L.LatLng(0, 0);
            }
            SearchFormCtrl.prototype.doSearch = function () {
                if (this.$scope.location.lat === 0 && this.$scope.location.lng === 0) {
                    alert('Directive did not update the location property in parent controller.');
                }
                else {
                    //alert('Yay. Location: ' + this.$scope.location);
                    var center = new L.LatLng(this.$scope.location.lat, this.$scope.location.lng);
                    this.$mapService.zoomToLocation(center);
                }
            };
            // $inject annotation.
            // It provides $injector with information about dependencies to be injected into constructor
            // it is better to have it close to the constructor, because the parameters must match in count and type.
            // See http://docs.angularjs.org/guide/di
            SearchFormCtrl.$inject = [
                '$scope',
                'mapService'
            ];
            return SearchFormCtrl;
        }());
        Search.SearchFormCtrl = SearchFormCtrl;
    })(Search = csComp.Search || (csComp.Search = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=SearchFormCtrl.js.map
var Dashboard;
(function (Dashboard) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Dashboard.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Dashboard.myModule = angular.module(moduleName, []);
    }
    Dashboard.myModule.directive('feature', ['$interpolate', function ($interpolate) {
            return {
                restrict: 'A',
                priority: Number.MAX_VALUE,
                link: function ($scope, $element, $attributes) {
                    if ($attributes.hasOwnProperty('feature')) {
                        var f = $attributes['feature'];
                        if (f === 'mca')
                            $element.hide();
                    }
                }
            };
        }]);
    Dashboard.myModule.directive('whenReady', ['$interpolate', function ($interpolate) {
            return {
                restrict: 'A',
                priority: Number.MIN_VALUE,
                link: function ($scope, $element, $attributes) {
                    var expressions = $attributes.whenReady.split(';');
                    var waitForInterpolation = false;
                    var hasReadyCheckExpression = false;
                    function evalExpressions(expressions) {
                        expressions.forEach(function (expression) {
                            $scope.$eval(expression);
                        });
                    }
                    if ($attributes.whenReady.trim().length === 0) {
                        return;
                    }
                    if ($attributes.waitForInterpolation && $scope.$eval($attributes.waitForInterpolation)) {
                        waitForInterpolation = true;
                    }
                    if ($attributes.readyCheck) {
                        hasReadyCheckExpression = true;
                    }
                    if (waitForInterpolation || hasReadyCheckExpression) {
                        requestAnimationFrame(function checkIfReady() {
                            var isInterpolated = false;
                            var isReadyCheckTrue = false;
                            if (waitForInterpolation && $element.text().indexOf($interpolate.startSymbol()) >= 0) {
                                // if the text still has {{placeholders}}
                                isInterpolated = false;
                            }
                            else {
                                isInterpolated = true;
                            }
                            if (hasReadyCheckExpression && !$scope.$eval($attributes.readyCheck)) {
                                // if the ready check expression returns false
                                isReadyCheckTrue = false;
                            }
                            else {
                                isReadyCheckTrue = true;
                            }
                            if (isInterpolated && isReadyCheckTrue) {
                                evalExpressions(expressions);
                            }
                            else {
                                requestAnimationFrame(checkIfReady);
                            }
                        });
                    }
                    else {
                        evalExpressions(expressions);
                    }
                }
            };
        }]);
    /**
      * Directive to display the available map layers.
      */
    Dashboard.myModule.directive('dashboardirective', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {
                    container: '='
                },
                //template: html, // I use gulp automatian to compile the FeatureProperties.tpl.html to a simple TS file,
                //FeatureProperties.tpl.ts, which contains the html as string. The advantage is that you can use HTML intellisence in the html file.
                templateUrl: 'directives/DashboardDirectives/Dashboard/Dashboard.tpl.html',
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    angular.element($window).bind('resize', function () {
                        //scope.onResizeFunction();
                        scope.$apply();
                    });
                    scope.container = attrs.container;
                    //var s = jQuery.parseJSON(attrs.param);
                    scope.initDashboard();
                },
                replace: false,
                transclude: true,
                controller: Dashboard.DashboardCtrl
            };
        }
    ]);
})(Dashboard || (Dashboard = {}));
//# sourceMappingURL=Dashboard.js.map
var Dashboard;
(function (Dashboard_1) {
    var DashboardCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function DashboardCtrl($scope, $compile, $layerService, $mapService, $messageBusService, $dashboardService, $templateCache, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$compile = $compile;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.$templateCache = $templateCache;
            this.$timeout = $timeout;
            $scope.vm = this;
            $messageBusService.subscribe('project', function (e, f) {
                if (e === 'loaded') {
                    $scope.dashboard = null;
                }
            });
            $scope.initDashboard = function () {
                //if (!$scope.container) $scope.container = 'main';
                //$messageBusService.subscribe('dashboard-' + $scope.container, (s: string, d: csComp.Services.Dashboard) => {
                // In LayerService, you expect the name to be dashboard-main too.
                $messageBusService.subscribe('dashboard-main', function (s, d) {
                    _this.project = $layerService.project;
                    if (_this.project.activeDashboard) {
                        _this.closeDashboard();
                    }
                    _this.project.activeDashboard = d;
                    //alert(this.project.activeDashboard.id);
                    switch (s) {
                        case 'activated':
                            $scope.dashboard = d;
                            _this.updateDashboard();
                            break;
                    }
                });
                _this.$messageBusService.subscribe('expertMode', function (title, expertMode) {
                    if (title !== 'newExpertise')
                        return;
                    //Check whether timeline should be visible. Only when at least Intermediate expertise AND dashboard.showTimeline !== false
                    setTimeout(function () {
                        if (_this.project && _this.project.activeDashboard) {
                            var ad = _this.project.activeDashboard;
                            if (_this.$mapService.isIntermediate && (!ad.hasOwnProperty('showTimeline') || ad.showTimeline === true)) {
                                _this.$messageBusService.publish('timeline', 'isEnabled', true);
                            }
                            else {
                                _this.$messageBusService.publish('timeline', 'isEnabled', false);
                            }
                        }
                    }, 50);
                });
                //this.project.activeDashboard.widgets
                //this.updateDashboard();
                //alert($scope.dashboard.name);
            };
        }
        DashboardCtrl.prototype.closeDashboard = function () {
            this.project.activeDashboard.widgets.forEach(function (w) {
                if (w.stop) {
                    w.stop();
                }
                else if (w.elementId) {
                    // The stop() function of a widget sits in the controller. We can reach the controller through the 
                    // scope of the widget element. 
                    try {
                        var wElm = document.getElementById(w.elementId);
                        var wScope = angular.element((wElm.children[0]).children[0]).scope(); // The widget is a child of the widget-container
                        if (wScope && wScope.vm && wScope.vm.stop) {
                            wScope.vm.stop();
                        }
                    }
                    catch (e) { }
                }
            });
        };
        DashboardCtrl.prototype.toggleWidget = function (widget) {
            if (widget.canCollapse) {
                widget.collapse = !widget.collapse;
            }
        };
        DashboardCtrl.prototype.updateWidget = function (w) {
            //console.log('updating widget ' + w.directive);
            if (w._initialized && this.$scope.dashboard._initialized)
                return;
            w._initialized = true;
            var widgetElement;
            var newScope = this.$scope;
            newScope.widget = w;
            if (w.template) {
                widgetElement = this.$compile(this.$templateCache.get(w.template))(newScope);
            }
            else if (w.url) {
                widgetElement = this.$compile('<div>url</div>')(this.$scope);
            }
            else if (w.directive) {
                //var newScope : ng.IScope;
                widgetElement = this.$compile('<' + w.directive + '></' + w.directive + '>')(newScope);
            }
            else {
                widgetElement = this.$compile('<h1>hoi</h1>')(this.$scope);
            }
            var resized = function () {
                //alert('resize');
                /* do something */
            };
            if (widgetElement) {
                widgetElement.resize(resized);
                //alert(w.elementId);
                var el = $('#' + w.elementId);
                el.empty();
                el.append(widgetElement);
            }
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        DashboardCtrl.prototype.toggleInteract = function (widget) {
            widget._interaction = !widget._interaction;
            if (widget._interaction) {
                interact('#' + widget.elementId + '-parent').draggable(true);
            }
            else {
                interact('#' + widget.elementId + '-parent').draggable(false);
            }
        };
        DashboardCtrl.prototype.checkMap = function () {
            if (this.$scope.dashboard.showMap !== this.$layerService.visual.mapVisible) {
                if (this.$scope.dashboard.showMap) {
                    this.$layerService.visual.mapVisible = true;
                }
                else {
                    this.$layerService.visual.mapVisible = false;
                }
                if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                    this.$scope.$apply();
                }
            }
            if (this.$layerService.visual.mapVisible && this.$scope.dashboard.mapWidth) {
                this.$layerService.visual.mapWidth = this.$scope.dashboard.mapWidth;
                if (this.$scope.dashboard.alignMapRight) {
                    this.$layerService.visual.alignMapRight = true;
                }
                else {
                    this.$layerService.visual.alignMapRight = false;
                }
            }
            if (this.$scope.dashboard.viewBounds) {
                console.log('set bound');
                this.$layerService.activeMapRenderer.fitBounds(this.$scope.dashboard.viewBounds);
            }
            if (this.$scope.dashboard.showMap && this.$scope.dashboard.baselayer) {
                //this.$messageBusService.publish('map', 'setbaselayer', this.$scope.dashboard.baselayer);
                var layer = this.$layerService.$mapService.getBaselayer(this.$scope.dashboard.baselayer);
                this.$layerService.activeMapRenderer.changeBaseLayer(layer);
                this.$layerService.$mapService.changeBaseLayer(this.$scope.dashboard.baselayer);
            }
        };
        DashboardCtrl.prototype.checkLayers = function () {
            var _this = this;
            var db = this.$layerService.project.activeDashboard;
            if (db.visiblelayers && db.visiblelayers.length > 0 && this.$layerService.project.groups) {
                this.$layerService.project.groups.forEach(function (g) {
                    g.layers.forEach(function (l) {
                        if (l.enabled && db.visiblelayers.indexOf(l.reference) === -1) {
                            _this.$layerService.removeLayer(l);
                            l.enabled = false;
                        }
                        if (!l.enabled && db.visiblelayers.indexOf(l.reference) >= 0) {
                            _this.$layerService.addLayer(l);
                            l.enabled = true;
                        }
                    });
                });
            }
        };
        DashboardCtrl.prototype.checkViewbound = function () {
            if (this.project.activeDashboard && this.project.activeDashboard.viewBounds) {
                this.$layerService.activeMapRenderer.fitBounds(this.project.activeDashboard.viewBounds);
            }
        };
        DashboardCtrl.prototype.checkTimeline = function () {
            var d = this.$scope.dashboard;
            if (d.showTimeline !== this.$mapService.timelineVisible) {
                this.$mapService.timelineVisible = (d.showTimeline && this.$mapService.isIntermediate);
                if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                    this.$scope.$root.$apply();
                }
            }
            if (d.showTimeline && d.timeline) {
                //console.log('checkTimeline: dashboard has timeline');
                if (!_.isUndefined(d.timeline.fixedRange)) {
                    switch (d.timeline.fixedRange) {
                        case '24h':
                            d.timeline.end = Date.now();
                            d.timeline.start = Date.now() - 1000 * 60 * 24;
                            break;
                    }
                }
                this.$messageBusService.publish('timeline', 'updateTimerange', d.timeline);
                // now move the focustimeContainer to the right position
                if (d.timeline.focus && d.timeline.start && d.timeline.end &&
                    (d.timeline.focus > d.timeline.start) && (d.timeline.focus < d.timeline.end)) {
                    var f = (d.timeline.focus - d.timeline.start) / (d.timeline.end - d.timeline.start);
                    //var w = $('#timeline').width();           // unfortunately, on the first call,
                    //the timeline has a width of 100 (not resized yet)
                    //var w = $('#timeline').parent().width();  // does not help: = 0 on first call
                    var w = $('#map').width(); // this works but might be dangerous
                    var newpos = f * w - $('#focustimeContainer').width() / 2;
                    $('#focustimeContainer').css('left', newpos);
                }
            } // end RS mod
        };
        DashboardCtrl.prototype.setValue = function (diff, value) {
            if (!value || value.indexOf('%') >= 0)
                return value;
            var left = parseInt(value.replace('px', ''), 10);
            left += diff;
            return left + 'px';
        };
        DashboardCtrl.prototype.removeWidget = function (widget) {
            this.$scope.dashboard.widgets = this.$scope.dashboard.widgets.filter(function (w) {
                return w !== widget;
            });
        };
        DashboardCtrl.prototype.isReady = function (widget) {
            var _this = this;
            //this.updateWidget(widget);
            setTimeout(function () {
                if (!widget._ijs)
                    widget._ijs = interact('#' + widget.elementId + '-parent')
                        .resizable({ inertia: true })
                        .on('down', function (e) {
                        if (widget._interaction)
                            widget._isMoving = true;
                        // if (this.$dashboardService.activeWidget !== widget) {
                        //     //this.$dashboardService.editWidget(widget)
                        // }
                    })
                        .on('up', function (e) { return widget._isMoving = false; })
                        .on('dragmove', function (event) {
                        if (widget.left || (!widget.left && widget.left !== '')) {
                            widget.left = _this.setValue(event.dx, widget.left);
                            if (widget.width && widget.width !== '') {
                                widget.right = '';
                            }
                            else {
                                widget.right = _this.setValue(-event.dx, widget.right);
                            }
                        }
                        else {
                            if (!widget.right || widget.right === '') {
                                widget.right = 1000 + 'px';
                            }
                            widget.right = _this.setValue(-event.dx, widget.right);
                        }
                        if (widget.top && widget.top !== '') {
                            widget.top = _this.setValue(event.dy, widget.top);
                            if (widget.bottom) {
                                if (widget.height) {
                                    widget.bottom = '';
                                }
                                else {
                                    widget.bottom = _this.setValue(-event.dy, widget.bottom);
                                }
                            }
                        }
                        else {
                            widget.bottom = _this.setValue(-event.dy, widget.bottom);
                        }
                        if (_this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest') {
                            _this.$scope.$apply();
                        }
                    })
                        .on('resizemove', function (event) {
                        widget.height = _this.setValue(event.dy, widget.height);
                        if (widget.left && widget.right) {
                            widget.right = _this.setValue(-event.dx, widget.right);
                        }
                        else {
                            if (!widget.width)
                                widget.width = '300px';
                            widget.width = _this.setValue(event.dx, widget.width);
                        }
                        if (_this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest') {
                            _this.$scope.$apply();
                        }
                    });
            }, 10);
        };
        DashboardCtrl.prototype.checkLegend = function (d) {
            if (!d.showLegend)
                return;
            var legendWidgetPresent = false;
            d.widgets.forEach(function (w) {
                if (w.id === 'Legend')
                    legendWidgetPresent = true;
            });
            if (!legendWidgetPresent) {
                //console.log('Create legend');
                var w = {};
                w.directive = 'legend-directive';
                w.id = csComp.Helpers.getGuid();
                w.elementId = 'widget-' + w.id;
                w.parentDashboard = d;
                w.title = 'Legend';
                w.data = { mode: 'lastSelectedStyle' };
                w.left = '20px';
                w.customStyle = { background: 'White', borderColor: 'Black', borderWidth: '1px' };
                w.top = '80px';
                w.hideIfLeftPanel = true;
                w.width = '150px';
                w.enabled = true;
                d.widgets.push(w);
            }
        };
        ;
        DashboardCtrl.prototype.updateDashboard = function () {
            var _this = this;
            var d = this.$scope.dashboard;
            if (!d)
                return;
            this.checkLegend(d);
            this.checkMap();
            this.checkTimeline();
            this.checkLayers();
            this.checkViewbound();
            //this.$messageBusService.publish('leftmenu',(d.showLeftmenu) ? 'show' : 'hide');
            // if (!this.$mapService.isAdminExpert) {
            if (!d._initialized) {
                this.$layerService.visual.leftPanelVisible = d.showLeftmenu;
                this.$layerService.visual.rightPanelVisible = d.showRightmenu;
            }
            this.$timeout(function () {
                d.widgets.forEach(function (w) {
                    w._initialized = false;
                    _this.updateWidget(w);
                });
                // this.$timeout(() => {
                //     this.$scope.$watchCollection('dashboard.widgets', (da) => {
                //         this.$scope.dashboard.widgets.forEach((w: csComp.Services.IWidget) => {
                //             this.updateWidget(w);
                //         });
                //     });
                // }, 300);
                d._initialized = true;
            }, 500);
            //this.$layerService.rightMenuVisible = d.showLeftmenu;
            //this.$mapService.rightMenuVisible = d.showRightmenu;
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        //public dashboard: csComp.Services.Dashboard;
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        DashboardCtrl.$inject = [
            '$scope',
            '$compile',
            'layerService',
            'mapService',
            'messageBusService',
            'dashboardService',
            '$templateCache', '$timeout'
        ];
        return DashboardCtrl;
    }());
    Dashboard_1.DashboardCtrl = DashboardCtrl;
})(Dashboard || (Dashboard = {}));
//# sourceMappingURL=DashboardCtrl.js.map
var DashboarHeaderdSelection;
(function (DashboarHeaderdSelection) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        DashboarHeaderdSelection.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        DashboarHeaderdSelection.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    DashboarHeaderdSelection.myModule.directive('dashboardHeaderSelection', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/DashboardDirectives/DashboardSelection/DashboardHeaderSelection.tpl.html',
                replace: true,
                transclude: true,
                controller: DashboarHeaderdSelection.DashboardHeaderSelectionCtrl
            };
        }
    ]);
})(DashboarHeaderdSelection || (DashboarHeaderdSelection = {}));
//# sourceMappingURL=DashboardHeaderSelection.js.map
var DashboarHeaderdSelection;
(function (DashboarHeaderdSelection) {
    var DashboardHeaderSelectionCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function DashboardHeaderSelectionCtrl($scope, $layerService, $dashboardService, $mapService, $messageBusService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$dashboardService = $dashboardService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            $scope.vm = this;
        }
        DashboardHeaderSelectionCtrl.prototype.childDashboards = function (db) {
            var res = this.$layerService.project.dashboards.filter(function (d) { return (d.parents && d.parents.indexOf(db.id) > -1); });
            return res;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        DashboardHeaderSelectionCtrl.$inject = [
            '$scope',
            'layerService',
            'dashboardService',
            'mapService',
            'messageBusService'
        ];
        return DashboardHeaderSelectionCtrl;
    }());
    DashboarHeaderdSelection.DashboardHeaderSelectionCtrl = DashboardHeaderSelectionCtrl;
})(DashboarHeaderdSelection || (DashboarHeaderdSelection = {}));
//# sourceMappingURL=DashboardHeaderSelectionCtrl.js.map
var DashboardSelection;
(function (DashboardSelection) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        DashboardSelection.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        DashboardSelection.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    DashboardSelection.myModule.directive('dashboardSelection', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/DashboardDirectives/DashboardSelection/DashboardSelection.tpl.html',
                //template: html,   // I use gulp automatian to compile the FeatureProperties.tpl.html to a simple TS file, 
                // FeatureProperties.tpl.ts, which contains the html as string. The advantage is that you can use HTML intellisence in the html file.
                //compile             : el          => {    // I need to explicitly compile it in order to use interpolation like {{xxx}}
                //    var fn                        = $compile(el);
                //    return scope                  => {
                //        fn(scope);
                //    };
                //},
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: true,
                transclude: true,
                controller: DashboardSelection.DashboardSelectionCtrl
            };
        }
    ]).directive('bsPopover', function () {
        return function (scope, element, attrs) {
            element.find('a[rel=popover]').popover({ placement: 'right', html: 'true' });
        };
    });
})(DashboardSelection || (DashboardSelection = {}));
//# sourceMappingURL=DashboardSelection.js.map
var DashboardSelection;
(function (DashboardSelection) {
    var DashboardSelectionCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function DashboardSelectionCtrl($scope, $layerService, $dashboardService, $mapService, $messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$dashboardService = $dashboardService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            $scope.vm = this;
            this.$messageBusService.subscribe('project', function (s, a) {
                _this.style = 'default';
                _this.selectStyle();
            });
        }
        DashboardSelectionCtrl.prototype.initDrag = function (key) {
            var _this = this;
            var transformProp;
            var startx, starty;
            interact('#widgettype-' + key)
                .draggable({ max: Infinity })
                .on('dragstart', function (event) {
                startx = 0;
                starty = 0;
                event.interaction.x = parseInt(event.target.getAttribute('data-x'), 10) || 0;
                event.interaction.y = parseInt(event.target.getAttribute('data-y'), 10) || 0;
                event.target.style.width = '300px';
                event.target.style.height = '300px';
            })
                .on('dragmove', function (event) {
                event.interaction.x += event.dx;
                event.interaction.y += event.dy;
                event.target.style.left = event.interaction.x + 'px';
                event.target.style.top = event.interaction.y + 'px';
            })
                .on('dragend', function (event) {
                setTimeout(function () {
                    var widget = {};
                    widget.directive = key;
                    widget.id = csComp.Helpers.getGuid();
                    widget.left = (event.clientX - 350) + "px"; //(parseInt(event.target.style.left.replace('px', '')) - 150) + "px";
                    widget.top = (event.clientY - 50) + "px"; //(parseInt(event.target.style.top.replace('px', '')) - 150) + "px";
                    widget.data = {};
                    widget.width = '300px';
                    widget.height = '300px';
                    widget.style = _this.style;
                    widget.enabled = true;
                    csComp.Services.Dashboard.addNewWidget(widget, _this.$layerService.project.activeDashboard, _this.$layerService.solution);
                    _this.$dashboardService.editWidget(widget);
                }, 100);
                //this.$dashboardService.mainDashboard.widgets.push(widget);
                event.target.setAttribute('data-x', 0);
                event.target.setAttribute('data-y', 0);
                event.target.style.left = '0px';
                event.target.style.top = '0px';
                event.target.style.width = '75px';
                event.target.style.height = '75px';
                //console.log(key);
            });
        };
        DashboardSelectionCtrl.prototype.startWidgetEdit = function (widget) {
            this.$dashboardService.editWidget(widget);
        };
        /**
        * Start editing a specific dashboard
        */
        DashboardSelectionCtrl.prototype.startDashboardEdit = function (dashboard) {
            var rpt = new csComp.Services.RightPanelTab();
            rpt.container = 'dashboard';
            rpt.data = dashboard;
            rpt.directive = 'dashboardedit';
            this.$messageBusService.publish('rightpanel', 'activate', rpt);
            this.$layerService.project.dashboards.forEach(function (d) {
                if (d.id !== dashboard.id) {
                    d.editMode = false;
                    d.disabled = true;
                }
            });
            this.$dashboardService.stopEditWidget();
        };
        /**
        * Stop editing a specific dashboard
        */
        DashboardSelectionCtrl.prototype.stopDashboardEdit = function (dashboard) {
            this.$layerService.project.dashboards.forEach(function (d) {
                d.disabled = false;
                d.editMode = false;
            });
            this.$dashboardService.stopEditWidget();
        };
        DashboardSelectionCtrl.prototype.stopEdit = function () {
            this.stopDashboardEdit(this.$layerService.project.activeDashboard);
        };
        DashboardSelectionCtrl.prototype.startEdit = function () { };
        DashboardSelectionCtrl.prototype.widgetHighlight = function (widget) {
            widget.hover = true;
        };
        DashboardSelectionCtrl.prototype.widgetStopHighlight = function (widget) {
            widget.hover = false;
        };
        /** Add new dashboard */
        DashboardSelectionCtrl.prototype.addDashboard = function (widget) {
            var d = new csComp.Services.Dashboard();
            d.id = csComp.Helpers.getGuid();
            d.showLeftmenu = true;
            d.showMap = true;
            d.name = 'New Dashboard';
            this.$layerService.project.dashboards.push(d);
        };
        /** Remove existing dashboard */
        DashboardSelectionCtrl.prototype.removeDashboard = function (key) {
            this.$layerService.project.dashboards = this.$layerService.project.dashboards.filter(function (s) { return s.id !== key; });
        };
        DashboardSelectionCtrl.prototype.selectStyle = function () {
            this.$scope.widgetStyle = this.$layerService.solution.widgetStyles[this.style];
            console.log(this.$scope.widgetStyle);
        };
        /** publish a message that a new dashboard was selected */
        DashboardSelectionCtrl.prototype.publishDashboardUpdate = function () {
            this.$messageBusService.publish('dashboard', 'onDashboardSelected', this.$layerService.project.activeDashboard);
        };
        /** Select an active dashboard */
        DashboardSelectionCtrl.prototype.selectDashboard = function (dashboard) {
            var _this = this;
            //var res = JSON.stringify(this.$dashboardService.dashboards);
            for (var key in this.$layerService.project.dashboards) {
                this.$layerService.project.dashboards[key].editMode = false;
            }
            if (dashboard) {
                //this.$dashboardService.mainDashboard = dashboard;
                if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                    this.$scope.$apply();
                }
                setTimeout(function () {
                    //this.$dashboardService.checkMap();
                    //this.checkTimeline();
                    //this.checkViewbound();
                    _this.publishDashboardUpdate();
                    //this.checkLayers();
                }, 100);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        DashboardSelectionCtrl.$inject = [
            '$scope',
            'layerService',
            'dashboardService',
            'mapService',
            'messageBusService'
        ];
        return DashboardSelectionCtrl;
    }());
    DashboardSelection.DashboardSelectionCtrl = DashboardSelectionCtrl;
})(DashboardSelection || (DashboardSelection = {}));
//# sourceMappingURL=DashboardSelectionCtrl.js.map
var Search;
(function (Search) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Search.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Search.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    Search.myModule.directive('searchHeader', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {
                    container: '='
                },
                //template: html, // I use gulp automatian to compile the FeatureProperties.tpl.html to a simple TS file, FeatureProperties.tpl.ts, which contains the html as string. The advantage is that you can use HTML intellisence in the html file.
                templateUrl: 'directives/DashboardDirectives/Search/Search.tpl.html',
                link: function (scope, element, attrs) {
                },
                replace: false,
                transclude: true,
                controller: Search.SearchCtrl
            };
        }
    ]);
})(Search || (Search = {}));
//# sourceMappingURL=Search.js.map
var Search;
(function (Search) {
    var SearchCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function SearchCtrl($scope, $compile, $layerService, $mapService, $messageBusService, $dashboardService, $templateCache, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$compile = $compile;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.$templateCache = $templateCache;
            this.$timeout = $timeout;
            $scope.vm = this;
            $scope.$watch('vm.query', _.throttle(function (search) {
                _this.$dashboardService.search = { query: search };
            }, 500));
        }
        SearchCtrl.prototype.startSearch = function () {
            if (this.$scope.sv) {
                setTimeout(function () {
                    $('#searchInput').focus();
                }, 100);
            }
        };
        //public dashboard: csComp.Services.Dashboard;
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        SearchCtrl.$inject = [
            '$scope',
            '$compile',
            'layerService',
            'mapService',
            'messageBusService',
            'dashboardService',
            '$templateCache',
            '$timeout'
        ];
        return SearchCtrl;
    }());
    Search.SearchCtrl = SearchCtrl;
})(Search || (Search = {}));
//# sourceMappingURL=SearchCtrl.js.map
var DashboardEdit;
(function (DashboardEdit) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        DashboardEdit.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        DashboardEdit.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    DashboardEdit.myModule.directive('dashboardedit', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/DashboardDirectives/WidgetEdit/DashboardEdit.tpl.html',
                replace: true,
                transclude: true,
                controller: DashboardEdit.DashboardEditCtrl
            };
        }
    ]);
})(DashboardEdit || (DashboardEdit = {}));
//# sourceMappingURL=DashboardEdit.js.map
var DashboardEdit;
(function (DashboardEdit) {
    var DashboardEditCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function DashboardEditCtrl($scope, $mapService, $layerService, $messageBusService, $dashboardService) {
            this.$scope = $scope;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.scope = $scope;
            $scope.vm = this;
            this.dashboard = $scope.$parent["data"];
            if (this.dashboard.parents && this.dashboard.parents.length > 0)
                this.parent = this.dashboard.parents[0];
            this.updateHasParent();
            console.log(this.$dashboardService.widgetTypes);
            // setup draggable elements.
        }
        DashboardEditCtrl.prototype.updateHasParent = function () {
            // if (this.parent !== "") this.dashboard.parents = [this.parent];
            // this.hasParent = this.dashboard.parents && this.dashboard.parents.length > 0;
        };
        DashboardEditCtrl.prototype.toggleTimeline = function () {
            //this.$dashboardService.mainDashboard.showTimeline = !this.$dashboardService.mainDashboard.showTimeline;
            this.checkTimeline();
            this.$layerService.project.dashboards;
        };
        DashboardEditCtrl.prototype.toggleLegend = function () {
            this.checkLegend();
            this.$layerService.project.dashboards;
        };
        DashboardEditCtrl.prototype.setExtent = function () {
            this.dashboard.viewBounds = this.$layerService.activeMapRenderer.getExtent();
            console.log('set extent');
        };
        DashboardEditCtrl.prototype.setVisibleLayers = function () {
            this.dashboard.visiblelayers = [];
            for (var id in this.$layerService.loadedLayers)
                this.dashboard.visiblelayers.push(id);
        };
        DashboardEditCtrl.prototype.setBaseLayer = function () {
            this.dashboard.baselayer = this.$mapService.activeBaseLayerId;
        };
        DashboardEditCtrl.prototype.toggleMap = function () {
            var _this = this;
            setTimeout(function () {
                _this.checkMap();
            }, 100);
        };
        DashboardEditCtrl.prototype.checkMap = function () {
            var db = this.$layerService.project.activeDashboard;
            if (db.showMap !== this.$layerService.visual.mapVisible) {
                if (db.showMap) {
                    this.$layerService.visual.mapVisible = true;
                }
                else {
                    this.$layerService.visual.mapVisible = false;
                }
                if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                    this.$scope.$apply();
                }
            }
            if (db.showMap && this.dashboard.baselayer) {
                //this.$messageBusService.publish("map", "setbaselayer", this.dashboard.baselayer);
                var layer = this.$layerService.$mapService.getBaselayer(this.dashboard.baselayer);
                this.$layerService.activeMapRenderer.changeBaseLayer(layer);
                this.$layerService.$mapService.changeBaseLayer(this.dashboard.baselayer);
                this.$layerService.$mapService.changeBaseLayer(this.dashboard.baselayer);
            }
        };
        DashboardEditCtrl.prototype.checkTimeline = function () { };
        DashboardEditCtrl.prototype.checkLegend = function () {
            var db = this.$layerService.project.activeDashboard;
            if (!db.showLegend) {
                var idxDelete = -1;
                db.widgets.forEach(function (w, idx) {
                    if (w.id === 'legend') {
                        idxDelete = idx;
                    }
                });
                if (idxDelete > -1)
                    db.widgets.splice(idxDelete, 1);
            }
            this.$dashboardService.selectDashboard(db, 'main');
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        DashboardEditCtrl.$inject = [
            '$scope',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return DashboardEditCtrl;
    }());
    DashboardEdit.DashboardEditCtrl = DashboardEditCtrl;
})(DashboardEdit || (DashboardEdit = {}));
//# sourceMappingURL=DashboardEditCtrl.js.map
var WidgetEdit;
(function (WidgetEdit) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        WidgetEdit.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        WidgetEdit.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    WidgetEdit.myModule.directive('widgetedit', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/DashboardDirectives/WidgetEdit/WidgetEdit.tpl.html',
                replace: true,
                transclude: true,
                controller: WidgetEdit.WidgetEditCtrl
            };
        }
    ]);
})(WidgetEdit || (WidgetEdit = {}));
//# sourceMappingURL=WidgetEdit.js.map
var WidgetEdit;
(function (WidgetEdit) {
    var WidgetEditCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function WidgetEditCtrl($scope, mapService, layerService, messageBusService, dashboardService) {
            this.$scope = $scope;
            this.mapService = mapService;
            this.layerService = layerService;
            this.messageBusService = messageBusService;
            this.dashboardService = dashboardService;
            this.scope = $scope;
            $scope.vm = this;
            $scope.widget = dashboardService.activeWidget;
        }
        WidgetEditCtrl.prototype.selectStyle = function () {
            var style = this.$scope.widget.style;
            if (style === "custom") {
                this.$scope.widget.customStyle = JSON.parse(JSON.stringify(this.$scope.widget.effectiveStyle));
                this.$scope.widget.effectiveStyle = this.$scope.widget.customStyle;
            }
            else {
                this.$scope.widget.effectiveStyle = this.layerService.solution.widgetStyles[style];
                this.$scope.widget.customStyle = null;
            }
        };
        WidgetEditCtrl.prototype.removeWidget = function (widget) {
            widget.parentDashboard.widgets = widget.parentDashboard.widgets.filter(function (w) { return widget.id != w.id; });
            this.dashboardService.deactivateTabContainer("widget-content");
            this.dashboardService.deactivateTabContainer("widget");
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        WidgetEditCtrl.$inject = [
            '$scope',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return WidgetEditCtrl;
    }());
    WidgetEdit.WidgetEditCtrl = WidgetEditCtrl;
})(WidgetEdit || (WidgetEdit = {}));
//# sourceMappingURL=WidgetEditCtrl.js.map
var FeatureTypeEditor;
(function (FeatureTypeEditor) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        FeatureTypeEditor.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FeatureTypeEditor.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    FeatureTypeEditor.myModule.directive('featureTypeEditor', ['$compile',
        function ($compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {
                    featureTypeId: '='
                },
                templateUrl: 'directives/Editors/FeatureTypeEditor/FeatureTypeEditor.tpl.html',
                replace: true,
                transclude: true,
                controller: FeatureTypeEditor.FeatureTypeEditorCtrl
            };
        }
    ])
        .directive('errSrc', function () {
        return {
            link: function (scope, element, attrs) {
                element.bind('error', function () {
                    if (attrs.src != attrs.errSrc) {
                        attrs.$set('src', attrs.errSrc);
                    }
                });
            }
        };
    });
})(FeatureTypeEditor || (FeatureTypeEditor = {}));
//# sourceMappingURL=FeatureTypeEditor.js.map
var FeatureTypeEditor;
(function (FeatureTypeEditor) {
    var FeatureTypeEditorCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function FeatureTypeEditorCtrl($scope, $layerService, $messageBusService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$scope.vm = this;
            if (this.$scope.$parent.$parent.vm.hasOwnProperty('selectedFeatureType')) {
                $scope.featureType = this.$scope.$parent.$parent.vm.selectedFeatureType;
            }
            else if (this.$scope.$root.hasOwnProperty('data')) {
                $scope.featureType = $scope.$root.data;
            }
            else {
                console.log('no feature type');
            }
        }
        /** force features to be updated */
        FeatureTypeEditorCtrl.prototype.updateFeatureTypes = function (ft) {
            if (!_.isUndefined(ft._resource))
                this.$layerService.saveResource(ft._resource);
            console.log('updating ..');
            this.$layerService.updateFeatureTypes(ft);
        };
        ;
        /** apply updates to features, don't return or save back to api */
        FeatureTypeEditorCtrl.prototype.apply = function () {
            this.$layerService.updateFeatureTypes(this.$scope.featureType);
        };
        FeatureTypeEditorCtrl.prototype.cancel = function () {
            this.$messageBusService.publish("featuretype", "stopEditing");
        };
        /** save a resource (back to api and update features) */
        FeatureTypeEditorCtrl.prototype.saveFeatureType = function () {
            if (!this.$scope.featureType._isInitialized) {
                this.$scope.featureType.id = this.$scope.featureType.name;
                this.$layerService.initFeatureType(this.$scope.featureType, null);
                this.$scope.featureType._resource.featureTypes[this.$scope.featureType.id] = this.$scope.featureType;
            }
            this.$layerService.saveResource(this.$scope.featureType._resource);
            this.$layerService.updateFeatureTypes(this.$scope.featureType);
            this.$messageBusService.publish("featuretype", "stopEditing");
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        FeatureTypeEditorCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return FeatureTypeEditorCtrl;
    }());
    FeatureTypeEditor.FeatureTypeEditorCtrl = FeatureTypeEditorCtrl;
})(FeatureTypeEditor || (FeatureTypeEditor = {}));
//# sourceMappingURL=FeatureTypeEditorCtrl.js.map
var FeatureTypes;
(function (FeatureTypes) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        FeatureTypes.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FeatureTypes.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    FeatureTypes.myModule.directive('featuretypes', ['$compile',
        function ($compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Editors/FeatureTypeEditor/FeatureTypes.tpl.html',
                replace: true,
                transclude: true,
                controller: FeatureTypes.FeatureTypesCtrl
            };
        }
    ])
        .directive('errSrc', function () {
        return {
            link: function (scope, element, attrs) {
                element.bind('error', function () {
                    if (attrs.src != attrs.errSrc) {
                        attrs.$set('src', attrs.errSrc);
                    }
                });
            }
        };
    });
})(FeatureTypes || (FeatureTypes = {}));
//# sourceMappingURL=FeatureTypes.js.map
var FeatureTypes;
(function (FeatureTypes) {
    var FeatureTypesCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function FeatureTypesCtrl($scope, $layerService, $messageBusService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$scope.vm = this;
            if (this.$scope.$root.hasOwnProperty('data')) {
                $scope.data = $scope.$root['data'];
                this.selectedResourceUrl = $scope.data.layer.typeUrl;
                this.selectResource();
            }
            console.log(this.$scope);
        }
        //** force features to be updated */
        FeatureTypesCtrl.prototype.updateFeatureTypes = function (ft) {
            this.$layerService.updateFeatureTypes(ft);
        };
        ;
        //** select a typesResource collection from the dropdown */
        FeatureTypesCtrl.prototype.selectResource = function () {
            if (this.$layerService.typesResources.hasOwnProperty(this.selectedResourceUrl)) {
                this.selectedResource = this.$layerService.typesResources[this.selectedResourceUrl];
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        FeatureTypesCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return FeatureTypesCtrl;
    }());
    FeatureTypes.FeatureTypesCtrl = FeatureTypesCtrl;
})(FeatureTypes || (FeatureTypes = {}));
//# sourceMappingURL=FeatureTypesCtrl.js.map
var GroupEdit;
(function (GroupEdit) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        GroupEdit.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        GroupEdit.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    GroupEdit.myModule.directive('groupedit', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Editors/GroupEditor/GroupEdit.tpl.html',
                replace: true,
                transclude: true,
                controller: GroupEdit.GroupEditCtrl
            };
        }
    ]);
})(GroupEdit || (GroupEdit = {}));
//# sourceMappingURL=GroupEdit.js.map
var GroupEdit;
(function (GroupEdit) {
    var GroupEditCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function GroupEditCtrl($scope, $mapService, $layerService, $messageBusService, $dashboardService) {
            var _this = this;
            this.$scope = $scope;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.noLayerSelected = true;
            this.scope = $scope;
            $scope.vm = this;
            $scope.group = $scope.$parent["data"];
            console.log($scope.group);
            this.updateLayers();
            this.$messageBusService.subscribe('layer', function () {
                _this.updateLayers();
            });
        }
        GroupEditCtrl.prototype.updateLayers = function () {
            this.noLayerSelected = this.$scope.group.layers.some(function (l) { return l.enabled; });
            //console.log("selected " + this.noLayerSelected)
            //this.$scope.group.oneLayerActive
        };
        GroupEditCtrl.prototype.removeGroup = function () {
            this.$layerService.removeGroup(this.$scope.group);
        };
        GroupEditCtrl.prototype.toggleClustering = function () {
            console.log('toggle clustering');
        };
        GroupEditCtrl.prototype.updateOws = function () {
            this.$scope.group.loadLayersFromOWS();
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        GroupEditCtrl.$inject = [
            '$scope',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return GroupEditCtrl;
    }());
    GroupEdit.GroupEditCtrl = GroupEditCtrl;
})(GroupEdit || (GroupEdit = {}));
//# sourceMappingURL=GroupEditCtrl.js.map
var LayerEdit;
(function (LayerEdit) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        LayerEdit.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        LayerEdit.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    LayerEdit.myModule.directive('layeredit', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Editors/LayerEditor/LayerEdit.tpl.html',
                replace: false,
                transclude: true,
                controller: LayerEdit.LayerEditCtrl
            };
        }
    ]);
})(LayerEdit || (LayerEdit = {}));
//# sourceMappingURL=LayerEdit.js.map
var LayerEdit;
(function (LayerEdit) {
    var LayerEditCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function LayerEditCtrl($scope, $http, $mapService, $layerService, $messageBusService, $dashboardService) {
            this.$scope = $scope;
            this.$http = $http;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.scope = $scope;
            $scope.vm = this;
            this.layer = $scope.$parent["data"];
            this.getTypes();
            var ft = {};
        }
        LayerEditCtrl.prototype.addLayer = function () {
        };
        LayerEditCtrl.prototype.removeLayer = function () {
            this.$layerService.removeLayer(this.layer, true);
        };
        LayerEditCtrl.prototype.addFeatureType = function () {
            var _this = this;
            if (this.layer.typeUrl) {
                this.$layerService.loadTypeResources(this.layer.typeUrl, this.layer.dynamicResource || false, function () {
                    if (_this.$layerService.typesResources.hasOwnProperty(_this.layer.typeUrl)) {
                        var r = _this.$layerService.typesResources[_this.layer.typeUrl];
                        var ft = {};
                        var id = _this.layer.typeUrl + "#" + _this.layer.defaultFeatureType;
                        ft.id = _this.layer.defaultFeatureType;
                        ft.name = ft.id;
                        ft.style = csComp.Helpers.getDefaultFeatureStyle(null);
                        if (!r.featureTypes.hasOwnProperty(id)) {
                            var ft = {};
                            ft.id = _this.layer.defaultFeatureType;
                            ft.name = ft.id;
                            // EV already called before.
                            //ft.style = csComp.Helpers.getDefaultFeatureStyle();
                            //if (ft.name.toLowerCase().startsWith("http://")) id = ft.name;
                            //if (csComp.Helpers.startsWith(name.toLowerCase(), "http://")) return name;
                            _this.$layerService._featureTypes[id] = ft;
                            r.featureTypes[ft.id] = ft;
                        }
                    }
                });
            }
        };
        LayerEditCtrl.prototype.getTypes = function () {
            var _this = this;
            console.log('its me babe');
            this.$http.get(this.layer.typeUrl)
                .success(function (response) {
                setTimeout(function () {
                    _this.availabeTypes = response.featureTypes;
                    console.log(_this.availabeTypes);
                }, 0);
            })
                .error(function () { console.log('LayerEditCtl: error with $http'); });
        };
        ;
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        LayerEditCtrl.$inject = [
            '$scope',
            '$http',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return LayerEditCtrl;
    }());
    LayerEdit.LayerEditCtrl = LayerEditCtrl;
})(LayerEdit || (LayerEdit = {}));
//# sourceMappingURL=LayerEditCtrl.js.map
var LayerEditor;
(function (LayerEditor) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        LayerEditor.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        LayerEditor.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    LayerEditor.myModule.directive('layereditor', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {
                    view: "@",
                    layer: "="
                },
                templateUrl: 'directives/Editors/LayerEditor/LayerEditor.tpl.html',
                replace: false,
                transclude: true,
                controller: LayerEditor.LayerEditorCtrl
            };
        }
    ]);
})(LayerEditor || (LayerEditor = {}));
//# sourceMappingURL=LayerEditor.js.map
var LayerEditor;
(function (LayerEditor) {
    var LayerEditorCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function LayerEditorCtrl($scope, $http, $mapService, $layerService, $messageBusService, $dashboardService) {
            this.$scope = $scope;
            this.$http = $http;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.scope = $scope;
            $scope.vm = this;
            if (!this.scope.layer) {
                if ($scope.$parent.hasOwnProperty("b")) {
                    this.layer = $scope.$parent["b"]["_layer"];
                }
                else if ($scope.$parent.$parent.hasOwnProperty("vm"))
                    this.layer = $scope.$parent.$parent["vm"]["layer"];
            }
            else {
                this.layer = this.scope.layer;
            }
            var ft = {};
            // ft.style.drawingMode
        }
        LayerEditorCtrl.prototype.startDraw = function (featureType, event) {
            if (event)
                event.stopPropagation();
            this.$mapService.startDraw(this.layer, featureType);
        };
        LayerEditorCtrl.prototype.initDrag = function (key, layer) {
            var _this = this;
            var transformProp;
            var startx, starty;
            var tr = this.$layerService.findResourceByLayer(layer);
            var i = interact('#layerfeaturetype-' + tr.featureTypes[key]._guid).draggable({
                'onmove': function (event) {
                    var target = event.target;
                    var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                    var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                    // translate the element
                    target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';
                    // update the posiion attributes
                    target.setAttribute('data-x', x);
                    target.setAttribute('data-y', y);
                },
                'onend': function (event) {
                    console.log('Draggable: ', event);
                    setTimeout(function () {
                        var x = event.clientX;
                        var y = event.clientY;
                        var pos = _this.$layerService.activeMapRenderer.getLatLon(x, y);
                        console.log(pos);
                        var f = new csComp.Services.Feature();
                        f.layerId = layer.id;
                        f.geometry = {
                            type: 'Point', coordinates: [pos.lon, pos.lat]
                        };
                        f.properties = { "featureTypeId": key, "Name": fid };
                        var fid = "new object";
                        if (tr.featureTypes.hasOwnProperty(key)) {
                            var ft = tr.featureTypes[key];
                            if (!ft._isInitialized) {
                                _this.$layerService.initFeatureType(ft, tr.propertyTypeData);
                            }
                            if (_.isArray(ft._propertyTypeData)) {
                                for (var k in ft._propertyTypeData) {
                                    var pt = ft._propertyTypeData[k];
                                    ft._propertyTypeData.forEach(function (pt) {
                                        f.properties[pt.label] = _.isUndefined(pt.defaultValue) ? "" : pt.defaultValue;
                                    });
                                }
                            }
                            fid = ft.name;
                        }
                        layer.data.features.push(f);
                        _this.$messageBusService.publish("feature", "dropped", f);
                        _this.$layerService.initFeature(f, layer);
                        _this.$layerService.activeMapRenderer.addFeature(f);
                        _this.$layerService.saveFeature(f);
                        _this.$layerService.editFeature(f, true);
                    }, 10);
                    $(event.target).remove();
                }
            }).on('move', function (event) {
                var interaction = event.interaction;
                // if the pointer was moved while being held down
                // and an interaction hasn't started yet
                if (interaction.pointerIsDown && !interaction.interacting() && event.currentTarget.classList.contains('drag-element-source')) {
                    var original = event.target;
                    var pos = { left: 0, top: 0 }; //$(original).offset();
                    // create a clone of the currentTarget element
                    var clone = event.currentTarget.cloneNode(true);
                    // Remove CSS class using JS only (not jQuery or jQLite) - http://stackoverflow.com/a/2155786/4972844
                    clone.className = clone.className.replace(/\bdrag-element-source\b/, '');
                    pos.left = event.clientX - 20; //-interaction.startOffset.left;
                    pos.top = event.clientY - 20; //-interaction.startOffset.top;
                    // update the posiion attributes
                    //  clone.setAttribute('data-x', pos.left);
                    // clone.setAttribute('data-y', pos.top);
                    $(clone).css("left", pos.left);
                    $(clone).css("top", pos.top);
                    $(clone).css("z-index", 1000);
                    // insert the clone to the page
                    // TODO: position the clone appropriately
                    $(document.body).append(clone);
                    // start a drag interaction targeting the clone
                    interaction.start({ name: 'drag' }, event.interactable, clone);
                }
                else {
                    interaction.start({ name: 'drag' }, event.interactable, event.currentTarget);
                }
            });
        };
        LayerEditorCtrl.prototype.deleteFeaturetype = function (type) {
            var _this = this;
            this.$messageBusService.confirm('Delete type', 'Are you sure?', function (result) {
                if (result) {
                    var r = _this.$layerService.findResourceByLayer(_this.layer);
                    if (r) {
                        for (var ft in r.featureTypes) {
                            if (r.featureTypes[ft].id === r.url + "#" + type.id || r.featureTypes[ft].id === type.id) {
                                delete r.featureTypes[ft];
                            }
                        }
                        _this.$layerService.saveResource(r);
                        _this.$messageBusService.publish('featuretype', 'stopEditing', type);
                    }
                }
            });
        };
        LayerEditorCtrl.prototype.editFeaturetype = function (type) {
            this.$messageBusService.publish('featuretype', 'startEditing', type);
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        LayerEditorCtrl.$inject = [
            '$scope',
            '$http',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return LayerEditorCtrl;
    }());
    LayerEditor.LayerEditorCtrl = LayerEditorCtrl;
})(LayerEditor || (LayerEditor = {}));
//# sourceMappingURL=LayerEditorCtrl.js.map
var LayerSettings;
(function (LayerSettings) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        LayerSettings.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        LayerSettings.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    LayerSettings.myModule.directive('layersettings', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Editors/LayerEditor/LayerSettings.tpl.html',
                replace: false,
                transclude: true,
                controller: LayerSettings.LayerSettingsCtrl
            };
        }
    ]);
})(LayerSettings || (LayerSettings = {}));
//# sourceMappingURL=LayerSettings.js.map
var LayerSettings;
(function (LayerSettings) {
    var LayerSettingsCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function LayerSettingsCtrl($scope, $http, $mapService, $layerService, $messageBusService, $dashboardService) {
            this.$scope = $scope;
            this.$http = $http;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.scope = $scope;
            $scope.vm = this;
            this.layer = $scope.$parent['data'];
            this.getTypes();
            var ft = {};
        }
        // public addLayer() {
        // }
        LayerSettingsCtrl.prototype.saveLayer = function () {
            this.$layerService.saveProject();
        };
        LayerSettingsCtrl.prototype.removeLayer = function () {
            this.$layerService.removeLayer(this.layer, true);
        };
        LayerSettingsCtrl.prototype.addFeatureType = function () {
            var _this = this;
            if (!this.layer.typeUrl)
                return;
            this.$layerService.loadTypeResources(this.layer.typeUrl, this.layer.dynamicResource || false, function () {
                if (_this.$layerService.typesResources.hasOwnProperty(_this.layer.typeUrl)) {
                    var r = _this.$layerService.typesResources[_this.layer.typeUrl];
                    var ft = {};
                    var id = _this.layer.typeUrl + '#' + _this.layer.defaultFeatureType;
                    ft.id = _this.layer.defaultFeatureType;
                    ft.name = ft.id;
                    ft.style = csComp.Helpers.getDefaultFeatureStyle(null);
                    if (!r.featureTypes.hasOwnProperty(id)) {
                        var ft = {};
                        ft.id = _this.layer.defaultFeatureType;
                        ft.name = ft.id;
                        ft.style = {};
                        ft.style.drawingMode = 'Point';
                        _this.$layerService._featureTypes[id] = ft;
                        r.featureTypes[ft.id] = ft;
                    }
                }
            });
        };
        LayerSettingsCtrl.prototype.getTypes = function () {
            var _this = this;
            this.$http.get(this.layer.typeUrl)
                .success(function (response) {
                setTimeout(function () {
                    _this.availabeTypes = response.featureTypes;
                    if (_this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest')
                        _this.$scope.$apply();
                }, 0);
            })
                .error(function () { console.log('LayerEditCtl.getTypes: error with $http'); });
        };
        ;
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        LayerSettingsCtrl.$inject = [
            '$scope',
            '$http',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return LayerSettingsCtrl;
    }());
    LayerSettings.LayerSettingsCtrl = LayerSettingsCtrl;
})(LayerSettings || (LayerSettings = {}));
//# sourceMappingURL=LayerSettingsCtrl.js.map
var PropertyTypes;
(function (PropertyTypes) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        PropertyTypes.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        PropertyTypes.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    PropertyTypes.myModule.directive('propertytypes', ['$compile',
        function ($compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Editors/PropertyTypeEditor/PropertyTypes.tpl.html',
                replace: true,
                transclude: true,
                controller: PropertyTypes.PropertyTypesCtrl
            };
        }
    ])
        .directive('ngEnter', function () {
        return function (scope, element, attrs) {
            element.bind("keydown keypress", function (event) {
                if (event.which === 13) {
                    scope.$apply(function () {
                        scope.$eval(attrs.ngEnter);
                    });
                    event.preventDefault();
                }
            });
        };
    });
})(PropertyTypes || (PropertyTypes = {}));
//# sourceMappingURL=PropertyTypes.js.map
var PropertyTypes;
(function (PropertyTypes) {
    var PropertyTypesCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function PropertyTypesCtrl($scope, $layerService, $messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.editModeMessageReceived = function (title) {
                switch (title) {
                    case "enable":
                        _this.$messageBusService.publish('sidebar', 'showEdit');
                        _this.$scope.vm = _this;
                        _this.$scope.propertyTypes = _this.$layerService.project.propertyTypeData;
                        break;
                    case 'disable':
                        _this.$messageBusService.publish('sidebar', 'hideEdit');
                        break;
                    default:
                }
                // NOTE EV: You need to call apply only when an event is received outside the angular scope.
                // However, make sure you are not calling this inside an angular apply cycle, as it will generate an error.
                if (_this.$scope.$root.$$phase !== '$apply' && _this.$scope.$root.$$phase !== '$digest') {
                    _this.$scope.$apply();
                }
            };
            /**
             * Callback function
             * @see {http://stackoverflow.com/questions/12756423/is-there-an-alias-for-this-in-typescript}
             * @see {http://stackoverflow.com/questions/20627138/typescript-this-scoping-issue-when-called-in-jquery-callback}
             * @todo {notice the strange syntax using a fat arrow =>, which is to preserve the this reference in a callback!}
             */
            this.sidebarMessageReceived = function (title) {
                //console.log("sidebarMessageReceived");
                switch (title) {
                    case "toggle":
                        _this.$scope.showMenu = !_this.$scope.showMenu;
                        break;
                    case "show":
                        _this.$scope.showMenu = true;
                        break;
                    case "showEdit":
                        _this.$scope.showMenuEdit = true;
                        break;
                    case "hide":
                        _this.$scope.showMenu = false;
                        break;
                    case "hideEdit":
                        _this.$scope.showMenuEdit = false;
                        break;
                    default:
                }
                // NOTE EV: You need to call apply only when an event is received outside the angular scope.
                // However, make sure you are not calling this inside an angular apply cycle, as it will generate an error.
                if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                    _this.$scope.$apply();
                }
            };
            console.log('prop editor');
            this.$scope.vm = this;
            this.$scope.showMenu = false;
            this.$scope.showMenuEdit = false;
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
            this.$messageBusService.subscribe("editmode", this.editModeMessageReceived);
            this.$messageBusService.subscribe("sidebar", this.sidebarMessageReceived);
            /**
             * Get all sections from the available PropertyTypes
             */
            $scope.getSections = function () {
                var propertyTypeData = _this.selectedResource.propertyTypeData;
                var newSections = new Array();
                for (var indexData in propertyTypeData) {
                    var add = true;
                    if (propertyTypeData[indexData].section != undefined) {
                        if (newSections.length == 0) {
                            newSections.push(propertyTypeData[indexData].section);
                        }
                        for (var indexNew in newSections) {
                            if (propertyTypeData[indexData].section == newSections[indexNew]) {
                                add = false;
                            }
                        }
                        if (add) {
                            newSections.push(propertyTypeData[indexData].section);
                        }
                    }
                }
                $scope.sections = newSections;
            };
            /**
             * Add a new section to sections array
             */
            $scope.addSection = function (name) {
                var sections = $scope.sections;
                var add = true;
                for (var index in sections) {
                    if (name == sections[index]) {
                        add = false;
                    }
                }
                if (add) {
                    $scope.sections.push(name);
                }
            };
            /**
             * Create an array with all the PropertyTypes for a features (or all features if no feature is selected)
             */
            $scope.filterProperty = function (selectedData) {
                var allPropertyTypes = _this.selectedResource.propertyTypeData;
                var propertyTypes = new Array();
                if (selectedData == undefined) {
                    // All property types are selected
                    for (var index in allPropertyTypes) {
                        propertyTypes.push(allPropertyTypes[index]);
                    }
                    $scope.propertyTypes = propertyTypes;
                }
                else {
                    // Property types of a feature is selected
                    var selectedPropertyTypes;
                    if (selectedData.propertyTypeKeys !== undefined) {
                        selectedPropertyTypes = selectedData.propertyTypeKeys.split(';');
                    }
                    for (var indexSelected in selectedPropertyTypes) {
                        for (var indexAll in allPropertyTypes) {
                            if (allPropertyTypes.hasOwnProperty(indexAll)) {
                                if (selectedPropertyTypes[indexSelected] == allPropertyTypes[indexAll].label) {
                                    propertyTypes.push(allPropertyTypes[indexAll]);
                                }
                            }
                        }
                    }
                    $scope.propertyTypes = propertyTypes;
                }
            };
        }
        //** select a typesResource collection from the dropdown */
        PropertyTypesCtrl.prototype.selectResource = function () {
            if (this.$layerService.typesResources.hasOwnProperty(this.selectedResourceUrl)) {
                this.selectedResource = this.$layerService.typesResources[this.selectedResourceUrl];
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        PropertyTypesCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return PropertyTypesCtrl;
    }());
    PropertyTypes.PropertyTypesCtrl = PropertyTypesCtrl;
})(PropertyTypes || (PropertyTypes = {}));
//# sourceMappingURL=PropertyTypesCtrl.js.map
var Agenda;
(function (Agenda) {
    /** Config */
    var moduleName = 'csComp';
    try {
        Agenda.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Agenda.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    Agenda.myModule.directive('agendaEdit', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Agenda/AgendaWidget-edit.tpl.html',
                replace: true,
                transclude: false,
                controller: AgendaWidgetEditCtrl
            };
        }
    ]);
    var AgendaWidgetEditCtrl = (function () {
        function AgendaWidgetEditCtrl($scope, $http, layerService, messageBusService, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.layerService = layerService;
            this.messageBusService = messageBusService;
            this.$timeout = $timeout;
            this.layers = [];
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget || par.data;
            if (!this.widget)
                return;
            $scope.data = this.widget.data;
            var selectedLayerId = $scope.data.selectedLayerId;
            layerService.project.groups.forEach(function (g) {
                g.layers.forEach(function (l) {
                    _this.layers.push(l);
                    if (l.id === selectedLayerId) {
                        _this.selectedLayer = l;
                    }
                });
            });
        }
        AgendaWidgetEditCtrl.prototype.update = function () {
            if (this.selectedLayer)
                this.widget.data.selectedLayerId = this.selectedLayer.id;
        };
        AgendaWidgetEditCtrl.$inject = [
            '$scope',
            '$http',
            'layerService',
            'messageBusService',
            '$timeout'
        ];
        return AgendaWidgetEditCtrl;
    }());
    Agenda.AgendaWidgetEditCtrl = AgendaWidgetEditCtrl;
})(Agenda || (Agenda = {}));
//# sourceMappingURL=AgendaWidget-edit.js.map
var Agenda;
(function (Agenda) {
    /** Config */
    var moduleName = 'csComp';
    try {
        Agenda.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Agenda.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    Agenda.myModule.directive('agenda', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Agenda/AgendaWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: AgendaWidgetCtrl
            };
        }
    ]);
    /**
     * The agenda widget does two things:
     * - it shows the relations of the currently selected feature, if any, as an agenda.
     * - it analyses a layer, if the 'agenda' tag is present in the ProjectLayer, for all events, i.e.
     *   features with a start and end time, and displays them on the timeline.
     */
    var AgendaWidgetCtrl = (function () {
        function AgendaWidgetCtrl($scope, $http, layerService, messageBusService, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.layerService = layerService;
            this.messageBusService = messageBusService;
            this.$timeout = $timeout;
            this.agenda = [];
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            if (this.widget) {
                $scope.data = this.widget.data;
            }
            else {
                $scope.data = par.data;
            }
            var selectedLayerId = $scope.data.selectedLayerId;
            if (layerService.project) {
                this.selectedLayer = layerService.findLayer(selectedLayerId);
            }
            else {
                messageBusService.subscribe('project', function (title) {
                    _this.selectedLayer = layerService.findLayer(selectedLayerId);
                });
            }
            messageBusService.subscribe('feature', function (action, feature) {
                switch (action) {
                    case 'onFeatureSelect':
                    case 'onRelationsUpdated':
                        _this.updateAgenda(feature);
                        break;
                    case 'onFeatureDeselect':
                        _this.clearAgenda();
                        break;
                }
            });
        }
        AgendaWidgetCtrl.prototype.clearAgenda = function () {
            this.title = '';
            this.agenda.length = 0;
        };
        AgendaWidgetCtrl.prototype.updateAgenda = function (feature) {
            var _this = this;
            if (!feature || !feature._gui)
                return;
            var eventStyle = feature.fType.eventStyle;
            if (!eventStyle || !feature._gui.hasOwnProperty('relations') || !feature._gui['relations'].hasOwnProperty(eventStyle.relationName))
                return;
            this.clearAgenda();
            this.title = feature.properties['Name'];
            var titleProp = eventStyle.title || 'Name', descProp = eventStyle.description || 'description', startProp = eventStyle.startTime || 'startTime', endProp = eventStyle.endTime || 'endTime';
            var eventList = feature._gui['relations'][eventStyle.relationName];
            eventList.forEach(function (e) {
                _this.agenda.push({
                    title: _this.getProperty(e, titleProp),
                    description: _this.getProperty(e, descProp),
                    startTime: _this.getProperty(e, startProp),
                    endTime: _this.getProperty(e, endProp)
                });
            });
        };
        AgendaWidgetCtrl.prototype.getProperty = function (feature, prop, defaultValue) {
            if (defaultValue === void 0) { defaultValue = ''; }
            var props = feature.properties;
            var propValue = props.hasOwnProperty(prop)
                ? props[prop]
                : defaultValue;
            feature.fType._propertyTypeData.some(function (pt) {
                if (pt.label !== prop)
                    return false;
                propValue = csComp.Helpers.convertPropertyInfo(pt, propValue);
                return true;
            });
            return propValue;
        };
        AgendaWidgetCtrl.$inject = [
            '$scope',
            '$http',
            'layerService',
            'messageBusService',
            '$timeout'
        ];
        return AgendaWidgetCtrl;
    }());
    Agenda.AgendaWidgetCtrl = AgendaWidgetCtrl;
})(Agenda || (Agenda = {}));
//# sourceMappingURL=AgendaWidget.js.map
var ButtonWidget;
(function (ButtonWidget) {
    /** Config */
    var moduleName = 'csComp';
    try {
        ButtonWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ButtonWidget.myModule = angular.module(moduleName, []);
    }
    /**
     * Directive (editor) for the button widget.
     */
    ButtonWidget.myModule.directive('buttonwidgetEdit', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/ButtonWidget/ButtonWidget-edit.tpl.html',
                replace: true,
                transclude: false,
                controller: ButtonWidgetEditCtrl
            };
        }
    ]);
    var ButtonWidgetEditCtrl = (function () {
        function ButtonWidgetEditCtrl($scope, $timeout, $messageBus, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$messageBus = $messageBus;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            $scope.methods = [
                { name: 'GET' },
                { name: 'PUT' },
                { name: 'POST' },
                { name: 'DELETE' }
            ];
            var par = $scope.$parent;
            this.widget = par.data;
            $scope.data = this.widget.data;
            if (!$scope.data.messages) {
                $scope.data.messages = [];
                this.addMessage();
            }
            else {
                $scope.selectedMessage = $scope.data.messages[0];
            }
        }
        ButtonWidgetEditCtrl.prototype.addMessage = function () {
            this.$scope.selectedMessage = {
                name: 'New message...',
                httpMethod: this.$scope.methods[2]
            };
            this.$scope.data.messages.push(this.$scope.selectedMessage);
        };
        ButtonWidgetEditCtrl.prototype.deleteMessage = function () {
            if (!this.$scope.selectedMessage)
                return;
            var index = this.$scope.data.messages.indexOf(this.$scope.selectedMessage);
            if (index < 0)
                return;
            this.$scope.data.messages.slice(index, 1);
            if (this.$scope.data.messages.length === 0)
                this.addMessage();
            else
                this.$scope.selectedMessage = this.$scope.data.messages[0];
        };
        // $inject annotation.
        ButtonWidgetEditCtrl.$inject = [
            '$scope',
            '$timeout',
            'messageBusService',
            'dashboardService'
        ];
        return ButtonWidgetEditCtrl;
    }());
    ButtonWidget.ButtonWidgetEditCtrl = ButtonWidgetEditCtrl;
})(ButtonWidget || (ButtonWidget = {}));
//# sourceMappingURL=ButtonWidget-edit.js.map
var ButtonWidget;
(function (ButtonWidget) {
    /** Config */
    var moduleName = 'csComp';
    try {
        ButtonWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ButtonWidget.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    ButtonWidget.myModule.directive('buttonwidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/ButtonWidget/ButtonWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: ButtonWidgetCtrl
            };
        }]);
    var ButtonWidgetCtrl = (function () {
        function ButtonWidgetCtrl($scope, $http, layerService, messageBusService, actionService, $timeout) {
            this.$scope = $scope;
            this.$http = $http;
            this.layerService = layerService;
            this.messageBusService = messageBusService;
            this.actionService = actionService;
            this.$timeout = $timeout;
            $scope.vm = this;
            var par = $scope.$parent;
            $scope.data = par.widget.data;
            if (typeof $scope.data.buttons === 'undefined') {
                $scope.data.buttons = [];
            }
            if (!_.isUndefined($scope.data.layerGroup)) {
                this.initLayerGroup();
            }
            else {
                this.$scope.buttons = this.$scope.data.buttons;
                this.initButtons();
            }
        }
        ButtonWidgetCtrl.prototype.initButtons = function () {
            var _this = this;
            this.$scope.buttons.forEach(function (b) {
                var actions = b.action.split(';');
                actions.forEach(function (act) {
                    switch (act.toLowerCase()) {
                        case 'activate timerange':
                            break;
                        case 'activate layer':
                            _this.checkLayer(b);
                            _this.messageBusService.subscribe('layer', function (a, l) { return _this.checkLayer(b); });
                            break;
                        case 'activate style':
                            _this.checkStyle(b);
                            _this.messageBusService.subscribe('updatelegend', function (a, l) { return _this.checkStyle(b); });
                            break;
                        case 'activate baselayer':
                            _this.checkBaselayer(b);
                            _this.messageBusService.subscribe('baselayer', function (a, l) { return _this.checkBaselayer(b); });
                            break;
                    }
                });
                if (b.defaultEnabled) {
                    _this.click(b);
                }
            });
        };
        ButtonWidgetCtrl.prototype.initLayerGroup = function () {
            var _this = this;
            this.checkLayerGroup();
            this.messageBusService.subscribe('layer', function (a, l) { return _this.checkLayerGroup(); });
        };
        ButtonWidgetCtrl.prototype.checkLayerGroup = function () {
            var _this = this;
            var group = this.layerService.findGroupById(this.$scope.data.layerGroup);
            this.$scope.buttons = [];
            if (!_.isUndefined(group)) {
                group.layers.forEach(function (l) {
                    var b = {
                        title: l.title,
                        action: 'Activate Layer',
                        layer: l.id,
                        showLegend: false
                    };
                    _this.$scope.buttons.push(b);
                    _this.checkLayer(b);
                });
            }
        };
        ButtonWidgetCtrl.prototype.checkBaselayer = function (b) {
            b._active = this.layerService.$mapService.activeBaseLayerId === b.layer;
        };
        /** start or stop editing, when starting all features are editable */
        ButtonWidgetCtrl.prototype.toggleEditLayer = function (b) {
            var _this = this;
            if (!_.isUndefined(b._layer)) {
                var layer = b._layer;
                if (layer._gui.hasOwnProperty('editing') && layer._gui['editing'] === true) {
                    layer.layerSource.stopEditing(layer);
                    layer.data.features.forEach(function (f) {
                        delete f._gui['editMode'];
                        _this.layerService.updateFeature(f);
                        _this.layerService.saveFeature(f);
                    });
                }
                else {
                    layer.layerSource.startEditing(layer);
                    layer.data.features.forEach(function (f) {
                        _this.layerService.editFeature(f, false);
                    });
                }
            }
        };
        ButtonWidgetCtrl.prototype.checkLayer = function (b) {
            b._layer = this.layerService.findLayer(b.layer);
            if (b.showLegend && b._layer.defaultLegend) {
                b._legend = this.layerService.getLayerLegend(b._layer);
                if (b._legend && b._legend.legendEntries && b._legend.legendEntries.length > 0) {
                    b._firstLegendLabel = b._legend.legendEntries[b._legend.legendEntries.length - 1].label;
                    b._lastLegendLabel = b._legend.legendEntries[0].label;
                }
            }
            if (_.isUndefined(b.image) && (!_.isUndefined(b._layer.image)))
                b.image = b._layer.image;
            if (!_.isUndefined(b._layer)) {
                b._disabled = false;
                b._active = b._layer.enabled;
                b._canEdit = b._layer.enabled && b._layer.isEditable;
            }
            else {
                b._disabled = true;
            }
        };
        ButtonWidgetCtrl.prototype.checkStyle = function (b) {
            var group = this.layerService.findGroupById(b.group);
            var prop = b.property;
            if (prop.indexOf('#') > -1)
                prop = prop.split('#')[1];
            if (typeof group !== 'undefined') {
                var selected = group.styles.filter(function (gs) {
                    return gs.property === prop;
                });
                if (selected.length === 0) {
                    b._active = false;
                }
                else {
                    if (!b.layer) {
                        b._active = true;
                    }
                    else {
                        b._active = (this.layerService.findLoadedLayer(b.layer)) ? true : false;
                    }
                }
                if (b._active && b.showLegend) {
                    b._legend = selected[0].activeLegend;
                    this.checkLegend(b);
                }
                else {
                    b._legend = null;
                }
            }
        };
        ButtonWidgetCtrl.prototype.checkLegend = function (b) {
            if (b._legend && b._legend.legendEntries.length > 0) {
                if (typeof b._lastLegendLabel === 'undefined')
                    b._lastLegendLabel = b._legend.legendEntries[0].label;
                if (typeof b._firstLegendLabel === 'undefined')
                    b._firstLegendLabel = b._legend.legendEntries[b._legend.legendEntries.length - 1].label;
            }
        };
        ButtonWidgetCtrl.prototype.click = function (b) {
            var _this = this;
            var actions = b.action.split(';');
            actions.forEach(function (act) {
                _this.actionService.execute(act.toLowerCase(), {
                    layerId: b.layer,
                    groupId: b.group,
                    propertyId: b.property,
                    zoomLevel: b.zoomLevel
                });
            });
            // switch (b.action) {
            //     case 'Activate TimeRange':
            //         console.log('time range');
            //         this.layerService.project.timeLine.start = new Date().getTime() - 1000 * 60 * 60 * 2;
            //         this.layerService.project.timeLine.end = new Date().getTime() + 1000 * 60 * 60 * 2;
            //         this.layerService.project.timeLine.focus = new Date().getTime();
            //         break;
            //     case 'Activate Layer':
            //         var pl = this.layerService.findLayer(b.layer);
            //         if (typeof pl !== 'undefined') {
            //             this.layerService.toggleLayer(pl);
            //         }
            //         break;
            //     case 'Activate Style':
            //         var group = this.layerService.findGroupById(b.group);
            //         if (typeof group !== 'undefined') {
            //             var propType = this.layerService.findPropertyTypeById(b.property);
            //             if (typeof propType !== 'undefined') {
            //                 this.layerService.setGroupStyle(group, propType);
            //             }
            //         }
            //         break;
            //     case 'Activate Baselayer':
            //         var layer: csComp.Services.BaseLayer = this.layerService.$mapService.getBaselayer(b.layer);
            //         this.layerService.activeMapRenderer.changeBaseLayer(layer);
            //         this.layerService.$mapService.changeBaseLayer(b.layer);
            //         break;
            // }
        };
        ButtonWidgetCtrl.prototype.createFilter = function (le, group, prop) {
            if (!le)
                return;
            var projGroup = this.layerService.findGroupById(group);
            var property = this.layerService.findPropertyTypeById(prop);
            var gf = new csComp.Services.GroupFilter();
            gf.property = prop.split('#').pop();
            gf.id = 'buttonwidget_filter';
            gf.group = projGroup;
            gf.filterType = 'row';
            gf.title = property.title;
            gf.rangex = [le.interval.min, le.interval.max];
            gf.filterLabel = le.label;
            console.log('Setting filter');
            this.layerService.rebuildFilters(projGroup);
            projGroup.filters = projGroup.filters.filter(function (f) { return f.id !== gf.id; });
            this.layerService.setFilter(gf, projGroup);
        };
        ButtonWidgetCtrl.$inject = [
            '$scope',
            '$http',
            'layerService',
            'messageBusService',
            'actionService',
            '$timeout'
        ];
        return ButtonWidgetCtrl;
    }());
    ButtonWidget.ButtonWidgetCtrl = ButtonWidgetCtrl;
})(ButtonWidget || (ButtonWidget = {}));
//# sourceMappingURL=ButtonWidget.js.map
var ChartsWidget;
(function (ChartsWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        ChartsWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ChartsWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    ChartsWidget.myModule.directive('chartsEdit', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Charts/Charts-edit.tpl.html',
                replace: true,
                transclude: true,
                controller: ChartsEditCtrl
            };
        }
    ]);
    var ChartsEditCtrl = (function () {
        function ChartsEditCtrl($scope, $timeout, $compile, $layerService, $templateCache, $messageBus, $mapService, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$compile = $compile;
            this.$layerService = $layerService;
            this.$templateCache = $templateCache;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.data;
            $scope.data = this.widget.data;
            this.loadChart();
        }
        ChartsEditCtrl.prototype.setupEditor = function () {
            this.editor = ace.edit("vegaeditor");
            //editor.setTheme("ace/theme/monokai");
            this.editor.getSession().setMode("ace/mode/json");
            this.editor.setValue(JSON.stringify(this.$scope.data.spec, null, '\t'));
            this.editor.clearSelection();
            this.editor.focus();
        };
        ChartsEditCtrl.prototype.loadChart = function () {
            this.$scope.spec = JSON.stringify(this.$scope.data.spec);
        };
        ChartsEditCtrl.prototype.updateChart = function () {
            this.$scope.data.spec = JSON.parse(this.editor.getValue());
            this.refreshChart();
            this.editor.focus();
        };
        ChartsEditCtrl.prototype.refreshChart = function () {
            var _this = this;
            vg.parse.spec(this.$scope.data.spec, function (chart) { chart({ el: "#vis" + _this.$scope.data._id }).update(); });
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        ChartsEditCtrl.$inject = [
            '$scope',
            '$timeout',
            '$compile',
            'layerService',
            '$templateCache',
            'messageBusService',
            'mapService', 'dashboardService'
        ];
        return ChartsEditCtrl;
    }());
    ChartsWidget.ChartsEditCtrl = ChartsEditCtrl;
})(ChartsWidget || (ChartsWidget = {}));
//# sourceMappingURL=Charts-edit.js.map
var ChartsWidget;
(function (ChartsWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        ChartsWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ChartsWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    ChartsWidget.myModule.directive('charts', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Charts/Charts.tpl.html',
                replace: true,
                transclude: false,
                controller: ChartsWidget.ChartCtrl
            };
        }
    ]);
})(ChartsWidget || (ChartsWidget = {}));
//# sourceMappingURL=Charts.js.map
var ChartsWidget;
(function (ChartsWidget) {
    var ChartData = (function () {
        function ChartData() {
        }
        return ChartData;
    }());
    ChartsWidget.ChartData = ChartData;
    var ChartCtrl = (function () {
        function ChartCtrl($scope, $timeout, $layerService, $messageBus, $mapService, $dashboardService) {
            var _this = this;
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            this.defaultSpec = {
                'width': 300,
                'height': 200,
                'padding': { 'top': 10, 'left': 30, 'bottom': 30, 'right': 10 },
                'data': [
                    {
                        'name': 'table',
                        'values': [
                            { 'x': 1, 'y': 28 }, { 'x': 2, 'y': 55 },
                            { 'x': 3, 'y': 43 }, { 'x': 4, 'y': 91 },
                            { 'x': 5, 'y': 81 }, { 'x': 6, 'y': 53 },
                            { 'x': 7, 'y': 19 }, { 'x': 8, 'y': 87 },
                            { 'x': 9, 'y': 52 }, { 'x': 10, 'y': 48 },
                            { 'x': 11, 'y': 24 }, { 'x': 12, 'y': 49 },
                            { 'x': 13, 'y': 87 }, { 'x': 14, 'y': 66 },
                            { 'x': 15, 'y': 17 }, { 'x': 16, 'y': 27 },
                            { 'x': 17, 'y': 68 }, { 'x': 18, 'y': 16 },
                            { 'x': 19, 'y': 49 }, { 'x': 20, 'y': 15 }
                        ]
                    }
                ],
                'scales': [
                    {
                        'name': 'x',
                        'type': 'ordinal',
                        'range': 'width',
                        'domain': { 'data': 'table', 'field': 'x' }
                    },
                    {
                        'name': 'y',
                        'type': 'linear',
                        'range': 'height',
                        'domain': { 'data': 'table', 'field': 'y' },
                        'nice': true
                    }
                ],
                'axes': [
                    { 'type': 'x', 'scale': 'x' },
                    { 'type': 'y', 'scale': 'y' }
                ],
                'marks': [
                    {
                        'type': 'rect',
                        'from': { 'data': 'table' },
                        'properties': {
                            'enter': {
                                'x': { 'scale': 'x', 'field': 'x' },
                                'width': { 'scale': 'x', 'band': true, 'offset': -1 },
                                'y': { 'scale': 'y', 'field': 'y' },
                                'y2': { 'scale': 'y', 'value': 0 }
                            },
                            'update': {
                                'fill': { 'value': 'steelblue' }
                            },
                            'hover': {
                                'fill': { 'value': 'red' }
                            }
                        }
                    }
                ]
            };
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            $scope.data = this.widget.data;
            $scope.data._id = this.widget.id;
            $('#' + this.widget.elementId).on('remove', function () {
                if (_this.generator)
                    _this.generator.stop();
            });
            //$scope.$on('destroy', () => {
        }
        ChartCtrl.prototype.initChart = function () {
            try {
                var d = this.$scope.data;
                var vgspec = d._spec || {};
                if (d.lite)
                    vgspec = vl.compile(d._spec);
                //parse(vgspec);
                if (vgspec)
                    var res = vg.embed('#vis' + d._id, vgspec, function (view, vega_spec) {
                        d._view = view;
                        //$('.vega-actions').css("display","none");
                        // Callback receiving the View instance and parsed Vega spec...
                        // The View resides under the '#vis' element
                    });
            }
            catch (e) {
            }
        };
        ChartCtrl.prototype.updateChart = function () {
            var _this = this;
            try {
                var d = this.$scope.data;
                var vgspec = d._spec;
                if (d.lite)
                    vgspec = vl.compile(d._spec);
                //if (d._view) d._view.update();
                vg.parse.spec(vgspec, function (chart) { chart({ el: "#vis" + _this.$scope.data._id }).update(); });
            }
            catch (e) {
            }
        };
        ChartCtrl.prototype.startChart = function () {
            var _this = this;
            var d = this.$scope.data;
            //console.log(d);
            // if a chart generator is specified, find it and start it
            if (d.generator) {
                if (d.generator.type && this.$dashboardService.chartGenerators.hasOwnProperty(d.generator.type)) {
                    this.generator = this.$dashboardService.chartGenerators[d.generator.type]();
                    this.generator.start(this);
                    return;
                }
            }
            else {
                // if no generator is specified, use the spec from data                
                d._spec = d.spec || this.defaultSpec;
                this.initChart();
                // check if a key is defined, a key can be used to listen to new data or complete vega specifications
                if (d.key) {
                    this.keyHandle = this.$layerService.$messageBusService.serverSubscribe(d.key, 'key', function (topic, msg) {
                        switch (msg.action) {
                            case 'key':
                                if (msg.data.item.hasOwnProperty('values')) {
                                    d._spec.data = msg.data.item.values;
                                }
                                else if (msg.data.item.hasOwnProperty('data')) {
                                    d._spec = msg.data.item;
                                }
                                _this.initChart();
                                break;
                        }
                    });
                }
            }
        };
        ChartCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'messageBusService',
            'mapService',
            'dashboardService'
        ];
        return ChartCtrl;
    }());
    ChartsWidget.ChartCtrl = ChartCtrl;
})(ChartsWidget || (ChartsWidget = {}));
//# sourceMappingURL=ChartsCtrl.js.map
var AreaFilter;
(function (AreaFilter) {
    var AreaFilterModel = (function () {
        function AreaFilterModel() {
            this.id = 'AreaFilterModel';
        }
        AreaFilterModel.prototype.stop = function () { };
        AreaFilterModel.prototype.addFeature = function (feature) { };
        AreaFilterModel.prototype.removeFeature = function (feature) { };
        AreaFilterModel.prototype.selectFeature = function (feature) { };
        AreaFilterModel.prototype.addLayer = function (layer) { };
        AreaFilterModel.prototype.removeLayer = function (layer) { };
        AreaFilterModel.prototype.getLayerActions = function (layer) {
            return null;
        };
        AreaFilterModel.prototype.getFeatureActions = function (feature) {
            if (!feature.geometry.type)
                return;
            switch (feature.geometry.type) {
                case 'MultiPolygon':
                case 'Polygon':
                    var setFilterActionOption = {
                        title: 'Set as area filter'
                    };
                    setFilterActionOption.callback = this.setAsFilter;
                    var resetFilterActionOption = {
                        title: 'Reset area filter'
                    };
                    resetFilterActionOption.callback = this.resetFilter;
                    return [setFilterActionOption, resetFilterActionOption];
                default:
                    console.log('Feature type name: ' + feature.featureTypeName);
                    return;
            }
        };
        AreaFilterModel.prototype.getFeatureHoverActions = function (feature) {
            return [];
        };
        AreaFilterModel.prototype.deselectFeature = function (feature) { };
        AreaFilterModel.prototype.updateFeature = function (feuture) { };
        AreaFilterModel.prototype.setAsFilter = function (feature, layerService) {
            if (!feature.geometry.type)
                return;
            switch (feature.geometry.type) {
                case 'MultiPolygon':
                case 'Polygon':
                    layerService.setFeatureAreaFilter(feature);
                    break;
            }
        };
        AreaFilterModel.prototype.resetFilter = function (feature, layerService) {
            if (!feature.geometry.type)
                return;
            switch (feature.geometry.type) {
                case 'MultiPolygon':
                case 'Polygon':
                    layerService.resetFeatureAreaFilter();
                    break;
            }
        };
        AreaFilterModel.prototype.init = function (layerService) {
            console.log('init AreaFilterActionService');
            this.layerService = layerService;
        };
        return AreaFilterModel;
    }());
    AreaFilter.AreaFilterModel = AreaFilterModel;
})(AreaFilter || (AreaFilter = {}));
//# sourceMappingURL=AreaFilter.js.map
var Filters;
(function (Filters) {
    var AreaFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function AreaFilterCtrl($scope, $layerService, $messageBus, $timeout, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$timeout = $timeout;
            this.$translate = $translate;
            $scope.vm = this;
            $translate('REMOVE').then(function (translation) {
                $scope.removeString = translation;
            });
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                setTimeout(function () { return _this.initAreaFilter(); });
                //$timeout.call(()=>this.initAreaFilter());
                $scope.options = (function () {
                    var res = [];
                    res.push([$scope.removeString, function () { return _this.remove(); }]);
                    return res;
                });
            }
        }
        AreaFilterCtrl.prototype.setAreaFilter = function (f) {
            if (f.geometry.type === 'Polygon') {
                this.isInsideFunction = csComp.Helpers.GeoExtensions.pointInsidePolygon;
            }
            else if (f.geometry.type === 'MultiPolygon') {
                this.isInsideFunction = csComp.Helpers.GeoExtensions.pointInsideMultiPolygon;
            }
            else {
                this.isInsideFunction = function () { return false; };
            }
        };
        AreaFilterCtrl.prototype.initAreaFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var feature = filter.value;
            var group = filter.group;
            var divid = 'filter_' + filter.id;
            this.setAreaFilter(filter.value);
            this.dcChart = dc.pieChart('#' + divid);
            this.$scope.$apply();
            var dcDim = group.ndx.dimension(function (d) {
                if (d.id && d.layer && d.layer.group && d.layer.group.markers && d.layer.group.markers.hasOwnProperty(d.id)) {
                    var marker = d.layer.group.markers[d.id];
                    return (marker.feature.geometry.coordinates);
                }
                return null;
            });
            filter.dimension = dcDim;
            this.helperDim = crossfilter([
                { title: "inside" },
                { title: "outside" }
            ]).dimension(function (d) { return d.title; });
            this.helperGroup = this.helperDim.group(function (d) {
                return d;
            });
            this.dcChart
                .width(175)
                .height(200)
                .slicesCap(4)
                .innerRadius(0)
                .dimension(this.helperDim)
                .group(this.helperGroup) // by default, pie charts will use group.key as the label
                .legend(dc.legend())
                .renderLabel(true)
                .label(function (d) { return d.value; })
                .on('renderlet', function (e) {
                _this.updateAreaFilter(_this.$scope.filter.value, false);
            });
            this.updateAreaFilter(this.$scope.filter.value);
        };
        AreaFilterCtrl.prototype.updateAreaFilter = function (feat, triggerRender) {
            var _this = this;
            if (triggerRender === void 0) { triggerRender = true; }
            if (!feat)
                return;
            var f = this.$scope.filter;
            if (!f.dimension)
                return;
            var group = f.group;
            this.setAreaFilter(feat);
            f.dimension.filterFunction(function (d) {
                if (d != null) {
                    return (_this.isInsideFunction(d, feat.geometry.coordinates));
                }
                return false;
            });
            this.helperGroup.all().forEach(function (hg) {
                if (hg.key === "inside") {
                    hg.value = f.dimension.top(Infinity).length;
                }
                if (hg.key === "outside") {
                    hg.value = f.dimension.groupAll().value() - f.dimension.top(Infinity).length;
                }
            });
            this.isEmpty = !(this.helperGroup.all().some(function (hg) { return hg.value !== 0; }));
            group.filterResult = f.dimension.top(Infinity);
            if (triggerRender) {
                this.$layerService.updateMapFilter(group);
                dc.renderAll();
            }
        };
        AreaFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        AreaFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            '$timeout',
            '$translate'
        ];
        return AreaFilterCtrl;
    }());
    Filters.AreaFilterCtrl = AreaFilterCtrl;
})(Filters || (Filters = {}));
//# sourceMappingURL=AreaFilterCtrl.js.map
var Filters;
(function (Filters) {
    var BarFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function BarFilterCtrl($scope, $layerService, $messageBus, $timeout, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$timeout = $timeout;
            this.$translate = $translate;
            $scope.vm = this;
            $scope.editMode = true;
            $translate('REMOVE').then(function (translation) {
                $scope.removeString = translation;
            });
            $translate('CREATE_SCATTER').then(function (translation) {
                $scope.createScatterString = translation;
            });
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            if ($scope && $scope.filter) {
                setTimeout(function () { return _this.initBarFilter(); });
                //$timeout.call(()=>this.initBarFilter());
                $scope.options = (function () {
                    var res = [];
                    res.push([$scope.removeString, function () { return _this.remove(); }]);
                    $scope.filter.group.filters.forEach(function (gf) {
                        if (gf.filterType === 'bar' && gf.property !== $scope.filter.property) {
                            res.push([$scope.createScatterString + ' ' + gf.title, function () { return _this.createScatter(gf); }]);
                        }
                    });
                    return res;
                });
            }
        }
        BarFilterCtrl.prototype.createScatter = function (gf) {
            this.$layerService.createScatterFilter(this.$scope.filter.group, this.$scope.filter.property, gf.property);
        };
        BarFilterCtrl.prototype.displayFilterRange = function (min, max) {
            if ((+min) > (+max)) {
                min = max;
            }
            var filter = this.$scope.filter;
            filter.from = filter.rangex[0] < min
                ? min
                : filter.rangex[0];
            filter.to = filter.rangex[1] > max
                ? max
                : filter.rangex[1];
            this.$scope.$apply();
        };
        BarFilterCtrl.prototype.initBarFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var group = filter.group;
            var divid = 'filter_' + filter.id;
            this.dcChart = dc.barChart('#' + divid);
            this.$scope.$apply();
            var info = (filter.meta['propertyInfo']) ? filter.meta['propertyInfo'] : this.$layerService.calculatePropertyInfo(group, filter.property);
            var nBins = (filter.meta['numberOfBins']) ? filter.meta['numberOfBins'] : Math.ceil(Math.sqrt(Object.keys(group.markers).length));
            var min = info.min;
            var max = info.max;
            var binWidth = Math.ceil(Math.abs(max - min) / nBins);
            max = min + nBins * binWidth;
            var dx = Math.round(binWidth / 2);
            filter.from = filter.rangex[0] = min - dx;
            filter.to = filter.rangex[1] = max;
            var dcDim = group.ndx.dimension(function (d) {
                if (!d.properties.hasOwnProperty(filter.property))
                    return null;
                var prop = d.properties[filter.property];
                if (prop === null)
                    return null;
                var a = parseFloat(prop) - min;
                return min + Math.floor(a / binWidth) * binWidth;
            });
            filter.dimension = dcDim;
            var dcGroup = dcDim.group();
            //var scale =
            this.dcChart
                .width(275)
                .height(110)
                .dimension(dcDim)
                .group(dcGroup)
                .transitionDuration(10)
                .centerBar(true)
                .gap(1) //d3.scale.quantize().domain([0, 10]).range(d3.range(1, 4));
                .elasticY(true)
                .x(d3.scale.linear().domain([min - dx, max]).range([-1, nBins + 1]))
                .filterPrinter(function (filters) {
                var s = '';
                if (filters.length > 0) {
                    var localFilter = filters[0];
                    _this.displayFilterRange(parseFloat(localFilter[0]).toFixed(2), parseFloat(localFilter[1]).toFixed(2));
                    s += localFilter[0];
                }
                return s;
            }).on('renderlet', function (e) {
                //var fil = e.hasFilter();
                var s = '';
                if (e.filters.length > 0) {
                    var localFilter = e.filters[0];
                    _this.displayFilterRange(+(localFilter[0]).toFixed(2), (+localFilter[1]).toFixed(2));
                    s += localFilter[0];
                }
                dc.events.trigger(function () {
                    _this.$layerService.updateFilterGroupCount(group);
                }, 0);
                dc.events.trigger(function () {
                    //console.log("yes");
                    group.filterResult = dcDim.top(Infinity);
                    _this.$layerService.updateMapFilter(group);
                }, 100);
            });
            this.dcChart.selectAll();
            //this.displayFilterRange(min,max);
            this.dcChart.xUnits(function () { return 100 / nBins; });
            this.dcChart.yAxis().ticks(5);
            this.dcChart.xAxis().ticks(5);
            //this.dcChart.mouseZoomable(true);
            dc.renderAll();
            this.updateRange();
            //  this.updateChartRange(this.dcChart,filter);
        };
        BarFilterCtrl.prototype.updateFilter = function () {
            var _this = this;
            setTimeout(function () {
                _this.dcChart.filter([_this.$scope.filter.from, _this.$scope.filter.to]);
                _this.dcChart.render();
                dc.renderAll();
                _this.$layerService.updateMapFilter(_this.$scope.filter.group);
            }, 10);
        };
        BarFilterCtrl.prototype.updateRange = function () {
            var _this = this;
            setTimeout(function () {
                var filter = _this.$scope.filter;
                var group = filter.group;
                _this.displayFilterRange(filter.from, filter.to);
                _this.dcChart.filterAll();
                _this.dcChart.filter(dc.filters.RangedFilter(filter.from, filter.to));
                _this.dcChart.render();
                dc.redrawAll();
                group.filterResult = filter.dimension.top(Infinity);
                _this.$layerService.updateMapFilter(filter.group);
                _this.$scope.$apply();
            }, 0);
        };
        BarFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        BarFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            '$timeout',
            '$translate'
        ];
        return BarFilterCtrl;
    }());
    Filters.BarFilterCtrl = BarFilterCtrl;
})(Filters || (Filters = {}));
//# sourceMappingURL=BarFilterCtrl.js.map
var Filters;
(function (Filters) {
    var BoolFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function BoolFilterCtrl($scope, $layerService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            $scope.vm = this;
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                this.initBoolFilter();
                //this.updateTextFilter();
                //this.widget = (par.widget); 
                $scope.$watch('filter.value', function () {
                    _this.updateBoolFilter();
                });
            }
        }
        BoolFilterCtrl.prototype.initBoolFilter = function () {
            var filter = this.$scope.filter;
            var group = filter.group;
            var dcDim = group.ndx.dimension(function (d) {
                if (d.properties.hasOwnProperty(filter.property)) {
                    return d.properties[filter.property];
                }
                else
                    return null;
            });
            filter.dimension = dcDim;
            filter.group = group;
            dcDim.filterFunction(function (d) {
                return false;
            });
        };
        BoolFilterCtrl.prototype.updateBoolFilter = function () {
            var f = this.$scope.filter;
            if (!f.dimension)
                return;
            var group = f.group;
            f.dimension.filterFunction(function (d) {
                if (d != null)
                    return (d = f.value);
                return false;
            });
            group.filterResult = f.dimension.top(Infinity);
            this.$layerService.updateMapFilter(group);
            dc.renderAll();
        };
        BoolFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        BoolFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return BoolFilterCtrl;
    }());
    Filters.BoolFilterCtrl = BoolFilterCtrl;
})(Filters || (Filters = {}));
//# sourceMappingURL=BoolFilterCtrl.js.map
var Filters;
(function (Filters) {
    var DateFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function DateFilterCtrl($scope, $layerService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.switch = "after";
            $scope.vm = this;
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                this.initTextFilter();
                //this.updateTextFilter();
                //this.widget = (par.widget);
                //$messageBus.subscribe('')
                this.subHandle = $messageBus.subscribe('timeline', function (trigger) {
                    switch (trigger) {
                        case 'focusChange':
                            _this.updateDateFilter();
                            break;
                    }
                });
                $scope.$watch('vm.switch', function () { _this.updateDateFilter(); });
            }
        }
        DateFilterCtrl.prototype.select = function () {
            //  console.log('select:' + this.switch);
        };
        DateFilterCtrl.prototype.check = function (d) {
            if (d != null) {
                var dt;
                if (_.isNumber(d))
                    dt = d;
                if (_.isDate(d))
                    dt = Date.parse(d);
                switch (this.switch) {
                    case "before": return dt >= this.$layerService.project.timeLine.focus;
                    case "after": return dt <= this.$layerService.project.timeLine.focus;
                    case "range": return dt >= this.$layerService.project.timeLine.start && dt <= this.$layerService.project.timeLine.end;
                }
            }
            return false;
        };
        DateFilterCtrl.prototype.initTextFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var group = filter.group;
            var dcDim = group.ndx.dimension(function (d) {
                if (d.properties.hasOwnProperty(filter.property)) {
                    return d.properties[filter.property];
                }
                else
                    return null;
            });
            filter.dimension = dcDim;
            filter.group = group;
            this.$layerService.project.timeLine.focusDate;
            dcDim.filterFunction(function (d) {
                return _this.check(d);
            });
        };
        DateFilterCtrl.prototype.updateDateFilter = function () {
            var _this = this;
            var f = this.$scope.filter;
            if (!f.dimension)
                return;
            var group = f.group;
            f.dimension.filterFunction(function (d) {
                return _this.check(d);
            });
            group.filterResult = f.dimension.top(Infinity);
            this.$layerService.updateMapFilter(group);
            dc.renderAll();
        };
        DateFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        DateFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return DateFilterCtrl;
    }());
    Filters.DateFilterCtrl = DateFilterCtrl;
})(Filters || (Filters = {}));
//# sourceMappingURL=DateFilterCtrl.js.map
var Filters;
(function (Filters) {
    var LocationFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function LocationFilterCtrl($scope, $layerService, $messageBus, $timeout, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$timeout = $timeout;
            this.$translate = $translate;
            $scope.vm = this;
            $translate('REMOVE').then(function (translation) {
                $scope.removeString = translation;
            });
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            if ($scope && $scope.filter) {
                setTimeout(function () { return _this.initLocationFilter(); });
                //$timeout.call(()=>this.initLocationFilter());
                $scope.options = (function () {
                    var res = [];
                    res.push([$scope.removeString, function () { return _this.remove(); }]);
                    return res;
                });
            }
        }
        LocationFilterCtrl.prototype.setLocationFilter = function () {
            var _this = this;
            if (!this.locationFilter) {
                var bounds = this.$layerService.map.map.getBounds();
                bounds = bounds.pad(-0.75);
                this.locationFilter = new L.LocationFilter({ bounds: bounds }).addTo(this.$layerService.map.map);
                this.$scope.filter.value = bounds;
                this.locationFilter.on('change', function (e) {
                    _this.updateLocationFilter(e.bounds);
                });
                this.locationFilter.on('enabled', function (e) {
                    _this.updateLocationFilter(e.bounds);
                });
                // this.locationFilter.on('disabled', (e) => {
                // });
                this.locationFilter.enable();
                this.updateLocationFilter(this.locationFilter.getBounds());
            }
            else if (this.locationFilter.isEnabled()) {
                this.locationFilter.disable();
            }
            else {
                this.locationFilter.enable();
            }
        };
        LocationFilterCtrl.prototype.initLocationFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var group = filter.group;
            var divid = 'filter_' + filter.id;
            this.setLocationFilter();
            this.dcChart = dc.pieChart('#' + divid);
            this.$scope.$apply();
            var dcDim = group.ndx.dimension(function (d) {
                if (d.id && d.layer && d.layer.group && d.layer.group.markers && d.layer.group.markers.hasOwnProperty(d.id)) {
                    var marker = d.layer.group.markers[d.id];
                    if (marker.getBounds) {
                        return marker.getBounds();
                    }
                    else if (marker.getLatLng) {
                        return (new L.LatLngBounds(marker.getLatLng(), marker.getLatLng()));
                    }
                    else {
                        //what else?
                        null;
                    }
                }
                return null;
            });
            filter.dimension = dcDim;
            this.helperDim = crossfilter([
                { title: 'inside' },
                { title: 'outside' }
            ]).dimension(function (d) { return d.title; });
            this.helperGroup = this.helperDim.group(function (d) {
                return d;
            });
            this.dcChart
                .width(175)
                .height(200)
                .slicesCap(4)
                .innerRadius(0)
                .dimension(this.helperDim)
                .group(this.helperGroup) // by default, pie charts will use group.key as the label
                .legend(dc.legend())
                .renderLabel(true)
                .label(function (d) { return d.value; })
                .on('renderlet', function (e) {
                _this.updateLocationFilter(_this.locationFilter.getBounds(), false);
            });
            this.updateLocationFilter(this.$scope.filter.value);
        };
        LocationFilterCtrl.prototype.updateLocationFilter = function (bounds, triggerRender) {
            if (triggerRender === void 0) { triggerRender = true; }
            var f = this.$scope.filter;
            if (!f.dimension || !this.locationFilter.isEnabled())
                return;
            var group = f.group;
            f.dimension.filterFunction(function (d) {
                if (d != null) {
                    return (bounds.contains(d));
                }
                return false;
            });
            this.helperGroup.all().forEach(function (hg) {
                if (hg.key === 'inside') {
                    hg.value = f.dimension.top(Infinity).length;
                }
                if (hg.key === 'outside') {
                    hg.value = f.dimension.groupAll().value() - f.dimension.top(Infinity).length;
                }
            });
            this.isEmpty = !(this.helperGroup.all().some(function (hg) { return hg.value !== 0; }));
            group.filterResult = f.dimension.top(Infinity);
            if (triggerRender) {
                this.$layerService.updateMapFilter(group);
                dc.renderAll();
            }
        };
        LocationFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                if (this.locationFilter && this.locationFilter.isEnabled)
                    this.locationFilter.disable();
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        LocationFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            '$timeout',
            '$translate'
        ];
        return LocationFilterCtrl;
    }());
    Filters.LocationFilterCtrl = LocationFilterCtrl;
})(Filters || (Filters = {}));
//# sourceMappingURL=LocationFilterCtrl.js.map
var Filters;
(function (Filters) {
    var RowFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function RowFilterCtrl($scope, $layerService, $messageBus, $timeout, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$timeout = $timeout;
            this.$translate = $translate;
            $scope.vm = this;
            $translate('REMOVE').then(function (translation) {
                $scope.removeString = translation;
            });
            $translate('CREATE_SCATTER').then(function (translation) {
                $scope.createScatterString = translation;
            });
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                setTimeout(function () { return _this.initRowFilter(); });
                //$timeout.call(()=>this.initBarFilter());
                $scope.options = (function () {
                    var res = [];
                    res.push([$scope.removeString, function () { return _this.remove(); }]);
                    $scope.filter.group.filters.forEach(function (gf) {
                        if (gf.filterType == "row" && gf.property != $scope.filter.property) {
                            res.push([$scope.createScatterString + ' ' + gf.title, function () { return _this.createScatter(gf); }]);
                        }
                    });
                    return res;
                });
            }
        }
        RowFilterCtrl.prototype.createScatter = function (gf) {
            this.$layerService.createScatterFilter(this.$scope.filter.group, this.$scope.filter.property, gf.property);
        };
        RowFilterCtrl.prototype.initRowFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var group = filter.group;
            var divid = 'filter_' + filter.id;
            this.dcChart = dc.rowChart('#' + divid);
            this.$scope.$apply();
            var pt;
            var dcDim = group.ndx.dimension(function (d) {
                if (!d.properties.hasOwnProperty(filter.property))
                    return null;
                else {
                    if (!pt)
                        pt = _this.$layerService.getPropertyType(d, filter.property);
                    if (d.properties[filter.property] != null) {
                        var a = d.properties[filter.property];
                        if (pt.type === 'options') {
                            var r;
                            if (pt && pt.options && pt.options.hasOwnProperty(a)) {
                                r = a + "." + pt.options[a];
                            }
                            else {
                                r = a + "." + a;
                            }
                            return r;
                        }
                        else if (pt.type === 'number' && pt.hasOwnProperty('legend')) {
                            var label;
                            pt.legend.legendEntries.some(function (le) {
                                if (a >= le.interval.min && le.interval.max >= a) {
                                    label = le.label;
                                    return true;
                                }
                            });
                            if (!label)
                                label = 'other';
                            return label;
                        }
                        else if (pt.type === 'text' || pt.type === 'textarea') {
                            return a;
                        }
                    }
                    return null;
                }
            });
            filter.dimension = dcDim;
            var dcGroup = dcDim.group();
            this.dcChart.width(315)
                .height(210)
                .dimension(dcDim)
                .group(dcGroup)
                .title(function (d) {
                return d.key;
            })
                .elasticX(true)
                .colors(function (d) {
                if (pt && pt.legend) {
                    if (pt.options)
                        return csComp.Helpers.getColorFromLegend(parseInt(d.split('.')[0]), pt.legend);
                    if (!pt.options) {
                        var arr = pt.legend.legendEntries.filter((function (le) { return le.label === d; }));
                        return (arr.length > 0 ? arr[0].color : '#444444');
                    }
                }
                else {
                    return "red";
                }
            })
                .cap(10)
                .on('renderlet', function (e) {
                dc.events.trigger(function () {
                    _this.$layerService.updateFilterGroupCount(group);
                }, 0);
                dc.events.trigger(function () {
                    group.filterResult = dcDim.top(Infinity);
                    _this.$layerService.updateMapFilter(group);
                }, 100);
            }).on('filtered', function (e) {
                console.log('Filtered rowchart');
            });
            this.dcChart.selectAll();
            this.updateRange();
            dc.renderAll();
        };
        RowFilterCtrl.prototype.updateFilter = function () {
            var _this = this;
            setTimeout(function () {
                _this.dcChart.filter(_this.$scope.filter.filterLabel);
                _this.dcChart.render();
                dc.renderAll();
                _this.$layerService.updateMapFilter(_this.$scope.filter.group);
            }, 10);
        };
        RowFilterCtrl.prototype.updateRange = function () {
            var _this = this;
            setTimeout(function () {
                var filter = _this.$scope.filter;
                var group = filter.group;
                _this.dcChart.filterAll();
                _this.dcChart.filter(_this.$scope.filter.filterLabel);
                _this.dcChart.render();
                dc.redrawAll();
                group.filterResult = filter.dimension.top(Infinity);
                _this.$layerService.updateMapFilter(_this.$scope.filter.group);
                _this.$scope.$apply();
            }, 0);
        };
        RowFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        RowFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            '$timeout',
            '$translate'
        ];
        return RowFilterCtrl;
    }());
    Filters.RowFilterCtrl = RowFilterCtrl;
})(Filters || (Filters = {}));
//# sourceMappingURL=RowFilterCtrl.js.map
var Filters;
(function (Filters) {
    var ScatterFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function ScatterFilterCtrl($scope, $layerService, $messageBus, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$timeout = $timeout;
            $scope.vm = this;
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            if ($scope && $scope.filter) {
                setTimeout(function () { return _this.addScatterFilter(); });
                //$timeout.call(()=>this.initBarFilter());
                $scope.options = (function () {
                    var res = [];
                    res.push(['remove', function () { return _this.remove(); }]);
                    $scope.filter.group.filters.forEach(function (gf) {
                        if (gf.filterType === 'bar' && gf.property !== $scope.filter.property) {
                            res.push(['create scatter with ' + gf.title, function () { return _this.remove(); }]);
                        }
                    });
                    return res;
                });
            }
        }
        ScatterFilterCtrl.prototype.displayFilterRange = function (min, max) {
            var filter = this.$scope.filter;
            filter.from = min;
            filter.to = max;
            this.$scope.$apply();
        };
        ScatterFilterCtrl.prototype.addScatterFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var group = filter.group;
            var info = this.$layerService.calculatePropertyInfo(group, filter.property);
            var info2 = this.$layerService.calculatePropertyInfo(group, filter.property2);
            var divid = 'filter_' + filter.id;
            this.dcChart = dc.scatterPlot('#' + divid);
            var prop1 = group.ndx.dimension(function (d) {
                if (!d.properties.hasOwnProperty(filter.property))
                    return null;
                if (d.properties[filter.property] != null) {
                    var a = parseFloat(d.properties[filter.property]);
                    var b = parseFloat(d.properties[filter.property2]);
                    if (a >= info.min && a <= info.max) {
                        return [a, b];
                    }
                }
                return [0, 0];
            });
            filter.dimension = prop1;
            var dcGroup1 = prop1.group();
            this.dcChart.width(275)
                .height(190)
                .dimension(prop1)
                .group(dcGroup1)
                .x(d3.scale.linear().domain([info.min, info.max]))
                .yAxisLabel(filter.property2)
                .xAxisLabel(filter.property)
                .on('filtered', function (e) {
                var fil = e.hasFilter();
                dc.events.trigger(function () {
                    group.filterResult = prop1.top(Infinity);
                    _this.$layerService.updateFilterGroupCount(group);
                }, 0);
                dc.events.trigger(function () {
                    _this.$layerService.updateMapFilter(group);
                }, 100);
            });
            this.dcChart.xUnits(function () { return 13; });
            this.dcChart.yAxis().ticks(15);
            this.dcChart.xAxis().ticks(15);
            this.dcChart.render();
        };
        ScatterFilterCtrl.prototype.updateFilter = function () {
            var _this = this;
            setTimeout(function () {
                _this.dcChart.filter([_this.$scope.filter.from, _this.$scope.filter.to]);
                _this.dcChart.render();
                dc.renderAll();
                _this.$layerService.updateMapFilter(_this.$scope.filter.group);
                console.log('update filter');
            }, 10);
        };
        ScatterFilterCtrl.prototype.updateRange = function () {
            var _this = this;
            setTimeout(function () {
                _this.dcChart.filter([_this.$scope.filter.from, _this.$scope.filter.to]);
                _this.dcChart.render();
                _this.$layerService.updateMapFilter(_this.$scope.filter.group);
                console.log('update filter');
            }, 10);
        };
        ScatterFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        ScatterFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            '$timeout'
        ];
        return ScatterFilterCtrl;
    }());
    Filters.ScatterFilterCtrl = ScatterFilterCtrl;
})(Filters || (Filters = {}));
//# sourceMappingURL=ScatterFilterCtrl.js.map
var Filters;
(function (Filters) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Filters.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Filters.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a legend in a widget.
      */
    Filters.myModule.directive('txt2', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/TextFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.TextFilterCtrl
            };
        }
    ])
        .directive('boolFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/BoolFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.BoolFilterCtrl
            };
        }
    ])
        .directive('barFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/BarFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.BarFilterCtrl
            };
        }
    ])
        .directive('rowFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/RowFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.RowFilterCtrl
            };
        }
    ])
        .directive('scatterFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/ScatterFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.ScatterFilterCtrl
            };
        }
    ])
        .directive('dateFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/DateFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.DateFilterCtrl
            };
        }
    ])
        .directive('locationFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/LocationFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.LocationFilterCtrl
            };
        }
    ])
        .directive('areaFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/AreaFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.AreaFilterCtrl
            };
        }
    ]);
})(Filters || (Filters = {}));
//# sourceMappingURL=TextFilter.js.map
var Filters;
(function (Filters) {
    var TextFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function TextFilterCtrl($scope, $layerService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            $scope.vm = this;
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                this.initTextFilter();
                //this.updateTextFilter();
                //this.widget = (par.widget);
                $scope.$watch('filter.stringValue', function () {
                    _this.updateTextFilter();
                });
            }
        }
        TextFilterCtrl.prototype.initTextFilter = function () {
            var filter = this.$scope.filter;
            var group = filter.group;
            var dcDim = group.ndx.dimension(function (d) {
                if (d.properties.hasOwnProperty(filter.property)) {
                    return d.properties[filter.property];
                }
                else
                    return null;
            });
            filter.dimension = dcDim;
            filter.group = group;
            dcDim.filterFunction(function (d) {
                if (d != null && typeof d.toLowerCase === 'function')
                    return (d.toLowerCase().indexOf(filter.stringValue.toLowerCase()) > -1);
                return false;
            });
        };
        TextFilterCtrl.prototype.updateTextFilter = function () {
            var f = this.$scope.filter;
            if (!f.dimension)
                return;
            var group = f.group;
            if (f.stringValue == null || f.stringValue === '') {
                f.dimension.filterAll();
            }
            else {
                f.dimension.filterFunction(function (d) {
                    if (d != null && typeof d.toLowerCase === 'function')
                        return (d.toLowerCase().indexOf(f.stringValue.toLowerCase()) > -1);
                    return false;
                });
            }
            group.filterResult = f.dimension.top(Infinity);
            this.$layerService.updateMapFilter(group);
            //dc.renderAll();
            dc.redrawAll();
        };
        TextFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        TextFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return TextFilterCtrl;
    }());
    Filters.TextFilterCtrl = TextFilterCtrl;
})(Filters || (Filters = {}));
//# sourceMappingURL=TextFilterCtrl.js.map
var FocusTimeWidget;
(function (FocusTimeWidget) {
    /** Config */
    var moduleName = 'csComp';
    try {
        FocusTimeWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FocusTimeWidget.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    FocusTimeWidget.myModule.directive('focustimewidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/FocusTimeWidget/FocusTimeWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: FocusTimeWidgetCtrl
            };
        }
    ]);
    var FocusTimeWidgetCtrl = (function () {
        function FocusTimeWidgetCtrl($scope, $http, layerService, messageBusService, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.layerService = layerService;
            this.messageBusService = messageBusService;
            this.$timeout = $timeout;
            this.disabled = false;
            this.active = false;
            this.isOpen = true;
            this.timeOptions = {
                readonlyInput: false,
                showMeridian: false
            };
            $scope.vm = this;
            var par = $scope.$parent;
            $scope.data = par.widget.data;
            par.widget.stop = function () {
                if (_this.handle)
                    _this.messageBusService.unsubscribe(_this.handle);
            };
            switch ($scope.data.mode) {
                case "layerTimestamp":
                    this.checkLayerTimestamp();
                    this.layer = this.layerService.findLayer(this.$scope.data.layer);
                    this.handle = this.messageBusService.subscribe('layer', function (a, l) {
                        if (a === "sensordataUpdated") {
                            if (l.id === $scope.data.layer)
                                _this.checkLayerTimestamp();
                        }
                    });
                    break;
                case "focustime":
                    this.handle = this.messageBusService.subscribe('timeline', function (a, d) {
                        if (a === "focusChange") {
                            $scope.$evalAsync(function () {
                                _this.time = _this.layerService.project.timeLine.focusDate();
                            });
                        }
                    });
                    break;
            }
        }
        FocusTimeWidgetCtrl.prototype.openCalendar = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.isOpen = true;
        };
        ;
        FocusTimeWidgetCtrl.prototype.lastHour = function () {
            this.layer.sensorLink.liveInterval = "1h";
            this.layerService.updateLayerSensorLink(this.layer);
        };
        FocusTimeWidgetCtrl.prototype.lastDay = function () {
            this.layer.sensorLink.liveInterval = "24h";
            this.layerService.updateLayerSensorLink(this.layer);
            console.log('last 24');
        };
        FocusTimeWidgetCtrl.prototype.checkLayerTimestamp = function () {
            var _this = this;
            if (this.layer)
                if (this.layer._gui.hasOwnProperty("timestamp"))
                    this.$scope.$evalAsync(function () {
                        _this.dateFormat = "dd-MM-yyyy EEE";
                        _this.timeFormat = "HH:mm ";
                        _this.time = _this.layer._gui["timestamp"];
                    });
        };
        FocusTimeWidgetCtrl.$inject = [
            '$scope',
            '$http',
            'layerService',
            'messageBusService',
            '$timeout'
        ];
        return FocusTimeWidgetCtrl;
    }());
    FocusTimeWidget.FocusTimeWidgetCtrl = FocusTimeWidgetCtrl;
})(FocusTimeWidget || (FocusTimeWidget = {}));
//# sourceMappingURL=FocusTimeWidget.js.map
var HeaderWidget;
(function (HeaderWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        HeaderWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        HeaderWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    HeaderWidget.myModule.directive('headerwidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/HeaderWidget/HeaderWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: HeaderWidget.HeaderWidgetCtrl
            };
        }
    ]);
})(HeaderWidget || (HeaderWidget = {}));
//# sourceMappingURL=HeaderWidget.js.map
var HeaderWidget;
(function (HeaderWidget) {
    var HeaderWidgetData = (function () {
        function HeaderWidgetData() {
        }
        return HeaderWidgetData;
    }());
    HeaderWidget.HeaderWidgetData = HeaderWidgetData;
    var HeaderWidgetCtrl = (function () {
        function HeaderWidgetCtrl($scope, $timeout, $layerService, $messageBus, $mapService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            if (this.widget.data) {
                $scope.data = this.widget.data;
                $scope.data.mdText = $scope.data.content;
                if ($scope.data.autoShow)
                    this.showContent();
            }
            this.dataProperties = {};
            this.parentWidget = $('#' + this.widget.elementId).parent();
        }
        HeaderWidgetCtrl.prototype.showContent = function () {
            var rpt = csComp.Helpers.createRightPanelTab('headerinfo', 'infowidget', this.$scope.data, 'Selected feature', '{{"FEATURE_INFO" | translate}}', 'question', true);
            this.$messageBus.publish('rightpanel', 'activate', rpt);
            this.$layerService.visual.rightPanelVisible = true; // otherwise, the rightpanel briefly flashes open before closing.
        };
        HeaderWidgetCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'messageBusService',
            'mapService'
        ];
        return HeaderWidgetCtrl;
    }());
    HeaderWidget.HeaderWidgetCtrl = HeaderWidgetCtrl;
})(HeaderWidget || (HeaderWidget = {}));
//# sourceMappingURL=HeaderWidgetCtrl.js.map
var InfoWidget;
(function (InfoWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        InfoWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        InfoWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    InfoWidget.myModule.directive('infowidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/HeaderWidget/InfoWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: InfoWidgetCtrl
            };
        }
    ]);
    var InfoWidgetData = (function () {
        function InfoWidgetData() {
        }
        return InfoWidgetData;
    }());
    InfoWidget.InfoWidgetData = InfoWidgetData;
    var InfoWidgetCtrl = (function () {
        function InfoWidgetCtrl($scope, $timeout, $layerService, $messageBus, $mapService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par;
            $scope.data = this.widget.data;
            if ($scope.data && $scope.data.content) {
                $scope.data.mdText = $scope.data.content;
                this.parentWidget = $('#' + this.widget.elementId).parent();
            }
        }
        InfoWidgetCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'messageBusService',
            'mapService'
        ];
        return InfoWidgetCtrl;
    }());
    InfoWidget.InfoWidgetCtrl = InfoWidgetCtrl;
})(InfoWidget || (InfoWidget = {}));
//# sourceMappingURL=InfoWidgetCtrl.js.map
var IFrameWidget;
(function (IFrameWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        IFrameWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        IFrameWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    IFrameWidget.myModule.directive('iframewidgetEdit', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/IFrameWidget/IFrame-edit.tpl.html',
                replace: true,
                transclude: true,
                controller: IFrameEditCtrl
            };
        }
    ]);
    var IFrameEditCtrl = (function () {
        function IFrameEditCtrl($scope, $sce) {
            this.$scope = $scope;
            this.$sce = $sce;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.data;
            $scope.data = this.widget.data;
            this.update();
        }
        IFrameEditCtrl.prototype.update = function () {
            this.$scope.data._safeurl = this.$sce.trustAsResourceUrl(this.$scope.data.url);
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        IFrameEditCtrl.$inject = [
            '$scope',
            '$sce'
        ];
        return IFrameEditCtrl;
    }());
    IFrameWidget.IFrameEditCtrl = IFrameEditCtrl;
})(IFrameWidget || (IFrameWidget = {}));
//# sourceMappingURL=IFrame-edit.js.map
var IFrameWidget;
(function (IFrameWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        IFrameWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        IFrameWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    IFrameWidget.myModule.directive('iframewidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/IFrameWidget/IFrameWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: IFrameWidget.IFrameWidgetCtrl
            };
        }
    ]);
})(IFrameWidget || (IFrameWidget = {}));
//# sourceMappingURL=IFrameWidget.js.map
var IFrameWidget;
(function (IFrameWidget) {
    var IFrameWidgetData = (function () {
        function IFrameWidgetData() {
        }
        return IFrameWidgetData;
    }());
    IFrameWidget.IFrameWidgetData = IFrameWidgetData;
    var IFrameWidgetCtrl = (function () {
        function IFrameWidgetCtrl($scope, $sce) {
            this.$scope = $scope;
            this.$sce = $sce;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            $scope.data = this.widget.data;
        }
        IFrameWidgetCtrl.prototype.update = function () {
            this.$scope.data._safeurl = this.$sce.trustAsResourceUrl(this.$scope.data.url);
        };
        IFrameWidgetCtrl.$inject = [
            '$scope',
            '$sce'
        ];
        return IFrameWidgetCtrl;
    }());
    IFrameWidget.IFrameWidgetCtrl = IFrameWidgetCtrl;
})(IFrameWidget || (IFrameWidget = {}));
//# sourceMappingURL=IFrameWidgetCtrl.js.map
var Indicators;
(function (Indicators) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Indicators.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Indicators.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    Indicators.myModule.directive('indicatorsEdit', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Indicators/Indicators-edit.tpl.html',
                replace: true,
                transclude: true,
                controller: IndicatorsEditCtrl
            };
        }
    ]);
    var IndicatorsEditCtrl = (function () {
        function IndicatorsEditCtrl($scope, $timeout, $compile, $layerService, $templateCache, $messageBus, $mapService, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$compile = $compile;
            this.$layerService = $layerService;
            this.$templateCache = $templateCache;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.data;
            this.propertyTypes = [];
            $scope.data = this.widget.data;
            this.indicatorVisuals = {};
            this.indicatorVisuals['bullet'] = {
                id: 'bullet',
                title: 'Bullet chart',
                input: {}
            };
            this.indicatorVisuals['circular'] = {
                id: 'circular',
                title: 'Circular',
                input: {
                    value: {
                        type: 'expression',
                        default: '~[\'value\']' },
                    min: {
                        type: 'expression',
                        default: 0
                    },
                    max: {
                        type: 'expression',
                        default: 0
                    }
                }
            };
            this.indicatorVisuals['sparkline'] = {
                id: 'sparkline',
                title: 'Sparkline',
                input: {
                    property: {
                        type: 'string',
                        default: 'value'
                    },
                    height: {
                        type: 'string',
                        default: '50'
                    }
                }
            };
            this.indicatorVisuals['bar'] = {
                id: 'bar',
                title: 'Bar chart',
                input: {}
            };
            this.indicatorVisuals['singlevalue'] = {
                id: 'singlevalue',
                title: 'Value',
                input: {
                    value: {
                        type: 'expression',
                        default: '~[\'value\']'
                    }
                }
            };
        }
        //
        // //** select a typesResource collection from the dropdown */
        IndicatorsEditCtrl.prototype.colorUpdated = function (c, i) {
            i.color = c;
        };
        IndicatorsEditCtrl.prototype.updatePropertyTypes = function (indic) {
            var fType = this.$layerService._featureTypes[indic.featureTypeName];
            if (fType)
                this.propertyTypeData = csComp.Helpers.getPropertyTypes(fType, this.$layerService.propertyTypeData);
        };
        IndicatorsEditCtrl.prototype.moveUp = function (i) {
            var pos = this.$scope.data.indicators.indexOf(i);
            //this.$scope.data.indicators.move()
        };
        IndicatorsEditCtrl.prototype.deleteIndicator = function (i) {
            this.$scope.data.indicators = this.$scope.data.indicators.filter(function (ind) { return ind.id !== i; });
        };
        IndicatorsEditCtrl.prototype.updateIndicator = function (i) {
            i.propertyTypes = [];
            i.propertyTypeTitles = [];
            this.propertyTypes.forEach(function (pt) {
                i.propertyTypes.push(pt.label);
                i.propertyTypeTitles.push(pt.title);
            });
            if (this.$layerService.lastSelectedFeature && i.source === 'feature') {
                this.$messageBus.publish('feature', 'onUpdateWithLastSelected', { indicator: i, feature: undefined });
            }
            i._toggleUpdate = !i._toggleUpdate;
            this.updateVisual(i);
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
            ;
        };
        IndicatorsEditCtrl.prototype.initIndicator = function (i) {
            this.updateVisual(i);
        };
        IndicatorsEditCtrl.prototype.updateVisual = function (i) {
            if (!i.inputs)
                i.inputs = {};
            var r = {};
            for (var key in this.indicatorVisuals[i.visual].input) {
                if (i.inputs && i.inputs.hasOwnProperty(key)) {
                    r[key] = i.inputs[key];
                }
                else {
                    var v = this.indicatorVisuals[i.visual].input;
                    r[key] = v[key].default;
                }
            }
            i.inputs = r;
        };
        IndicatorsEditCtrl.prototype.addIndicator = function () {
            var newIndicator = new Indicators.Indicator();
            newIndicator.title = 'New Indicator';
            newIndicator.visual = 'circular';
            newIndicator.sensor = '';
            newIndicator.source = 'feature';
            newIndicator.featureTypeName = '';
            newIndicator.propertyTypes = [];
            this.updateVisual(newIndicator);
            if (!this.$scope.data.indicators)
                this.$scope.data.indicators = [];
            this.$scope.data.indicators.push(newIndicator);
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
            ;
        };
        IndicatorsEditCtrl.prototype.sensorChanged = function (i) {
            var sourceString = i.sensor.split('/');
            if (sourceString.length > 1) {
                this.$layerService.project.datasources.forEach(function (ds) {
                    if (ds.id === sourceString[0]) {
                        if (ds.sensors.hasOwnProperty(sourceString[1])) {
                            i._sensorSet = ds.sensors[sourceString[1]];
                        }
                    }
                });
            }
            i._toggleUpdate = !i._toggleUpdate;
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
            ;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        IndicatorsEditCtrl.$inject = [
            '$scope',
            '$timeout',
            '$compile',
            'layerService',
            '$templateCache',
            'messageBusService',
            'mapService', 'dashboardService'
        ];
        return IndicatorsEditCtrl;
    }());
    Indicators.IndicatorsEditCtrl = IndicatorsEditCtrl;
})(Indicators || (Indicators = {}));
//# sourceMappingURL=Indicators-edit.js.map
var Indicators;
(function (Indicators) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Indicators.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Indicators.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    Indicators.myModule.directive('indicators', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Indicators/Indicators.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Indicators.IndicatorsCtrl
            };
        }
    ]).filter('datasource', function () {
        return function (input, scope) {
            if (!input)
                return "";
            var r = scope.$parent.$eval(input.replace('~', 'i._value'));
            return r;
        };
    });
})(Indicators || (Indicators = {}));
//# sourceMappingURL=Indicators.js.map
var Indicators;
(function (Indicators) {
    var IndicatorData = (function () {
        function IndicatorData() {
            this.orientation = 'vertical';
        }
        return IndicatorData;
    }());
    Indicators.IndicatorData = IndicatorData;
    var Indicator = (function () {
        function Indicator() {
            this.inputs = {};
            this._result = {};
            this._toggleUpdate = true;
            this.indicatorWidth = 200;
        }
        return Indicator;
    }());
    Indicators.Indicator = Indicator;
    var IndicatorsCtrl = (function () {
        function IndicatorsCtrl($scope, $timeout, $layerService, $messageBus, $mapService, $dashboardService, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            this.$translate = $translate;
            $scope.vm = this;
            var par = $scope.$parent;
            if (!par.widget)
                return;
            this.widget = par.widget;
            this.widget._ctrl = this;
            this.checkLayers();
            this.$messageBus.subscribe('layer', function (s) {
                _this.checkLayers();
            });
            $scope.data = this.widget.data;
            // $scope.$watchCollection('data.indicators', () => {
            //     //console.log('update data');
            //     if ($scope.data.indicators && !$scope.data.indicators[$scope.data.indicators.length - 1].id) {
            //         var i = $scope.data.indicators[$scope.data.indicators.length - 1];
            //         i.id = csComp.Helpers.getGuid();
            //         this.$messageBus.subscribe('feature', (action: string, feature: any) => {
            //             switch (action) {
            //                 case 'onFeatureSelect':
            //                     this.selectFeature(feature, i);
            //                     break;
            //                 case 'onUpdateWithLastSelected':
            //                     var indic = <indicator> feature.indicator; //variable called feature is actually an object containing the indicator and an (empty) feature
            //                     var realFeature;
            //                     if (this.$layerService.lastSelectedFeature) { realFeature = this.$layerService.lastSelectedFeature; };
            //                     this.selectFeature(realFeature, indic);
            //                     break;
            //                 default:
            //                     break;
            //             }
            //         });
            //     }
            // });
            if (typeof $scope.data.indicators !== 'undefined') {
                $scope.data.indicators.forEach(function (i) {
                    i.id = 'circ-' + csComp.Helpers.getGuid();
                });
            }
            $timeout(function () { return _this.checkLayers(); });
        }
        IndicatorsCtrl.prototype.forceUpdateIndicator = function (i, value) {
            var _this = this;
            setTimeout(function () {
                i._value = value;
                i._result = {};
                _this.$scope.$apply();
                for (var k in i.inputs)
                    i._result[k] = i.inputs[k];
                _this.$scope.$apply();
            }, 0);
        };
        IndicatorsCtrl.prototype.updateIndicator = function (i) {
            var focusTime = this.$layerService.project.timeLine.focus;
            this.$layerService.findSensorSet(i.sensor, function (ss) {
                i._sensorSet = ss;
                i._focusTime = focusTime;
                if (i._sensorSet.propertyType && i._sensorSet.propertyType.legend) {
                    i.color = csComp.Helpers.getColorFromLegend(i._sensorSet.activeValue, i._sensorSet.propertyType.legend);
                }
            });
        };
        IndicatorsCtrl.prototype.startEdit = function () {
            //alert('start edit');
        };
        IndicatorsCtrl.prototype.checkLayers = function () {
            var _this = this;
            if (!this.$layerService.visual.mapVisible)
                return;
            var focusTime = this.$layerService.project.timeLine.focus;
            if (!this.$scope.data || !this.$scope.data.indicators)
                return;
            this.$scope.data.indicators.forEach(function (i) {
                i._focusTime = focusTime;
                if (i.layer != null) {
                    var ss = i.layer.split('/');
                    var l = _this.$layerService.findLayer(ss[0]);
                    if (l != null) {
                        if (ss.length > 1) {
                            i.isActive = l.enabled && l.group.styles.some(function (gs) {
                                return gs.property === ss[1];
                            });
                        }
                        else {
                            i.isActive = l.enabled;
                        }
                    }
                }
            });
        };
        IndicatorsCtrl.prototype.selectIndicator = function (i) {
            if (typeof i.dashboard !== 'undefined') {
                var db = this.$layerService.project.dashboards.filter(function (d) { return d.id === i.dashboard; });
                if (db.length > 0)
                    this.$dashboardService.selectDashboard(db[0], 'main');
            }
            if (!this.$layerService.visual.mapVisible)
                return;
            if (i.layer != null) {
                var ss = i.layer.split('/');
                var l = this.$layerService.findLayer(ss[0]);
                if (l != null) {
                    if (l.enabled) {
                        this.$layerService.checkLayerLegend(l, ss[1]);
                    }
                    else {
                        if (ss.length > 1)
                            l.defaultLegendProperty = ss[1];
                        this.$layerService.addLayer(l);
                    }
                }
            }
            this.checkLayers();
            //console.log(i.title);
        };
        IndicatorsCtrl.prototype.indicatorInit = function (i, scope) {
            var _this = this;
            scope.Math = Math;
            switch (i.source) {
                default:
                    // Assume by default that we are dealing with a feature.
                    this.$messageBus.subscribe('feature', function (action, feature) {
                        switch (action) {
                            case 'onFeatureSelect':
                                _this.selectFeature(feature, i);
                                break;
                            case 'onUpdateWithLastSelected':
                                var indic = feature.indicator; //variable called feature is actually an object containing the indicator and an (empty) feature
                                var realFeature;
                                if (_this.$layerService.lastSelectedFeature) {
                                    realFeature = _this.$layerService.lastSelectedFeature;
                                }
                                ;
                                _this.selectFeature(realFeature, indic);
                                break;
                            default:
                                break;
                        }
                    });
                    break;
                case 'sensor':
                    if (i.sensor != null) {
                        this.$layerService.$messageBusService.serverSubscribe(i.sensor, 'key', function (topic, msg) {
                            switch (msg.action) {
                                case 'key':
                                    _this.forceUpdateIndicator(i, msg.data.item); // i._sensorSet.activeValue);
                                    break;
                            }
                        });
                        this.updateIndicator(i);
                    }
                    break;
            }
        };
        IndicatorsCtrl.prototype.selectFeature = function (f, i) {
            var _this = this;
            // console.log('select feature called');
            // console.log(f);
            if (!i._sensorSet) {
                var ss = new csComp.Services.SensorSet();
                ss.propertyType = { title: '' };
                i._sensorSet = ss;
            }
            if (i.hasOwnProperty('featureTypeName')) {
                if (f.featureTypeName === i.featureTypeName) {
                    var propTypes = i.propertyTypes;
                    var propTitles = [];
                    var propValues = [];
                    this.forceUpdateIndicator(i, f.properties);
                    propTypes.forEach(function (pt) {
                        if (f.properties.hasOwnProperty(pt)) {
                            propValues.push(f.properties[pt]);
                        }
                        if (_this.$layerService.propertyTypeData.hasOwnProperty(pt)) {
                            propTitles.push(_this.$layerService.propertyTypeData[pt].title);
                        }
                        else {
                            propTitles.push(pt);
                        }
                    });
                    i._sensorSet.activeValue = propValues[0];
                    i._sensorSet.propertyType.title = propTitles[0];
                    var propInfo = this.$layerService.calculatePropertyInfo(f.layer.group, propTypes[0]);
                    i._sensorSet.min = propInfo.min;
                    i._sensorSet.max = propInfo.max * 1.05;
                    if (i.visual === 'bullet') {
                        var dataInJson = [];
                        for (var count = 0; count < propTypes.length; count++) {
                            var pinfo = this.$layerService.calculatePropertyInfo(f.layer.group, propTypes[count]);
                            //TODO: Just for fixing the impact ranges to [-5, 5], better solution is to be implemented...
                            if (propTypes[count].substr(0, 3) === 'IMP') {
                                if (pinfo.sd < 0) {
                                    pinfo.min = -5;
                                    pinfo.max = -5;
                                }
                                else {
                                    pinfo.min = 5;
                                    pinfo.max = 5;
                                }
                            }
                            var item = {
                                'title': propTitles[count],
                                'subtitle': '',
                                'ranges': [pinfo.max, pinfo.max],
                                'measures': [propValues[count]],
                                'markers': [propValues[count]],
                                'barColor': (propValues[count] <= 0) ? 'green' : 'red'
                            };
                            dataInJson.push(item);
                        }
                        i.indicatorWidth = 200;
                        i.data = JSON.stringify(dataInJson);
                    }
                    ;
                    i._toggleUpdate = !i._toggleUpdate; //Redraw the widget
                }
            }
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
            ;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        IndicatorsCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'messageBusService',
            'mapService',
            'dashboardService',
            '$translate'
        ];
        return IndicatorsCtrl;
    }());
    Indicators.IndicatorsCtrl = IndicatorsCtrl;
})(Indicators || (Indicators = {}));
//# sourceMappingURL=IndicatorsCtrl.js.map
var LocationWidget;
(function (LocationWidget) {
    /** Config */
    var moduleName = 'csComp';
    try {
        LocationWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        LocationWidget.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    LocationWidget.myModule.directive('locationwidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/LocationWidget/LocationWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: LocationWidgetCtrl
            };
        }]);
    var LocationWidgetCtrl = (function () {
        function LocationWidgetCtrl($scope, $http, layerService, messageBusService, actionService, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.layerService = layerService;
            this.messageBusService = messageBusService;
            this.actionService = actionService;
            this.$timeout = $timeout;
            this.streetViewUrl = 'https://maps.googleapis.com/maps/api/streetview';
            this.location = {};
            $scope.vm = this;
            var par = $scope.$parent;
            $scope.data = par.widget.data;
            if ($scope.data.streetViewUrl)
                this.streetViewUrl = $scope.data.streetViewUrl;
            this.parentWidget = $('#' + par.widget.elementId).parent();
            this.parentWidget.hide();
            messageBusService.subscribe('geocoding', function (action, data) {
                if (action !== 'reverseLookupResult')
                    return;
                _this.parentWidget.show();
                _this.updateWidget(data);
            });
        }
        LocationWidgetCtrl.prototype.updateWidget = function (data) {
            this.location = {};
            if (!data || !data.annotations)
                return;
            if (data.formatted)
                this.location.title = data.formatted;
            // Set address
            if (data.components) {
                if (data.components.postcode)
                    this.location.postcode = data.components.postcode;
                if (data.components.city)
                    this.location.city = data.components.city;
                if (data.components.neighbourhood)
                    this.location.neighbourhood = data.components.neighbourhood;
                if (data.components.road || data.components.pedestrian) {
                    this.location.address = data.components.road || data.components.pedestrian;
                    if (data.components.house_number)
                        this.location.address += " " + data.components.house_number;
                    this.location.streetViewUrlThumb = this.streetViewUrl + "?size=200x200&location=" + this.location.address + "," + this.location.city + "&key=" + this.$scope.data.streetViewApiKey;
                    this.location.streetViewUrlFull = this.streetViewUrl + "?size=640x640&location=" + this.location.address + "," + this.location.city + "&key=" + this.$scope.data.streetViewApiKey;
                }
            }
            // Set locations
            this.location.locations = [];
            if (data.geometry)
                this.location.locations.push(data.geometry.lat + ", " + data.geometry.lng);
            if (data.annotations.DMS)
                this.location.locations.push("DMS latitude: " + data.annotations.DMS.lat + ", longitude: " + data.annotations.DMS.lng);
            if (data.geometry)
                this.location.locations.push("WGS84 latitude: " + data.geometry.lat + ", longitude: " + data.geometry.lng);
            if (data.annotations.MGRS)
                this.location.locations.push("MGRS: " + data.annotations.MGRS);
            if (data.annotations.Mercator)
                this.location.locations.push("Mercator x: " + data.annotations.Mercator.x + ", y: " + data.annotations.Mercator.y);
            if (this.location.locations.length > 0)
                this.selectedLocationFormat = this.location.locations[0];
            this.location.defaultLocation = this.location.locations[0];
            // Set sunrise and sunset
            if (data.annotations.sun) {
                var sunrise = new Date(data.annotations.sun.rise.apparent * 1000);
                this.location.sunrise = String.format('{0:HH}:{0:mm}:{0:ss}', sunrise);
                var sunset = new Date(data.annotations.sun.set.apparent * 1000);
                this.location.sunset = String.format('{0:HH}:{0:mm}:{0:ss}', sunset);
            }
        };
        LocationWidgetCtrl.prototype.close = function () {
            this.location = {};
            this.parentWidget.hide();
        };
        LocationWidgetCtrl.$inject = [
            '$scope',
            '$http',
            'layerService',
            'messageBusService',
            'actionService',
            '$timeout'
        ];
        return LocationWidgetCtrl;
    }());
    LocationWidget.LocationWidgetCtrl = LocationWidgetCtrl;
})(LocationWidget || (LocationWidget = {}));
//# sourceMappingURL=LocationWidget.js.map
var Markdown;
(function (Markdown) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Markdown.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Markdown.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    Markdown.myModule.directive('markdownwidgetEdit', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/MarkdownWidget/Markdown-edit.tpl.html',
                replace: true,
                transclude: true,
                controller: MarkdownEditCtrl
            };
        }
    ]);
    var MarkdownEditCtrl = (function () {
        function MarkdownEditCtrl($scope, $timeout, $compile, $layerService, $templateCache, $messageBus, $mapService, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$compile = $compile;
            this.$layerService = $layerService;
            this.$templateCache = $templateCache;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.data;
            $scope.data = this.widget.data;
        }
        MarkdownEditCtrl.prototype.updateText = function () {
            this.$scope.data.mdText = this.$scope.data.content;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        MarkdownEditCtrl.$inject = [
            '$scope',
            '$timeout',
            '$compile',
            'layerService',
            '$templateCache',
            'messageBusService',
            'mapService', 'dashboardService'
        ];
        return MarkdownEditCtrl;
    }());
    Markdown.MarkdownEditCtrl = MarkdownEditCtrl;
})(Markdown || (Markdown = {}));
//# sourceMappingURL=Markdown-edit.js.map
var MarkdownWidget;
(function (MarkdownWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        MarkdownWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        MarkdownWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    MarkdownWidget.myModule.directive('markdownwidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/MarkdownWidget/MarkdownWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: MarkdownWidget.MarkdownWidgetCtrl
            };
        }
    ]);
})(MarkdownWidget || (MarkdownWidget = {}));
//# sourceMappingURL=MarkdownWidget.js.map
var MarkdownWidget;
(function (MarkdownWidget) {
    var MarkdownWidgetData = (function () {
        function MarkdownWidgetData() {
        }
        return MarkdownWidgetData;
    }());
    MarkdownWidget.MarkdownWidgetData = MarkdownWidgetData;
    var MarkdownWidgetCtrl = (function () {
        function MarkdownWidgetCtrl($scope, $timeout, $layerService, $messageBus, $mapService) {
            var _this = this;
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            $scope.data = this.widget.data;
            $scope.data.mdText = $scope.data.content;
            $scope.minimized = false;
            this.dataProperties = {};
            this.parentWidget = $('#' + this.widget.elementId).parent();
            if (typeof $scope.data.featureTypeName !== 'undefined' && typeof $scope.data.dynamicProperties !== 'undefined' && $scope.data.dynamicProperties.length > 0) {
                // Hide widget
                this.parentWidget.hide();
                this.msgBusHandle = this.$messageBus.subscribe('feature', function (action, feature) {
                    switch (action) {
                        case 'onFeatureDeselect':
                        case 'onFeatureSelect':
                            _this.selectFeature(feature);
                            break;
                        default:
                            break;
                    }
                });
            }
            if (!(typeof $scope.data.url === 'undefined')) {
                var url = $scope.data.url;
                if ($scope.data.useLanguagePrefix) {
                    var extensions = url.split('.');
                    var newExtension = this.$layerService.currentLocale + '.' + extensions.pop();
                    extensions.push(newExtension);
                    url = extensions.join('.');
                }
                $.get(url, function (md) {
                    $timeout(function () {
                        $scope.data.content = $scope.data.mdText = md;
                    }, 0);
                });
            }
            // in case a separate datafile is used
            if (!(typeof $scope.data.dataSourceUrl === 'undefined')) {
                url = $scope.data.dataSourceUrl;
                $.get(url, function (properties) {
                    $timeout(function () {
                        _this.dataProperties = JSON.parse(properties);
                        _this.replaceKeys();
                    }, 0);
                });
            }
        }
        MarkdownWidgetCtrl.prototype.minimize = function () {
            this.$scope.minimized = !this.$scope.minimized;
            if (this.$scope.minimized) {
                this.parentWidget.css('height', '30px');
            }
            else {
                this.parentWidget.css('height', this.widget.height);
            }
        };
        MarkdownWidgetCtrl.prototype.canClose = function () {
            return (this.$scope.data.hasOwnProperty('canClose'))
                ? this.$scope.data['canClose']
                : true;
        };
        MarkdownWidgetCtrl.prototype.close = function () {
            this.parentWidget.hide();
        };
        MarkdownWidgetCtrl.prototype.stop = function () {
            if (this.msgBusHandle) {
                this.$messageBus.unsubscribe(this.msgBusHandle);
            }
        };
        MarkdownWidgetCtrl.prototype.escapeRegExp = function (str) {
            return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1');
        };
        MarkdownWidgetCtrl.prototype.replaceAll = function (str, find, replace) {
            return str.replace(new RegExp(this.escapeRegExp(find), 'g'), replace);
        };
        MarkdownWidgetCtrl.prototype.selectFeature = function (feature) {
            var _this = this;
            if (!feature || !feature.isSelected || feature.featureTypeName !== this.$scope.data.featureTypeName) {
                this.parentWidget.hide();
                return;
            }
            this.$timeout(function () {
                var md = _this.$scope.data.content;
                var i = 0;
                _this.$scope.data.dynamicProperties.forEach(function (p) {
                    var searchPattern = '{{' + i++ + '}}';
                    var displayText = '';
                    if (feature.properties.hasOwnProperty(p)) {
                        var pt = _this.$layerService.getPropertyType(feature, p);
                        displayText = csComp.Helpers.convertPropertyInfo(pt, feature.properties[p]);
                    }
                    md = _this.replaceAll(md, searchPattern, displayText);
                });
                _this.parentWidget.show();
                _this.$scope.data.mdText = md;
            }, 0);
        };
        MarkdownWidgetCtrl.prototype.replaceKeys = function () {
            var _this = this;
            var md = this.$scope.data.content;
            this.$timeout(function () {
                var keys = Object.keys(_this.dataProperties);
                keys.forEach(function (k) {
                    if (_this.dataProperties.hasOwnProperty(k)) {
                        var searchPattern = '{{' + k + '}}';
                        var replacePattern = _this.dataProperties[k];
                        md = _this.replaceAll(md, searchPattern, replacePattern);
                    }
                });
                _this.$scope.data.mdText = md;
            }, 0);
        };
        MarkdownWidgetCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'messageBusService',
            'mapService'
        ];
        return MarkdownWidgetCtrl;
    }());
    MarkdownWidget.MarkdownWidgetCtrl = MarkdownWidgetCtrl;
})(MarkdownWidget || (MarkdownWidget = {}));
//# sourceMappingURL=MarkdownWidgetCtrl.js.map
var MarvelWidget;
(function (MarvelWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        MarvelWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        MarvelWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    MarvelWidget.myModule.directive('marvelwidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/MarvelWidget/MarvelWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: MarvelWidget.MarvelWidgetCtrl
            };
        }
    ]);
})(MarvelWidget || (MarvelWidget = {}));
//# sourceMappingURL=MarvelWidget.js.map
var MarvelWidget;
(function (MarvelWidget) {
    var MarvelWidgetData = (function () {
        function MarvelWidgetData() {
        }
        return MarvelWidgetData;
    }());
    MarvelWidget.MarvelWidgetData = MarvelWidgetData;
    var MarvelWidgetCtrl = (function () {
        function MarvelWidgetCtrl($scope, $timeout, $translate, $layerService, $messageBus, $mapService) {
            var _this = this;
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$translate = $translate;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            this.parentWidget = $("#" + this.widget.elementId).parent();
            this.defaultStates = ['OK', 'Stressed', 'Failed'];
            this.initDependencies();
            $scope.data = this.widget.data;
            $scope.minimized = false;
            $scope.editmode = false;
            if (typeof $scope.data.featureTypeName !== 'undefined') {
                // Hide widget
                this.parentWidget.hide();
                this.$messageBus.subscribe('feature', function (action, feature) {
                    switch (action) {
                        case 'onFeatureDeselect':
                        case 'onFeatureSelect':
                            _this.selectFeature(feature);
                            break;
                        default:
                            break;
                    }
                });
            }
        }
        MarvelWidgetCtrl.prototype.initDependencies = function () {
            var _this = this;
            this.$scope.dependencyTypes = {};
            this.$scope.dependencyTypes['_dep_water'] = { label: '', type: 'number' };
            this.$scope.dependencyTypes['_dep_UPS'] = { label: '', type: 'number' };
            this.$scope.dependencyTypes['_dep_features'] = { label: '', type: 'stringarray' };
            // Overwrite labels with translations
            this.$translate('MARVEL_WATER_LEVEL').then(function (translation) {
                _this.$scope.dependencyTypes['_dep_water']['label'] = translation;
            });
            this.$translate('MARVEL_UPS_DURATION').then(function (translation) {
                _this.$scope.dependencyTypes['_dep_UPS']['label'] = translation;
            });
            this.$translate('MARVEL_FEATURE_DEP').then(function (translation) {
                _this.$scope.dependencyTypes['_dep_features']['label'] = translation;
            });
            this.$scope.states = this.defaultStates;
            return {};
        };
        MarvelWidgetCtrl.prototype.minimize = function () {
            this.$scope.minimized = !this.$scope.minimized;
            if (this.$scope.minimized) {
                this.parentWidget.css("height", "30px");
            }
            else {
                this.parentWidget.css("height", this.widget.height);
            }
        };
        MarvelWidgetCtrl.prototype.edit = function () {
            var _this = this;
            this.$scope.editmode = !this.$scope.editmode;
            if (!this.$scope.editmode) {
                this.$timeout(function () {
                    var w = $("#" + _this.widget.elementId);
                    Marvelous.refreshView(w);
                }, 50);
            }
        };
        MarvelWidgetCtrl.prototype.close = function () {
            this.parentWidget.hide();
        };
        /** Save single feature update by sending it to the server over the messageBus  */
        MarvelWidgetCtrl.prototype.save = function () {
            var f = this.$scope.selectedFeature;
            var s = new csComp.Services.LayerUpdate();
            s.layerId = f.layerId;
            s.action = csComp.Services.LayerUpdateAction.updateFeature;
            s.item = csComp.Services.Feature.serialize(f);
            this.$messageBus.serverSendMessageAction("layer", s);
            this.edit(); // Toggle edit mode
            console.log('Published feature changes');
        };
        /** Save all features of the selected feature's featureType. Set a property
          * 'changeAllFeaturesOfType' to inform the simservice that all features
          * should be updated.
          */
        MarvelWidgetCtrl.prototype.saveAll = function () {
            var f = this.$scope.selectedFeature;
            var s = new csComp.Services.LayerUpdate();
            s.layerId = f.layerId;
            s.action = csComp.Services.LayerUpdateAction.updateFeature;
            s.item = csComp.Services.Feature.serialize(f);
            s.item['changeAllFeaturesOfType'] = true;
            this.$messageBus.serverSendMessageAction("layer", s);
            this.edit(); // Toggle edit mode
            console.log('Published feature changes');
        };
        MarvelWidgetCtrl.prototype.escapeRegExp = function (str) {
            return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        };
        MarvelWidgetCtrl.prototype.replaceAll = function (str, find, replace) {
            return str.replace(new RegExp(this.escapeRegExp(find), 'g'), replace);
        };
        MarvelWidgetCtrl.prototype.addDependency = function (id, dep) {
            if (this.$scope.selectedFeature.properties.hasOwnProperty(id)) {
                delete this.$scope.selectedFeature.properties[id];
            }
            else {
                switch (dep.type) {
                    case 'number':
                        this.$scope.selectedFeature.properties[id] = 0;
                        break;
                    case 'string':
                        this.$scope.selectedFeature.properties[id] = '';
                        break;
                    case 'stringarray':
                        this.$scope.selectedFeature.properties[id] = [];
                        break;
                    default:
                        this.$scope.selectedFeature.properties[id] = null;
                        break;
                }
            }
        };
        MarvelWidgetCtrl.prototype.addDependencyFeature = function (dep) {
            if (!this.$scope.selectedFeature.properties.hasOwnProperty(dep))
                return;
            var newVal = $('#add-' + dep).val();
            if (!newVal || (newVal === ''))
                return;
            if (!this.$scope.selectedFeature.properties[dep].some(function (d) { return newVal === d; })) {
                this.$scope.selectedFeature.properties[dep].push(newVal);
                $('#add-' + dep).val('');
            }
        };
        MarvelWidgetCtrl.prototype.removeDependencyFeature = function (dep, name) {
            if (this.$scope.selectedFeature.properties.hasOwnProperty(dep)) {
                this.$scope.selectedFeature.properties[dep] = this.$scope.selectedFeature.properties[dep].filter(function (d) { return name !== d; });
            }
        };
        MarvelWidgetCtrl.prototype.selectFeature = function (feature) {
            var _this = this;
            if (!feature || !feature.isSelected) {
                this.parentWidget.hide();
                return;
            }
            if (typeof this.$scope.data.marvelFolder === 'undefined')
                return;
            if (!feature.fType || !feature.fType.id)
                return;
            //TODO: get the options from the propertyTypeData
            var pts = csComp.Helpers.getPropertyTypes(feature.fType, {});
            pts.forEach(function (p) {
                if (p.hasOwnProperty && p.hasOwnProperty('label') && p.label === 'state') {
                    _this.$scope.states = _.values(p.options);
                }
            });
            this.$scope.selectedFeature = feature;
            var featureTypeName = feature.fType.id.split('#').pop().replace(/(\_\d$)/, ''); // Remove state appendix (e.g. Hospital_0)
            var filePath = this.$scope.data.marvelFolder + featureTypeName + '.mrvjson';
            this.parentWidget.show();
            $.ajax({
                url: filePath,
                success: function (marvel) {
                    _this.$timeout(function () {
                        _this.$scope.data.title = feature.fType.name;
                        var w = $("#" + _this.widget.elementId);
                        Marvelous.model(marvel, featureTypeName, w);
                    }, 0);
                },
                error: function () {
                    _this.parentWidget.hide();
                }
            });
        };
        MarvelWidgetCtrl.$inject = [
            '$scope',
            '$timeout',
            '$translate',
            'layerService',
            'messageBusService',
            'mapService'
        ];
        return MarvelWidgetCtrl;
    }());
    MarvelWidget.MarvelWidgetCtrl = MarvelWidgetCtrl;
})(MarvelWidget || (MarvelWidget = {}));
//# sourceMappingURL=MarvelWidgetCtrl.js.map
var MCAWidget;
(function (MCAWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        MCAWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        MCAWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    MCAWidget.myModule.directive('mcawidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/MCAWidget/MCAWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: MCAWidget.MCAWidgetCtrl
            };
        }
    ]);
})(MCAWidget || (MCAWidget = {}));
//# sourceMappingURL=MCAWidget.js.map
var MCAWidget;
(function (MCAWidget) {
    var MCAWidgetData = (function () {
        function MCAWidgetData() {
        }
        return MCAWidgetData;
    }());
    MCAWidget.MCAWidgetData = MCAWidgetData;
    var MCAWidgetCtrl = (function () {
        function MCAWidgetCtrl($scope, $timeout, $controller, $layerService, $messageBus, $mapService) {
            var _this = this;
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$controller = $controller;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            $scope.data = this.widget.data;
            if (typeof $scope.data.layerId !== 'undefined') {
                // Hide widget
                this.parentWidget = $("#" + this.widget.elementId).parent();
                this.parentWidget.hide();
                this.$messageBus.subscribe('layer', function (action, layer) {
                    switch (action) {
                        case 'activated':
                        case 'deactivate':
                            _this.activateLayer(layer);
                            break;
                        default:
                            break;
                    }
                });
            }
        }
        MCAWidgetCtrl.prototype.activateLayer = function (layer) {
            var _this = this;
            this.mcaScope = this.getMcaScope();
            if (!this.mcaScope)
                return;
            if (layer.id !== this.$scope.data.layerId || (layer.id === this.$scope.data.layerId && !layer.enabled)) {
                this.parentWidget.hide();
                return;
            }
            this.$timeout(function () {
                _this.parentWidget.show();
            }, 0);
        };
        MCAWidgetCtrl.prototype.getMcaScope = function () {
            var mcaElm = angular.element('div[id="mca"]');
            if (!mcaElm) {
                console.log('Mca element not found.');
                return;
            }
            var mcaScope = mcaElm.scope();
            if (!mcaScope) {
                console.log('Mca controller scope not found.');
                return;
            }
            else {
                this.$scope.data.availableMcas = mcaScope.vm.availableMcas;
                return mcaScope;
            }
        };
        MCAWidgetCtrl.prototype.setMcaAsStyle = function (mcaNr) {
            if (!this.mcaScope || !this.mcaScope.vm.mca) {
                console.log('Mca controller scope not found.');
                return;
            }
            else {
                var vm = this.mcaScope.vm;
                if (!vm.showFeature) {
                    this.$messageBus.notifyWithTranslation('SELECT_A_FEATURE', 'SELECT_FEATURE_FOR_STYLE');
                    return;
                }
                if (vm.properties.length > 0) {
                    var availableMcas = vm.availableMcas.length;
                    if (mcaNr <= availableMcas) {
                        vm.mca = vm.availableMcas[mcaNr];
                        vm.updateMca();
                    }
                    console.log('Set mca style.');
                    vm.setStyle(vm.properties[0]);
                }
            }
        };
        MCAWidgetCtrl.$inject = [
            '$scope',
            '$timeout',
            '$controller',
            'layerService',
            'messageBusService',
            'mapService'
        ];
        return MCAWidgetCtrl;
    }());
    MCAWidget.MCAWidgetCtrl = MCAWidgetCtrl;
})(MCAWidget || (MCAWidget = {}));
//# sourceMappingURL=MCAWidgetCtrl.js.map
var NavigatorWidget;
(function (NavigatorWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        NavigatorWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        NavigatorWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    NavigatorWidget.myModule.directive('navigatorwidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Navigator/NavigatorWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: NavigatorWidget.NavigatorWidgetCtrl
            };
        }
    ]);
})(NavigatorWidget || (NavigatorWidget = {}));
//# sourceMappingURL=NavigatorWidget.js.map
var NavigatorWidget;
(function (NavigatorWidget) {
    var NavigatorWidgetData = (function () {
        function NavigatorWidgetData() {
        }
        return NavigatorWidgetData;
    }());
    NavigatorWidget.NavigatorWidgetData = NavigatorWidgetData;
    var NavigatorWidgetCtrl = (function () {
        function NavigatorWidgetCtrl($scope, $timeout, $layerService, $messageBus, $mapService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            if (this.widget.data)
                $scope.data = this.widget.data;
            if (typeof $scope.data.featureTypeName !== 'undefined' && typeof $scope.data.dynamicProperties !== 'undefined' && $scope.data.dynamicProperties.length > 0) {
                // Hide widget
                this.parentWidget = $("#" + this.widget.elementId).parent();
                this.parentWidget.hide();
            }
        }
        NavigatorWidgetCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'messageBusService',
            'mapService'
        ];
        return NavigatorWidgetCtrl;
    }());
    NavigatorWidget.NavigatorWidgetCtrl = NavigatorWidgetCtrl;
})(NavigatorWidget || (NavigatorWidget = {}));
//# sourceMappingURL=NavigatorWidgetCtrl.js.map
var PostMan;
(function (PostMan) {
    /** Config */
    var moduleName = 'csComp';
    try {
        PostMan.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        PostMan.myModule = angular.module(moduleName, []);
    }
    /**
     * Directive (editor) to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN.
     * Since this is an editor, the name of the directive is a convention: always use main directive name, plus Edit!
     */
    PostMan.myModule.directive('postmanEdit', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/PostMan/PostMan-edit.tpl.html',
                replace: true,
                transclude: false,
                controller: PostMan.PostManEditCtrl
            };
        }
    ]);
})(PostMan || (PostMan = {}));
//# sourceMappingURL=PostMan-edit.js.map
var PostMan;
(function (PostMan) {
    /** Config */
    var moduleName = 'csComp';
    try {
        PostMan.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        PostMan.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    PostMan.myModule.directive('postman', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/PostMan/PostMan.tpl.html',
                replace: true,
                transclude: false,
                controller: PostMan.PostManCtrl
            };
        }
    ]);
})(PostMan || (PostMan = {}));
//# sourceMappingURL=PostMan.js.map
var PostMan;
(function (PostMan) {
    var PostManCtrl = (function () {
        function PostManCtrl($scope, $http, messageBusService, $timeout) {
            this.$scope = $scope;
            this.$http = $http;
            this.messageBusService = messageBusService;
            this.$timeout = $timeout;
            $scope.vm = this;
            var par = $scope.$parent;
            $scope.data = par.widget.data;
            if ($scope.data.messages) {
                $scope.selectedMessage = $scope.data.messages[0];
            }
        }
        PostManCtrl.prototype.execute = function () {
            var _this = this;
            if (!this.$scope.selectedMessage)
                return;
            var msg = this.$scope.selectedMessage;
            this.result = '';
            switch (msg.httpMethod.name.toUpperCase()) {
                case 'POST':
                    this.$http.post(msg.url, msg.message)
                        .success(function () { _this.result = 'OK'; })
                        .error(function (err) { _this.result = "Error: " + err; });
                    break;
                case 'PUT':
                    this.$http.put(msg.url, msg.message)
                        .success(function () { _this.result = 'OK'; })
                        .error(function (err) { _this.result = "Error: " + err; });
                    break;
                case 'GET':
                    this.$http.get(msg.url, msg.message)
                        .success(function (data) { _this.result = "Result: " + data; })
                        .error(function (err) { _this.result = "Error: " + err; });
                    break;
                case 'DELETE':
                    this.$http.delete(msg.url, msg.message)
                        .success(function () { _this.result = 'OK'; })
                        .error(function (err) { _this.result = "Error: " + err; });
                    break;
            }
        };
        PostManCtrl.$inject = [
            '$scope',
            '$http',
            'messageBusService',
            '$timeout'
        ];
        return PostManCtrl;
    }());
    PostMan.PostManCtrl = PostManCtrl;
})(PostMan || (PostMan = {}));
//# sourceMappingURL=PostManCtrl.js.map
var PostMan;
(function (PostMan) {
    var PostManEditCtrl = (function () {
        function PostManEditCtrl($scope, $timeout, $messageBus, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$messageBus = $messageBus;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            $scope.methods = [
                { name: 'GET' },
                { name: 'PUT' },
                { name: 'POST' },
                { name: 'DELETE' }
            ];
            var par = $scope.$parent;
            this.widget = par.data;
            $scope.data = this.widget.data;
            if (!$scope.data.messages) {
                $scope.data.messages = [];
                this.addMessage();
            }
            else {
                $scope.selectedMessage = $scope.data.messages[0];
            }
        }
        PostManEditCtrl.prototype.addMessage = function () {
            this.$scope.selectedMessage = {
                name: 'New message...',
                httpMethod: this.$scope.methods[2]
            };
            this.$scope.data.messages.push(this.$scope.selectedMessage);
        };
        PostManEditCtrl.prototype.deleteMessage = function () {
            if (!this.$scope.selectedMessage)
                return;
            var index = this.$scope.data.messages.indexOf(this.$scope.selectedMessage);
            if (index < 0)
                return;
            this.$scope.data.messages.slice(index, 1);
            if (this.$scope.data.messages.length === 0)
                this.addMessage();
            else
                this.$scope.selectedMessage = this.$scope.data.messages[0];
        };
        // $inject annotation.
        PostManEditCtrl.$inject = [
            '$scope',
            '$timeout',
            'messageBusService',
            'dashboardService'
        ];
        return PostManEditCtrl;
    }());
    PostMan.PostManEditCtrl = PostManEditCtrl;
})(PostMan || (PostMan = {}));
//# sourceMappingURL=PostManEditCtrl.js.map
var Presentation;
(function (Presentation) {
    /**
     * This service keeps the presentation state, so that when we switch between tabs,
     * we don't loose any information.
     */
    var PresentationService = (function () {
        function PresentationService($rootScope, layerService, messageBusService, dashboardService) {
            // this.dashboardService.widgetTypes['presentation'] = <csComp.Services.IWidget>{
            //     id: 'presentation',
            //     icon: 'images/politie_zwart.png',
            //     description: 'Show presentation widget.'
            // };
            var _this = this;
            this.$rootScope = $rootScope;
            this.layerService = layerService;
            this.messageBusService = messageBusService;
            this.dashboardService = dashboardService;
            /** All slides, from all open layers, grouped by layer id. */
            this.presentations = {};
            /** The active slides for each widget, where each key represents a widget's id. */
            this.activePresentation = {};
            // var ppt = csComp.Helpers.createRightPanelTab(
            //     'containers', 'presentation', null, 'Presentation', '{{"PowerPoint view" | translate}}', 'images/politie_zwart.png', false, false);
            // messageBusService.publish('rightpanel', 'activate', ppt);
            messageBusService.subscribe('layer', function (title, layer) {
                if (layer && !layer.tags || (layer.tags && layer.tags.indexOf('presentation') < 0))
                    return;
                switch (title) {
                    case 'activated':
                        _this.addSlidesFromLayer(layer);
                        break;
                    case 'deactivate':
                        _this.removeSlidesFromLayer(layer);
                        break;
                }
            });
        }
        /** Initialize the layer by creating an initial presentation */
        PresentationService.prototype.createPresentation = function (layer) {
            if (this.presentations.hasOwnProperty(layer.id))
                return;
            var presentation = {
                title: layer.title,
                slides: []
            };
            this.presentations[layer.id] = presentation;
            return presentation;
        };
        /** Add the slides from the project layer */
        PresentationService.prototype.addSlidesFromLayer = function (layer) {
            this.removeSlidesFromLayer(layer); // remove any old ones - shouldn't be there though
            var presentation = this.createPresentation(layer);
            var features = csComp.Services.ProjectLayer.getFeatures(layer);
            if (features && features.length) {
                // TODO REMOVE
                // presentation.slides.push({ index: 1, content: `<h1>Huidige status</h1><br><ul><li>Drukte: 80%</li><li>Incidenten: ...</li><li>...</li></ul>` });
                // presentation.slides.push({ index: 2, content: `<h1>Huidige status</h1><br><ul><li>Punt 1</li><li>Punt 2</li><li>Punt 3</li></ul>` });
                // presentation.slides.push({ index: 3, content: `<h1>Verwachting</h1><br><ul><li>Drukte: ...</li><li>Punt 2</li><li>Punt 3</li></ul>` });
                features.forEach(function (f) {
                    if (!f.properties.hasOwnProperty('_slide'))
                        return;
                    var slide = f.properties['_slide'];
                    slide.featureId = f.id;
                    presentation.slides.push(slide);
                });
                presentation.slides.sort(function (s1, s2) { return s1.index - s2.index; });
            }
            this.messageBusService.publish('presentation', 'added', layer.id);
        };
        /** Remove the slides from the project layer */
        PresentationService.prototype.removeSlidesFromLayer = function (layer) {
            if (!this.presentations.hasOwnProperty(layer.id))
                return;
            // if (this.slides[layer.id] === this.activeSlides) this.activeSlides = null;
            delete this.presentations[layer.id];
            this.messageBusService.publish('presentation', 'removed', layer.id);
            // if (this.activeSlides || Object.keys(this.slides).length === 0) {
            //     this.activeSlide = null;
            //     return;
            // }
            // this.activeSlides = this.slides[Object.keys(this.slides)[0]];
            // this.activeSlideIndex = 0;
            // this.updateActiveSlide();
        };
        /** Update all slides in the layer */
        PresentationService.prototype.save = function (layer) {
            var _this = this;
            if (!this.presentations.hasOwnProperty(layer.id))
                return;
            var presentation = this.presentations[layer.id];
            presentation.slides.forEach(function (slide) {
                var feature = _this.layerService.findFeature(layer, slide.featureId);
                if (feature) {
                    feature.properties['_slide'] = slide;
                    _this.layerService.saveFeature(feature);
                }
                else {
                    // create new feature
                    var f = new csComp.Services.Feature();
                    f.id = slide.featureId = csComp.Helpers.getGuid();
                    f.properties = {};
                    f.properties['_slide'] = slide;
                    _this.layerService.createFeature(f, layer);
                }
            });
        };
        PresentationService.prototype.isFirstPresentation = function (presentation) {
            return Object.keys(this.presentations).length === 0 || presentation === this.presentations[Object.keys(this.presentations)[0]];
        };
        PresentationService.prototype.isLastPresentation = function (presentation) {
            return Object.keys(this.presentations).length === 0 || presentation === this.presentations[Object.keys(this.presentations)[Object.keys(this.presentations).length - 1]];
        };
        /** Get the next or the previous presentation, if any */
        PresentationService.prototype.getNextPrevPresentation = function (activeSlides, isNext) {
            var isFound = false;
            var lastKey;
            for (var key in this.presentations) {
                if (!this.presentations.hasOwnProperty(key))
                    continue;
                if (isFound)
                    return this.presentations[key];
                if (this.presentations[key] === activeSlides) {
                    if (!isNext)
                        return this.presentations[lastKey];
                    isFound = true;
                }
                lastKey = key;
            }
            return this.presentations[lastKey];
        };
        PresentationService.$inject = [
            '$rootScope',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return PresentationService;
    }());
    Presentation.PresentationService = PresentationService;
    /**
     * Register service
     */
    var moduleName = 'csComp';
    try {
        Presentation.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Presentation.myModule = angular.module(moduleName, []);
    }
    Presentation.myModule.service('presentationService', Presentation.PresentationService);
})(Presentation || (Presentation = {}));
//# sourceMappingURL=PresentationService.js.map
var Presentation;
(function (Presentation) {
    /** Config */
    var moduleName = 'csComp';
    try {
        Presentation.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Presentation.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    Presentation.myModule.directive('presentationEdit', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Presentation/PresentationWidget-edit.tpl.html',
                replace: true,
                transclude: false,
                controller: PresentationWidgetEditCtrl
            };
        }
    ]);
    var PresentationWidgetEditCtrl = (function () {
        function PresentationWidgetEditCtrl($scope, $http, layerService, messageBusService, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.layerService = layerService;
            this.messageBusService = messageBusService;
            this.$timeout = $timeout;
            this.layers = [];
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget || par.data;
            $scope.data = this.widget.data;
            var selectedLayerId = $scope.data.selectedLayerId;
            layerService.project.groups.forEach(function (g) {
                g.layers.forEach(function (l) {
                    _this.layers.push(l);
                    if (l.id === selectedLayerId) {
                        _this.selectedLayer = l;
                    }
                });
            });
        }
        PresentationWidgetEditCtrl.prototype.update = function () {
            if (this.selectedLayer)
                this.widget.data.selectedLayerId = this.selectedLayer.id;
        };
        PresentationWidgetEditCtrl.$inject = [
            '$scope',
            '$http',
            'layerService',
            'messageBusService',
            '$timeout'
        ];
        return PresentationWidgetEditCtrl;
    }());
    Presentation.PresentationWidgetEditCtrl = PresentationWidgetEditCtrl;
})(Presentation || (Presentation = {}));
//# sourceMappingURL=PresentationWidget-edit.js.map
var Presentation;
(function (Presentation) {
    /** Config */
    var moduleName = 'csComp';
    try {
        Presentation.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Presentation.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    Presentation.myModule.directive('presentation', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Presentation/PresentationWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: PresentationWidgetCtrl
            };
        }
    ]);
    /**
     * The presentation widget is inspired by ESRI Storymaps, collects slides from all enabled layers, which you can show one by one.
     * The slides are stored in the GeoJSON, as part of regular features, in the _slide property, which is of type ISlide.
     */
    var PresentationWidgetCtrl = (function () {
        function PresentationWidgetCtrl($scope, layerService, messageBusService, presentationService) {
            var _this = this;
            this.$scope = $scope;
            this.layerService = layerService;
            this.messageBusService = messageBusService;
            this.presentationService = presentationService;
            /** Are we in edit mode */
            this.isEditing = false;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            if (!this.widget)
                this.widget = { id: 'rightPanel' };
            // $scope.data = <PresentationData>this.widget.data;
            // let selectedLayerId = $scope.data.selectedLayerId;
            // this.selectedLayer = layerService.findLayer(selectedLayerId);
            if (!presentationService.activePresentation.hasOwnProperty(this.widget.id)) {
                this.activePresentation = {};
            }
            else {
                this.activeSlideIndex = 0;
                this.updateActiveSlide();
            }
            messageBusService.subscribe('presentation', function (title, layerId) {
                switch (title) {
                    case 'added':
                        if (_this.activePresentation && _this.activePresentation.slides && _this.activePresentation.slides.length > 0)
                            return;
                        _this.activeLayerId = layerId;
                        _this.activePresentation = presentationService.presentations[layerId];
                        _this.activeSlideIndex = 0;
                        _this.updateActiveSlide();
                        break;
                    case 'removed':
                        if (_this.activeLayerId === layerId)
                            _this.activePresentation = null;
                        break;
                }
            });
        }
        Object.defineProperty(PresentationWidgetCtrl.prototype, "activePresentation", {
            /** The active slides from one layer */
            get: function () {
                return this.presentationService.activePresentation[this.widget.id];
            },
            set: function (slides) {
                this.presentationService.activePresentation[this.widget.id] = slides;
            },
            enumerable: true,
            configurable: true
        });
        PresentationWidgetCtrl.prototype.updateActiveSlide = function () {
            this.activeSlide = {};
            if (!this.activePresentation || !this.activePresentation.slides || this.activePresentation.slides.length === 0)
                return;
            this.activeSlide = this.activePresentation.slides[this.activeSlideIndex];
            if (!this.activeSlide)
                return;
            if (this.activeSlide.boundingBox) {
                this.layerService.activeMapRenderer.fitBounds(this.activeSlide.boundingBox);
            }
        };
        PresentationWidgetCtrl.prototype.selectSlide = function (index) {
            if (index >= this.activePresentation.slides.length)
                return;
            this.activeSlideIndex = index;
            this.updateActiveSlide();
        };
        Object.defineProperty(PresentationWidgetCtrl.prototype, "isFirstSlide", {
            get: function () { return !this.activePresentation || !this.activePresentation.slides || this.activeSlideIndex === 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PresentationWidgetCtrl.prototype, "isLastSlide", {
            get: function () { return !this.activePresentation || !this.activePresentation.slides || this.activeSlideIndex === this.activePresentation.slides.length - 1; },
            enumerable: true,
            configurable: true
        });
        PresentationWidgetCtrl.prototype.isActiveSlide = function (index) { return this.activeSlideIndex === index; };
        PresentationWidgetCtrl.prototype.nextSlide = function () {
            if (this.isLastSlide)
                return;
            this.activeSlideIndex++;
            this.updateActiveSlide();
        };
        PresentationWidgetCtrl.prototype.previousSlide = function () {
            if (this.isFirstSlide)
                return;
            this.activeSlideIndex--;
            this.updateActiveSlide();
        };
        Object.defineProperty(PresentationWidgetCtrl.prototype, "isFirstPresentation", {
            get: function () { return this.presentationService.isFirstPresentation(this.activePresentation); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PresentationWidgetCtrl.prototype, "isLastPresentation", {
            get: function () { return this.presentationService.isLastPresentation(this.activePresentation); },
            enumerable: true,
            configurable: true
        });
        PresentationWidgetCtrl.prototype.nextPresentation = function () {
            this.activePresentation = this.presentationService.getNextPrevPresentation(this.activePresentation, true);
            this.activeSlideIndex = 0;
            this.updateActiveSlide();
        };
        PresentationWidgetCtrl.prototype.previousPresentation = function () {
            this.activePresentation = this.presentationService.getNextPrevPresentation(this.activePresentation, false);
            this.activeSlideIndex = 0;
            this.updateActiveSlide();
        };
        PresentationWidgetCtrl.prototype.toggleEdit = function () {
            this.isEditing = !this.isEditing;
            if (this.isEditing) {
                this.layerService.visual.leftPanelVisible = false;
            }
            else {
                this.save();
            }
        };
        PresentationWidgetCtrl.prototype.addSlide = function () {
            this.activeSlide = { content: '' };
            this.activeSlideIndex++;
            if (this.activeSlideIndex === this.activePresentation.slides.length) {
                this.activePresentation.slides.push(this.activeSlide);
            }
            else {
                this.activePresentation.slides.splice(this.activeSlideIndex, 0, this.activeSlide);
            }
            this.reindexSlides();
            this.toggleEdit();
            this.save();
        };
        PresentationWidgetCtrl.prototype.reindexSlides = function () {
            var index = 0;
            this.activePresentation.slides.forEach(function (s) { return s.index = index++; });
        };
        PresentationWidgetCtrl.prototype.deleteSlide = function () {
            var _this = this;
            this.messageBusService.confirm('Delete slide?', 'Are you sure you want to delete this slide?', function (answer) {
                if (!answer)
                    return;
                // Delete slide in feature.
                var featureId = _this.activeSlide.featureId;
                var layer = _this.layerService.findLayer(_this.activeLayerId);
                var feature = _this.layerService.findFeature(layer, featureId);
                if (feature.properties.hasOwnProperty('Name') && feature.properties['Name'] !== '_slide') {
                    // Assume that we are dealing with a regular property, so only delete the slide.
                    delete feature.properties['_slide'];
                }
                else if (layer.data && layer.data.features) {
                    // This feature was created to hold the slide: delete it.
                    var i = layer.data.features.indexOf(feature);
                    layer.data.features.splice(i, 1);
                    _this.layerService.removeFeature(feature, true);
                }
                var index = _this.activeSlideIndex;
                var slides = _this.activePresentation.slides;
                slides.splice(index, 1);
                if (slides.length === 0) {
                    _this.toggleEdit();
                    _this.save();
                    return;
                }
                if (index >= slides.length) {
                    index--;
                    _this.activeSlideIndex = index;
                }
                _this.reindexSlides();
                _this.updateActiveSlide();
                _this.save();
            });
        };
        PresentationWidgetCtrl.prototype.saveLocation = function () {
            this.activeSlide.boundingBox = this.layerService.activeMapRenderer.getExtent();
            this.messageBusService.notify('Location saved', 'The current location has been saved with this slide.');
            this.save();
        };
        PresentationWidgetCtrl.prototype.save = function () {
            var layer = this.layerService.findLayer(this.activeLayerId);
            if (!layer)
                return;
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest')
                this.$scope.$digest();
            this.presentationService.save(layer);
        };
        PresentationWidgetCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            'presentationService'
        ];
        return PresentationWidgetCtrl;
    }());
    Presentation.PresentationWidgetCtrl = PresentationWidgetCtrl;
})(Presentation || (Presentation = {}));
//# sourceMappingURL=PresentationWidget.js.map
var SimState;
(function (SimState) {
    /** Config */
    var moduleName = 'csComp';
    try {
        SimState.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        SimState.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    SimState.myModule.directive('simstateEdit', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/SimState/SimState.tpl.html',
                replace: true,
                transclude: false,
                controller: SimStateEditCtrl
            };
        }
    ]);
    var SimStateEditCtrl = (function () {
        function SimStateEditCtrl($scope, $http, messageBusService, $timeout) {
            this.$scope = $scope;
            this.$http = $http;
            this.messageBusService = messageBusService;
            this.$timeout = $timeout;
            $scope.vm = this;
            //var par = <any>$scope.$parent;
            //$scope.data = <PostManEditorData>par.widget.data;
        }
        SimStateEditCtrl.$inject = [
            '$scope',
            '$http',
            'messageBusService',
            '$timeout'
        ];
        return SimStateEditCtrl;
    }());
    SimState.SimStateEditCtrl = SimStateEditCtrl;
})(SimState || (SimState = {}));
//# sourceMappingURL=SimState-edit.js.map
var SimState;
(function (SimState) {
    /** Config */
    var moduleName = 'csComp';
    try {
        SimState.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        SimState.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    SimState.myModule.directive('simstate', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/SimState/SimState.tpl.html',
                replace: true,
                transclude: false,
                controller: SimStateCtrl
            };
        }
    ]);
    var SimStateCtrl = (function () {
        function SimStateCtrl($scope, $http, messageBusService, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.messageBusService = messageBusService;
            this.$timeout = $timeout;
            this.states = {};
            $scope.vm = this;
            messageBusService.serverSubscribe('Sim.SimState.', 'key', function (title, msg) {
                if (!msg || !msg.hasOwnProperty('data') || !msg.data.hasOwnProperty('item'))
                    return;
                //console.log(`Server subscription received: ${title}, ${JSON.stringify(msg, null, 2) }.`);
                _this.$timeout(function () {
                    var state = msg.data.item;
                    if (state.state === 'Exit')
                        delete _this.states[state.id];
                    else
                        _this.states[state.name] = state; // Although id would be better, we could end up with the remains of restarted services.
                }, 0);
            });
        }
        SimStateCtrl.$inject = [
            '$scope',
            '$http',
            'messageBusService',
            '$timeout'
        ];
        return SimStateCtrl;
    }());
    SimState.SimStateCtrl = SimStateCtrl;
})(SimState || (SimState = {}));
//# sourceMappingURL=SimState.js.map
var SimTimeController;
(function (SimTimeController) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        SimTimeController.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        SimTimeController.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    SimTimeController.myModule.directive('simtimecontrollerEdit', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/SimTimeController/SimTimeController-edit.tpl.html',
                replace: true,
                transclude: false,
                controller: SimTimeController.SimTimeControllerEditCtrl
            };
        }
    ]);
})(SimTimeController || (SimTimeController = {}));
//# sourceMappingURL=SimTimeController-edit.js.map
var SimTimeController;
(function (SimTimeController) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        SimTimeController.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        SimTimeController.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    SimTimeController.myModule.directive('simtimecontroller', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/SimTimeController/SimTimeController.tpl.html',
                replace: true,
                transclude: false,
                controller: SimTimeController.SimTimeControllerCtrl
            };
        }
    ]);
})(SimTimeController || (SimTimeController = {}));
//# sourceMappingURL=SimTimeController.js.map
var SimTimeController;
(function (SimTimeController) {
    (function (PlayState) {
        PlayState[PlayState["Stopped"] = 0] = "Stopped";
        PlayState[PlayState["Playing"] = 1] = "Playing";
        PlayState[PlayState["Paused"] = 2] = "Paused";
    })(SimTimeController.PlayState || (SimTimeController.PlayState = {}));
    var PlayState = SimTimeController.PlayState;
    (function (SimCommand) {
        SimCommand[SimCommand["Start"] = 0] = "Start";
        SimCommand[SimCommand["Pause"] = 1] = "Pause";
        SimCommand[SimCommand["Stop"] = 2] = "Stop";
        SimCommand[SimCommand["Run"] = 3] = "Run";
        SimCommand[SimCommand["Finish"] = 4] = "Finish";
        SimCommand[SimCommand["Exit"] = 5] = "Exit";
    })(SimTimeController.SimCommand || (SimTimeController.SimCommand = {}));
    var SimCommand = SimTimeController.SimCommand;
    var SimTimeControllerCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function SimTimeControllerCtrl($scope, $http, messageBusService, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.messageBusService = messageBusService;
            this.$timeout = $timeout;
            this.timeSinceStartString = '00:00';
            this.speed = 1;
            /** Start time, e.g. when restarting */
            this.startTime = new Date();
            /** Current time */
            this.time = this.startTime;
            // DateTimePicker
            this.isOpen = false;
            this.timeOptions = {
                readonlyInput: false,
                showMeridian: false
            };
            // For the view's status
            this.isPlaying = false;
            this.isPaused = false;
            this.isStopped = true;
            $scope.vm = this;
            var par = $scope.$parent;
            this.editorData = par.widget.data;
            this.httpMethod = 'POST';
            if (this.editorData.hasOwnProperty('httpMethod') && this.editorData.httpMethod.hasOwnProperty('name'))
                this.httpMethod = this.editorData.httpMethod.name.toUpperCase();
            this.url = this.editorData.url || 'api/keys/simTime';
            this.fsm = new FSM.FiniteStateMachine(PlayState.Stopped);
            this.fsm.fromAny(PlayState).to(PlayState.Stopped).on(SimCommand.Stop);
            this.fsm.from(PlayState.Stopped).to(PlayState.Playing).on(SimCommand.Start);
            this.fsm.from(PlayState.Playing).to(PlayState.Stopped).on(SimCommand.Stop);
            this.fsm.from(PlayState.Playing).to(PlayState.Paused).on(SimCommand.Pause);
            this.fsm.from(PlayState.Paused).to(PlayState.Stopped).on(SimCommand.Stop);
            this.fsm.from(PlayState.Paused).to(PlayState.Playing).on(SimCommand.Start);
            this.fsm.onTransition = function (fromState, toState) {
                console.log("Moving from " + PlayState[fromState] + " to " + PlayState[toState] + ".");
            };
            this.fsm.onEnter(PlayState.Stopped, function (from) {
                _this.$timeout(function () {
                    _this.time = _this.startTime;
                    _this.timeSinceSimulationStart = 0;
                    _this.updateTimeSinceSimStart();
                    _this.isStopped = true;
                    _this.isPlaying = false;
                    _this.isPaused = false;
                }, 0);
                _this.sendSimTimeMessage(SimCommand.Stop);
                return true;
            });
            this.fsm.onEnter(PlayState.Playing, function (from) {
                _this.$timeout(function () {
                    _this.isPlaying = true;
                    _this.isStopped = false;
                    _this.isPaused = false;
                }, 0);
                _this.sendSimTimeMessage(SimCommand.Start);
                return true;
            });
            this.fsm.onEnter(PlayState.Paused, function (from) {
                _this.$timeout(function () {
                    _this.isPaused = true;
                    _this.isStopped = false;
                    _this.isPlaying = false;
                }, 0);
                _this.sendSimTimeMessage(SimCommand.Pause);
                return true;
            });
            // $http.get(this.url)
            //     .then((msg) => {
            //     // TODO Why does this always return an empty msg.data element
            //     // console.log('Received message: ');
            //     // console.log(msg);
            //     // console.log(JSON.stringify(msg, null, 2));
            // })
            console.log("Simtimecontroller constructed");
        }
        SimTimeControllerCtrl.prototype.updateTimeSinceSimStart = function () {
            var msec = this.time.valueOf() - this.startTime.valueOf();
            var days = Math.floor(msec / 86400000);
            msec -= days * 86400000;
            var hours = Math.floor(msec / 3600000);
            msec -= hours * 3600000;
            var minutes = Math.floor(msec / 60000);
            msec -= minutes * 60000;
            var seconds = Math.floor(msec / 1000);
            var result = '';
            if (days > 0)
                result = days + "d ";
            result += (hours < 10 ? '0' + hours : hours) + ":" + (minutes < 10 ? '0' + minutes : minutes);
            this.timeSinceStartString = result;
        };
        SimTimeControllerCtrl.prototype.subscribeToSimTime = function () {
            var _this = this;
            this.messageBusHandle = this.messageBusService.serverSubscribe('Sim.SimTime', 'key', function (title, msg) {
                //console.log(`Server subscription received: ${title}, ${JSON.stringify(msg, null, 2) }.`);
                if (!msg
                    || !msg.hasOwnProperty('data')
                    || !msg.data.hasOwnProperty('item')
                    || !msg.data.item)
                    return;
                _this.$timeout(function () {
                    if (msg.data.item.hasOwnProperty('simTime'))
                        _this.time = new Date(+msg.data.item.simTime);
                    else
                        _this.time = new Date(msg.data.item);
                    if (!isNaN(_this.time.getTime())) {
                        _this.updateTimeSinceSimStart();
                        _this.messageBusService.publish('timeline', 'setFocus', _this.time);
                    }
                    else {
                        console.log("ERROR processing Sim.SimTime message! Received: (input: " + JSON.stringify(msg.data.item, null, 2));
                    }
                    //console.log(`TIME: ${this.time} (input: ${JSON.stringify(data.data.item, null, 2)})`);
                }, 0);
            });
        };
        SimTimeControllerCtrl.prototype.play = function () {
            if (!this.messageBusHandle) {
                this.subscribeToSimTime();
            }
            this.fsm.trigger(SimCommand.Start);
        };
        SimTimeControllerCtrl.prototype.pause = function () {
            this.fsm.trigger(SimCommand.Pause);
        };
        SimTimeControllerCtrl.prototype.stop = function () {
            if (this.messageBusHandle) {
                this.messageBusService.serverUnsubscribe(this.messageBusHandle);
                this.messageBusHandle = null;
            }
            this.fsm.trigger(SimCommand.Stop);
        };
        SimTimeControllerCtrl.prototype.increaseSpeed = function () {
            this.speed *= 2;
            this.speedChanged();
        };
        SimTimeControllerCtrl.prototype.decreaseSpeed = function () {
            this.speed /= 2;
            this.speedChanged();
        };
        SimTimeControllerCtrl.prototype.setSpeed = function (newSpeed) {
            this.speed = newSpeed;
            this.speedChanged();
        };
        SimTimeControllerCtrl.prototype.setTime = function (newTime) {
            if (this.fsm.currentState !== PlayState.Stopped)
                return;
            this.startTime = this.time = new Date(newTime);
        };
        SimTimeControllerCtrl.prototype.openCalendar = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.isOpen = true;
        };
        ;
        SimTimeControllerCtrl.prototype.speedChanged = function () {
            if (this.fsm.currentState === PlayState.Playing)
                this.sendSimTimeMessage(SimCommand.Start);
        };
        SimTimeControllerCtrl.prototype.sendSimTimeMessage = function (cmd) {
            var msg = {
                simTime: this.time.valueOf().toString(),
                simSpeed: this.speed.toString(),
                simCmd: SimCommand[cmd],
                type: 'simTime'
            };
            switch (this.httpMethod) {
                case 'POST':
                    this.$http.post(this.url, msg)
                        .error(function (err) { return alert("Failed to deliver message: " + JSON.stringify({ err: err })); });
                    break;
                case 'PUT':
                    this.$http.put(this.url, msg)
                        .error(function (err) { return alert("Failed to deliver message: " + JSON.stringify({ err: err })); });
                    break;
            }
            //
            // this.$http.post( '/api/keys/simTime', msg)
            //     .error((err) => alert( "Failed to deliver message: " + JSON.stringify({err: err})));
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        SimTimeControllerCtrl.$inject = [
            '$scope',
            '$http',
            'messageBusService',
            '$timeout'
        ];
        return SimTimeControllerCtrl;
    }());
    SimTimeController.SimTimeControllerCtrl = SimTimeControllerCtrl;
})(SimTimeController || (SimTimeController = {}));
//# sourceMappingURL=SimTimeControllerCtrl.js.map
var SimTimeController;
(function (SimTimeController) {
    /** Controller class for the SimTimeController editor */
    var SimTimeControllerEditCtrl = (function () {
        function SimTimeControllerEditCtrl($scope, $timeout, $messageBus, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$messageBus = $messageBus;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            $scope.methods = [
                { name: 'GET' },
                { name: 'PUT' },
                { name: 'POST' },
                { name: 'DELETE' }
            ];
            var par = $scope.$parent;
            this.widget = par.data;
            $scope.data = this.widget.data;
            if (!$scope.data.httpMethod)
                $scope.data.httpMethod = $scope.methods[2];
            if (!$scope.data.url)
                $scope.data.url = 'api/keys/simTime';
        }
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        SimTimeControllerEditCtrl.$inject = [
            '$scope',
            '$timeout',
            'messageBusService',
            'dashboardService'
        ];
        return SimTimeControllerEditCtrl;
    }());
    SimTimeController.SimTimeControllerEditCtrl = SimTimeControllerEditCtrl;
})(SimTimeController || (SimTimeController = {}));
//# sourceMappingURL=SimTimeControllerEditCtrl.js.map
var TableWidget;
(function (TableWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        TableWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        TableWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    TableWidget.myModule.directive('tablewidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/TableWidget/TableWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: TableWidget.TableWidgetCtrl
            };
        }
    ]);
})(TableWidget || (TableWidget = {}));
//# sourceMappingURL=TableWidget.js.map
var TableWidget;
(function (TableWidget) {
    var TableWidgetData = (function () {
        function TableWidgetData() {
        }
        return TableWidgetData;
    }());
    TableWidget.TableWidgetData = TableWidgetData;
    var TableWidgetCtrl = (function () {
        function TableWidgetCtrl($scope, $timeout, $layerService, $messageBus, $mapService, $sce) {
            var _this = this;
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$sce = $sce;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            if (this.widget.directive && this.widget.directive !== 'tablewidget') {
                console.log('Warning: ' + this.widget.directive + ' does not belong in TableWidgetCtrl!!! Id: ' + this.widget.id);
            }
            $scope.data = this.widget.data;
            $scope.data.tableHtml = '<table></table>';
            $scope.minimized = false;
            this.dataProperties = {};
            this.parentWidget = $('#' + this.widget.elementId).parent();
            if (typeof $scope.data.featureTypeName !== 'undefined' && typeof $scope.data.dynamicProperties !== 'undefined' && $scope.data.dynamicProperties.length > 0) {
                // Hide widget
                this.parentWidget.hide();
                this.$messageBus.subscribe('feature', function (action, feature) {
                    switch (action) {
                        case 'onFeatureDeselect':
                        case 'onFeatureSelect':
                            _this.selectFeature(feature);
                            break;
                        default:
                            break;
                    }
                });
            }
            if (!(typeof $scope.data.url === 'undefined')) {
                var url = $scope.data.url;
                if ($scope.data.useLanguagePrefix) {
                    var extensions = url.split('.');
                    var newExtension = this.$layerService.currentLocale + '.' + extensions.pop();
                    extensions.push(newExtension);
                    url = extensions.join('.');
                }
                $.get(url, function (table) {
                    $timeout(function () {
                        try {
                            $scope.data.content = JSON.parse(table);
                            _this.createTable();
                            _this.updateTable();
                        }
                        catch (error) {
                            console.log('Error parsing table: ' + error.message);
                            console.log('Table type: ' + (typeof table));
                        }
                    }, 0);
                });
            }
            // in case a separate datafile is used
            if (!(typeof $scope.data.dataSourceUrl === 'undefined')) {
                url = $scope.data.dataSourceUrl;
                $.get(url, function (properties) {
                    $timeout(function () {
                        _this.dataProperties = JSON.parse(properties);
                        _this.replaceKeys();
                    }, 0);
                });
            }
        }
        TableWidgetCtrl.prototype.createTable = function () {
            var data = this.$scope.data.content;
            var table = '<table style="width:100%">';
            if (!data.hasOwnProperty('columnHeaders'))
                return;
            table += '<tr class="tablewidget-row">';
            data.columnHeaders.forEach(function (h) {
                table += '<th class="tablewidget-cell border-bottom" style="width:' + 100 / (data.nrOfCols + 1) + '%">' + h + '</th>';
            });
            table += '</tr>';
            if (!data.hasOwnProperty('rowTitles') || !data.hasOwnProperty('datagrid'))
                return;
            data.datagrid.forEach(function (row, ri) {
                table += '<tr class="tablewidget-row">';
                table += '<th class="border-right">' + data.rowTitles[ri] + '</th>';
                row.forEach(function (col, ci) {
                    var style = (data.stylegrid) ? data.stylegrid[ri][ci] : '';
                    table += '<td class="tablewidget-cell" style="' + style + '">' + data.datagrid[ri][ci] + '</td>';
                });
                table += '</tr>';
            });
            table += '</table>';
            this.$scope.data.tableHtml = table;
        };
        TableWidgetCtrl.prototype.updateTable = function () {
            var tableContainer = $('#' + this.widget.elementId).find('#widgettable-container');
            tableContainer.html(this.$scope.data.tableHtml);
        };
        TableWidgetCtrl.prototype.minimize = function () {
            this.$scope.minimized = !this.$scope.minimized;
            if (this.$scope.minimized) {
                this.parentWidget.css('height', '30px');
            }
            else {
                this.parentWidget.css('height', this.widget.height);
            }
        };
        TableWidgetCtrl.prototype.canClose = function () {
            return (this.$scope.data.hasOwnProperty('canClose'))
                ? this.$scope.data['canClose']
                : true;
        };
        TableWidgetCtrl.prototype.close = function () {
            this.parentWidget.hide();
        };
        TableWidgetCtrl.prototype.escapeRegExp = function (str) {
            return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1');
        };
        TableWidgetCtrl.prototype.replaceAll = function (str, find, replace) {
            return str.replace(new RegExp(this.escapeRegExp(find), 'g'), replace);
        };
        TableWidgetCtrl.prototype.selectFeature = function (feature) {
            var _this = this;
            if (!feature || !feature.isSelected || feature.featureTypeName !== this.$scope.data.featureTypeName) {
                this.parentWidget.hide();
                return;
            }
            this.$timeout(function () {
                var d = _this.$scope.data.tableHtml;
                var i = 0;
                _this.$scope.data.dynamicProperties.forEach(function (p) {
                    var searchPattern = '{{' + i++ + '}}';
                    var displayText = '';
                    if (feature.properties.hasOwnProperty(p)) {
                        var pt = _this.$layerService.getPropertyType(feature, p);
                        displayText = csComp.Helpers.convertPropertyInfo(pt, feature.properties[p]);
                    }
                    d = _this.replaceAll(d, searchPattern, displayText);
                });
                _this.parentWidget.show();
                _this.$scope.data.tableHtml = d;
                _this.updateTable();
            }, 0);
        };
        TableWidgetCtrl.prototype.replaceKeys = function () {
            var _this = this;
            var d = this.$scope.data.tableHtml;
            this.$timeout(function () {
                var keys = Object.keys(_this.dataProperties);
                keys.forEach(function (k) {
                    if (_this.dataProperties.hasOwnProperty(k)) {
                        var searchPattern = '{{' + k + '}}';
                        var replacePattern = _this.dataProperties[k];
                        d = _this.replaceAll(d, searchPattern, replacePattern);
                    }
                });
                _this.$scope.data.tableHtml = d;
                _this.updateTable();
            }, 0);
        };
        TableWidgetCtrl.prototype.toTrusted = function (html) {
            try {
                if (html === undefined || html === null)
                    return this.$sce.trustAsHtml(html);
                return this.$sce.trustAsHtml(html.toString());
            }
            catch (e) {
                console.log(e + ': ' + html);
                return '';
            }
        };
        TableWidgetCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'messageBusService',
            'mapService',
            '$sce'
        ];
        return TableWidgetCtrl;
    }());
    TableWidget.TableWidgetCtrl = TableWidgetCtrl;
})(TableWidget || (TableWidget = {}));
//# sourceMappingURL=TableWidgetCtrl.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var OnlineSearchActions = (function (_super) {
            __extends(OnlineSearchActions, _super);
            /**
             * @param  {string} searchUrl: route to the search api
             */
            function OnlineSearchActions($http, searchUrl) {
                _super.call(this);
                this.$http = $http;
                this.isReady = true;
                this.id = 'OnlineSearchActions';
                this.searchUrl = searchUrl;
            }
            OnlineSearchActions.prototype.search = function (query, result) {
                var _this = this;
                var r = [];
                this.getHits(query.query, 15, function (searchResults) {
                    searchResults.forEach(function (sr) {
                        r.push({
                            title: sr.title,
                            description: sr.description,
                            icon: 'bower_components/csweb/dist-bower/images/large-marker.png',
                            service: _this.id,
                            location: JSON.parse(sr.location),
                            score: 0.99,
                            click: function () { return _this.onSelect(sr); }
                        });
                    });
                    result(null, r);
                });
            };
            /**
             * Get the features based on the entered text.
             */
            OnlineSearchActions.prototype.getHits = function (text, resultCount, cb) {
                if (resultCount === void 0) { resultCount = 15; }
                if (!this.isReady || text === null || text.length < 2) {
                    cb([]);
                    return;
                }
                var searchWords = text.toLowerCase().split(' ');
                var sqlSearch = searchWords.join(' & ');
                var searchObject = { query: sqlSearch, nrItems: resultCount };
                var searchResults = [];
                $.ajax({
                    type: 'POST',
                    url: this.searchUrl,
                    data: JSON.stringify(searchObject),
                    contentType: 'application/json',
                    dataType: 'json',
                    statusCode: {
                        200: function (data) {
                            console.log('Received online search result');
                            if (data.hasOwnProperty('result')) {
                                searchResults = data.result;
                            }
                            cb(searchResults);
                        },
                        404: function (data) {
                            console.log('Could not get online search result');
                            cb(searchResults);
                        }
                    },
                    error: function () {
                        console.log('Error getting online search results');
                        cb(searchResults);
                    }
                });
            };
            OnlineSearchActions.prototype.init = function (layerService) {
                _super.prototype.init.call(this, layerService);
            };
            OnlineSearchActions.prototype.onSelect = function (selectedItem) {
                var geoLoc;
                if (typeof selectedItem.location === 'string') {
                    try {
                        geoLoc = JSON.parse(selectedItem.location);
                    }
                    catch (error) {
                        console.log(error);
                    }
                }
                if (geoLoc && geoLoc.hasOwnProperty('coordinates')) {
                    this.layerService.$mapService.zoomToLocation(new L.LatLng(geoLoc.coordinates[1], geoLoc.coordinates[0]), 19);
                }
            };
            OnlineSearchActions.prototype.selectFeatureById = function (layerId, featureIndex) {
            };
            OnlineSearchActions.prototype.selectFeature = function (feature) {
            };
            return OnlineSearchActions;
        })(Services.BasicActionService);
        Services.OnlineSearchActions = OnlineSearchActions;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=BagSearchAction.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var BingSearchAction = (function (_super) {
            __extends(BingSearchAction, _super);
            /**
             * @param  {string} apiKey: route to the search api (optional, followed by a |), and the Bing maps key (required)
             */
            function BingSearchAction($http, apiKey, searchUrl, data) {
                var _this = this;
                if (searchUrl === void 0) { searchUrl = 'http://dev.virtualearth.net/REST/v1/Locations'; }
                if (data === void 0) { data = {
                    culture: 'nl',
                    userLocation: '52.077857,4.316639'
                }; }
                _super.call(this);
                this.$http = $http;
                this.apiKey = apiKey;
                this.searchUrl = searchUrl;
                this.data = data;
                this.isReady = true;
                this.id = 'BingSearchActions';
                this.searchCache = {};
                this.debouncedFn = _.debounce(function (query, result) { return _this.bingRestRequest(query, result); }, 2500);
            }
            BingSearchAction.prototype.init = function (layerService) {
                _super.prototype.init.call(this, layerService);
            };
            BingSearchAction.prototype.search = function (query, result) {
                if (query.query.length < 4)
                    return;
                this.debouncedFn(query, result);
            };
            /** Create the geocode request uri and call it using JSONP. */
            BingSearchAction.prototype.bingRestRequest = function (query, handler) {
                var _this = this;
                if (this.searchCache.hasOwnProperty(query.query)) {
                    this.geocodeCallback(this.searchCache[query.query], handler, query.query);
                    return;
                }
                var geocodeRequest = (this.searchUrl + "?query=")
                    + encodeURIComponent(query.query)
                    + ("&culture=" + this.data.culture + "&userLocation=" + this.data.userLocation + "&maxResults=10&jsonp=JSON_CALLBACK&key=" + this.apiKey);
                this.callRestService(geocodeRequest, function (result, handler, query) { return _this.geocodeCallback(result, handler, query); }, handler, query.query);
            };
            /** JSONP callback wrapper */
            BingSearchAction.prototype.callRestService = function (request, callback, handler, query) {
                this.$http.jsonp(request)
                    .success(function (r) {
                    callback(r, handler, query);
                })
                    .error(function (data, status, error, thing) {
                    alert(error);
                });
            };
            BingSearchAction.prototype.geocodeCallback = function (result, handler, query) {
                var _this = this;
                console.log('BING location search result:');
                console.log(JSON.stringify(result, null, 2));
                this.searchCache[query] = result;
                var searchResults = [];
                result.resourceSets.forEach(function (rs) {
                    rs.resources.forEach(function (r) {
                        searchResults.push({
                            type: r.entityType,
                            description: r.entityType,
                            title: r.name,
                            score: r.confidence === 'High' ? 1 : 0.3,
                            icon: result.brandLogoUri,
                            service: _this.id,
                            click: function () { return _this.onSelect(r); },
                            location: _this.swapLatLonInPoint(r.point)
                        });
                    });
                });
                handler(null, searchResults);
            };
            BingSearchAction.prototype.swapLatLonInPoint = function (location) {
                return {
                    type: location.type,
                    coordinates: [location.coordinates[1], location.coordinates[0]]
                };
            };
            BingSearchAction.prototype.onSelect = function (selectedItem) {
                var geoLoc = selectedItem.point;
                if (selectedItem.bbox) {
                    this.layerService.map.getMap().fitBounds(new L.LatLngBounds(selectedItem.bbox.slice(0, 2), selectedItem.bbox.slice(2, 4)));
                }
                else {
                    this.layerService.$mapService.zoomToLocation(new L.LatLng(geoLoc.coordinates[1], geoLoc.coordinates[0]), 19);
                }
            };
            return BingSearchAction;
        }(Services.BasicActionService));
        Services.BingSearchAction = BingSearchAction;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=BingSearchAction.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var KeywordIndex = (function () {
            function KeywordIndex() {
            }
            return KeywordIndex;
        }());
        Services.KeywordIndex = KeywordIndex;
        /** An index entry that contains a search result. */
        var Entry = (function () {
            function Entry(layerIndexOrArray, featureIndex, propertyIndex) {
                this.v = Array(2);
                if (typeof layerIndexOrArray === 'number') {
                    this.v[0] = layerIndexOrArray;
                    this.v[1] = featureIndex;
                }
                else {
                    this.v = layerIndexOrArray;
                }
            }
            Object.defineProperty(Entry.prototype, "layerIndex", {
                get: function () { return this.v[0]; },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Entry.prototype, "featureIndex", {
                get: function () { return this.v[1]; },
                enumerable: true,
                configurable: true
            });
            return Entry;
        }());
        Services.Entry = Entry;
        var OfflineSearchResult = (function () {
            function OfflineSearchResult(title, layerTitle, groupTitle, entry, score) {
                this.title = title;
                this.layerTitle = layerTitle;
                this.groupTitle = groupTitle;
                this.entry = entry;
                this.score = score;
                this.firstInGroup = false;
            }
            OfflineSearchResult.prototype.toString = function () {
                return this.title;
            };
            Object.defineProperty(OfflineSearchResult.prototype, "fullTitle", {
                get: function () {
                    return this.groupTitle + ' >> ' + this.layerTitle + ' >> ' + this.title;
                },
                enumerable: true,
                configurable: true
            });
            return OfflineSearchResult;
        }());
        Services.OfflineSearchResult = OfflineSearchResult;
        var OfflineSearchActions = (function (_super) {
            __extends(OfflineSearchActions, _super);
            /**
             * @param  {string} projectUri: path to the project.json file
             */
            function OfflineSearchActions($http, projectUri) {
                _super.call(this);
                this.$http = $http;
                this.isReady = true;
                this.id = 'OfflineSearchActions';
                var offlineSearchResultUri = projectUri.replace('project.json', 'offline_search_result.json');
                this.loadIndex(offlineSearchResultUri);
            }
            /** Load the offline search index from a json file. */
            OfflineSearchActions.prototype.loadIndex = function (url) {
                var _this = this;
                this.$http.get(url)
                    .success(function (offlineSearchResult) {
                    _this.offlineSearchResult = offlineSearchResult;
                    var kwi = offlineSearchResult.keywordIndex;
                    var keywordIndex = {};
                    for (var key in kwi) {
                        if (!kwi.hasOwnProperty(key))
                            continue;
                        kwi[key].forEach(function (entry) {
                            if (!keywordIndex.hasOwnProperty(key))
                                keywordIndex[key] = [];
                            keywordIndex[key].push(new Entry(entry));
                        });
                    }
                    _this.offlineSearchResult.keywordIndex = keywordIndex;
                    _this.isReady = true;
                })
                    .error(function () { console.log("OfflineSearch: error with $http "); });
            };
            OfflineSearchActions.prototype.search = function (query, result) {
                var _this = this;
                var r = [];
                var searchResults = this.getHits(query.query, 15);
                searchResults.sort(function (a, b) { return b.score - a.score; }).forEach(function (sr) {
                    r.push({
                        title: sr.title,
                        description: sr.layerTitle + " (" + sr.groupTitle + ")",
                        score: sr.score,
                        icon: 'bower_components/csweb/dist-bower/images/large-marker.png',
                        service: _this.id,
                        click: function () { return _this.onSelect(sr); }
                    });
                });
                result(null, r);
            };
            /**
             * Get the features based on the entered text.
             */
            OfflineSearchActions.prototype.getHits = function (text, resultCount) {
                if (resultCount === void 0) { resultCount = 15; }
                if (!this.isReady || text === null || text.length < 1)
                    return [];
                var searchWords = text.toLowerCase().split(' ');
                // test if last word in text might be a (part of) a stopword, if so remove it
                // var lastSearchTerm = searchWords[searchWords.length - 1];
                // var possibleStopWords = this.offlineSearchResult.options.stopWords.filter(stopword => stopword.indexOf(lastSearchTerm) > -1);
                // if (possibleStopWords.length > 0) {
                //   searchWords.splice(searchWords.length - 1, 1);
                // }
                // remove all exact stopwords
                // this.offlineSearchResult.options.stopWords.forEach(stopWord => {
                //   while (searchWords.indexOf(stopWord) > -1) {
                //     searchWords.splice(searchWords.indexOf(stopWord), 1);
                //   }
                // });
                var totResults;
                for (var j in searchWords) {
                    var result = this.getKeywordHits(searchWords[j]);
                    totResults = !totResults
                        ? result
                        : this.mergeResults(totResults, result);
                }
                var searchResults = [];
                var layers = this.offlineSearchResult.layers;
                var count = resultCount;
                var resultIndex = 0;
                while (count > 0 && resultIndex < totResults.length) {
                    var r = totResults[resultIndex++];
                    var subCount = Math.min(count, r.entries.length);
                    for (var i = 0; i < subCount; i++) {
                        var entry = r.entries[i];
                        var layer = layers[entry.layerIndex];
                        count--;
                        searchResults.push(new OfflineSearchResult(layer.featureNames[entry.featureIndex], layer.title, layer.groupTitle, entry, r.score));
                    }
                }
                // Group search results by groupTitle | layerTitle
                var groups = {};
                searchResults.forEach(function (sr) {
                    var group = sr.groupTitle + ' >> ' + sr.layerTitle;
                    if (!groups.hasOwnProperty(group))
                        groups[group] = [];
                    groups[group].push(sr);
                });
                searchResults = [];
                for (var key in groups) {
                    if (!groups.hasOwnProperty(key))
                        continue;
                    var firstInGroup = true;
                    groups[key].forEach(function (sr) {
                        sr.firstInGroup = firstInGroup;
                        searchResults.push(sr);
                        firstInGroup = false;
                    });
                }
                return searchResults;
            };
            /**
             * Merge the resuls of two keyword lookups by checking whether different entries refer
             * to the same layer and feature.
             * @result1 {ILookupResult[]}
             * @result2 {ILookupResult[]}
             */
            OfflineSearchActions.prototype.mergeResults = function (result1, result2) {
                var r = [];
                result1.forEach(function (r1) {
                    result2.forEach(function (r2) {
                        r1.entries.forEach(function (entry1) {
                            r2.entries.forEach(function (entry2) {
                                if (entry1.layerIndex === entry2.layerIndex && entry1.featureIndex === entry2.featureIndex)
                                    r.push({ score: r1.score * r2.score, key: r1.key + ' ' + r2.key, entries: [entry1] });
                            });
                        });
                    });
                });
                r = r.sort(function (a, b) { return b.score - a.score; });
                return r;
            };
            /**
             * Do a fuzzy keyword comparison between the entered text and the list of keywords,
             * and return a subset.
             * @text: {string}
             */
            OfflineSearchActions.prototype.getKeywordHits = function (text) {
                var results = [];
                var keywordIndex = this.offlineSearchResult.keywordIndex;
                var keywords = Object.getOwnPropertyNames(keywordIndex);
                keywords.forEach(function (key) {
                    var score = key.score(text, null);
                    if (score < 0.5)
                        return;
                    results.push({ score: score, key: key, entries: keywordIndex[key] });
                });
                results = results.sort(function (a, b) { return b.score - a.score; });
                return results;
            };
            OfflineSearchActions.prototype.init = function (layerService) {
                _super.prototype.init.call(this, layerService);
            };
            OfflineSearchActions.prototype.onSelect = function (selectedItem) {
                var _this = this;
                var layerIndex = selectedItem.entry.layerIndex;
                var layer = this.offlineSearchResult.layers[layerIndex];
                var projectLayer = this.layerService.findLayer(layer.id);
                if (!projectLayer)
                    return;
                if (projectLayer.enabled) {
                    this.selectFeatureById(layer.id, selectedItem.entry.featureIndex);
                    return;
                }
                else {
                    var handle = this.layerService.$messageBusService.subscribe('layer', function (title, layer) {
                        if (title !== 'activated' || projectLayer.url !== layer.url)
                            return;
                        _this.selectFeatureById(layer.id, selectedItem.entry.featureIndex);
                        _this.layerService.$messageBusService.unsubscribe(handle);
                    });
                    this.layerService.addLayer(projectLayer);
                }
                var group = $('#layergroup_' + projectLayer.groupId);
                group.collapse('show');
            };
            OfflineSearchActions.prototype.selectFeatureById = function (layerId, featureIndex) {
                var feature = this.layerService.findFeatureByIndex(layerId, featureIndex);
                if (feature == null)
                    return;
                this.layerService.$mapService.zoomTo(feature);
                // Force-select feature, otherwise we might deselect the feature immediately after it was selected.
                this.layerService.selectFeature(feature, false, true);
            };
            OfflineSearchActions.prototype.selectFeature = function (feature) {
            };
            return OfflineSearchActions;
        }(Services.BasicActionService));
        Services.OfflineSearchActions = OfflineSearchActions;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=OfflineSearchAction.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var OnlineSearchActions = (function (_super) {
            __extends(OnlineSearchActions, _super);
            /**
             * @param  {string} searchUrl: route to the search api
             */
            function OnlineSearchActions($http, searchUrl) {
                _super.call(this);
                this.$http = $http;
                this.isReady = true;
                this.id = 'OnlineSearchActions';
                this.searchUrl = searchUrl;
            }
            OnlineSearchActions.prototype.search = function (query, result) {
                var _this = this;
                var r = [];
                this.getHits(query.query, 10, function (searchResults) {
                    searchResults.forEach(function (sr) {
                        r.push({
                            title: sr.title,
                            description: sr.description,
                            icon: 'bower_components/csweb/dist-bower/images/large-marker.png',
                            service: _this.id,
                            location: JSON.parse(sr.location),
                            score: (sr.description == 'Gemeente') ? 0.99 : 0.98,
                            click: function () { return _this.onSelect(sr); }
                        });
                    });
                    result(null, r);
                });
            };
            /**
             * Get the features based on the entered text.
             */
            OnlineSearchActions.prototype.getHits = function (text, resultCount, cb) {
                if (resultCount === void 0) { resultCount = 10; }
                if (!this.isReady || text === null || text.length < 2) {
                    cb([]);
                    return;
                }
                var searchWords = text.toLowerCase().split(' ');
                var sqlSearch = searchWords.join(' & ');
                var searchObject = { query: sqlSearch, nrItems: resultCount };
                var searchResults = [];
                $.ajax({
                    type: 'POST',
                    url: this.searchUrl,
                    data: JSON.stringify(searchObject),
                    contentType: 'application/json',
                    dataType: 'json',
                    statusCode: {
                        200: function (data) {
                            console.log('Received online search result');
                            if (data.hasOwnProperty('result')) {
                                searchResults = data.result;
                            }
                            cb(searchResults);
                        },
                        404: function (data) {
                            console.log('Could not get online search result');
                            cb(searchResults);
                        }
                    },
                    error: function () {
                        console.log('Error getting online search results');
                        cb(searchResults);
                    }
                });
            };
            OnlineSearchActions.prototype.init = function (layerService) {
                _super.prototype.init.call(this, layerService);
            };
            OnlineSearchActions.prototype.onSelect = function (selectedItem) {
                var geoLoc;
                if (typeof selectedItem.location === 'string') {
                    try {
                        geoLoc = JSON.parse(selectedItem.location);
                    }
                    catch (error) {
                        console.log(error);
                    }
                }
                if (geoLoc && geoLoc.hasOwnProperty('coordinates') && geoLoc.hasOwnProperty('type')) {
                    switch (geoLoc.type) {
                        case 'Point':
                            this.layerService.$mapService.zoomToLocation(new L.LatLng(geoLoc.coordinates[1], geoLoc.coordinates[0]), 18);
                            break;
                        case 'MultiPolygon':
                        case 'Polygon':
                        default:
                            this.layerService.map.getMap().fitBounds(L.geoJson(geoLoc).getBounds());
                            // this.layerService.map.getMap().setZoom(14);
                            break;
                    }
                }
            };
            OnlineSearchActions.prototype.selectFeatureById = function (layerId, featureIndex) {
            };
            OnlineSearchActions.prototype.selectFeature = function (feature) {
            };
            return OnlineSearchActions;
        }(Services.BasicActionService));
        Services.OnlineSearchActions = OnlineSearchActions;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=OnlineSearchAction.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var OpenCageDataSearchAction = (function (_super) {
            __extends(OpenCageDataSearchAction, _super);
            /**
             * @param  {string} apiKey: route to the search api (optional, followed by a |), and the Bing maps key (required)
             */
            function OpenCageDataSearchAction($http, apiKey, searchUrl, data) {
                var _this = this;
                if (searchUrl === void 0) { searchUrl = 'https://api.opencagedata.com/geocode/v1/geojson'; }
                _super.call(this);
                this.$http = $http;
                this.apiKey = apiKey;
                this.searchUrl = searchUrl;
                this.data = data;
                this.isReady = true;
                this.id = 'OpenCageDataSearchAction';
                this.searchCache = {};
                this.queryUrl = this.searchUrl
                    + ("?pretty=1&no_dedupe=1&limit=10&jsonp=JSON_CALLBACK&key=" + this.apiKey)
                    + (this.data.bounds ? "&bounds=" + this.data.bounds : '')
                    + (this.data.culture ? "&countrycode=" + this.data.culture : '&nl')
                    + (this.data.language ? "&language=" + this.data.language : '&nl-NL');
                this.debouncedFn = _.debounce(function (query, result) { return _this.ocdRestRequest(query, result); }, 2500);
                this.messageBus = data.messageBus;
                this.messageBus.subscribe('geocoding', function (action, point) {
                    if (action.toLowerCase() !== 'reverselookup')
                        return;
                    _this.reverseGeocodeLookup(point);
                });
            }
            OpenCageDataSearchAction.prototype.init = function (layerService) {
                _super.prototype.init.call(this, layerService);
            };
            /** Perform a reverse geocode query for the current point and publish the results. */
            OpenCageDataSearchAction.prototype.reverseGeocodeLookup = function (point) {
                var _this = this;
                var geocodeRequest = this.queryUrl + "&q=" + point.lat + "," + point.lng;
                this.$http.jsonp(geocodeRequest)
                    .success(function (r) {
                    if (!r.results || r.results.length === 0)
                        return;
                    _this.messageBus.publish('geocoding', 'reverseLookupResult', r.results[0]);
                })
                    .error(function (data, status, error, thing) {
                    console.log(error);
                });
            };
            OpenCageDataSearchAction.prototype.search = function (query, result) {
                if (query.query.length < 4)
                    return;
                this.debouncedFn(query, result);
            };
            /** Create the geocode request uri and call it using JSONP. */
            OpenCageDataSearchAction.prototype.ocdRestRequest = function (query, handler) {
                var _this = this;
                if (this.searchCache.hasOwnProperty(query.query)) {
                    this.geocodeCallback(this.searchCache[query.query], handler, query.query);
                    return;
                }
                var geocodeRequest = this.queryUrl + "&q=" + encodeURIComponent(query.query);
                this.callRestService(geocodeRequest, function (result, handler, query) { return _this.geocodeCallback(result, handler, query); }, handler, query.query);
            };
            /** JSONP callback wrapper */
            OpenCageDataSearchAction.prototype.callRestService = function (request, callback, handler, query) {
                this.$http.jsonp(request)
                    .success(function (r) {
                    callback(r, handler, query);
                })
                    .error(function (data, status, error, thing) {
                    alert(error);
                });
            };
            OpenCageDataSearchAction.prototype.geocodeCallback = function (result, handler, query) {
                var _this = this;
                console.log('Open cache location search result:');
                console.log(JSON.stringify(result, null, 2));
                this.searchCache[query] = result;
                var searchResults = [];
                result.results.forEach(function (f) {
                    searchResults.push({
                        title: f.formatted,
                        type: f.annotations ? f.annotations.DMS.lat + ", " + f.annotations.DMS.lng : '',
                        service: _this.id,
                        description: f.annotations && f.annotations.what3words ? f.annotations.what3words.words : '',
                        score: f.confidence / 10,
                        icon: 'bower_components/csweb/dist-bower/images/large-marker.png',
                        click: function () { return _this.onSelect(f); },
                        location: {
                            type: 'Point',
                            coordinates: [f.geometry.lng, f.geometry.lat]
                        }
                    });
                });
                handler(null, searchResults);
            };
            OpenCageDataSearchAction.prototype.swapLatLonInPoint = function (location) {
                return {
                    type: location.type,
                    coordinates: [location.coordinates[1], location.coordinates[0]]
                };
            };
            OpenCageDataSearchAction.prototype.onSelect = function (feature) {
                if (feature.bounds) {
                    var bounds = new L.LatLngBounds(feature.bounds.southwest, feature.bounds.northeast);
                    this.layerService.map.getMap().fitBounds(bounds);
                }
                else {
                    this.layerService.$mapService.zoomToLocation(new L.LatLng((feature.geometry.lat), (feature.geometry.lng)), 18);
                }
            };
            return OpenCageDataSearchAction;
        }(Services.BasicActionService));
        Services.OpenCageDataSearchAction = OpenCageDataSearchAction;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=OpenCageDataSearchAction.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var DatabaseSource = (function () {
            function DatabaseSource(service) {
                this.service = service;
                this.title = 'database';
                this.requiresLayer = false;
            }
            DatabaseSource.prototype.refreshLayer = function (layer) {
                var _this = this;
                if (layer.isLoading) {
                    var handle = this.service.$messageBusService.subscribe('layer', function (a, l) {
                        if (a === 'activated' && l.id === layer.id) {
                            // this.service.removeLayer(layer);
                            _this.service.addLayer(layer);
                            _this.service.$messageBusService.unsubscribe(handle);
                        }
                    });
                    return;
                }
                if (!layer.enabled) {
                    // this.service.removeLayer(layer);
                    // this.service.addLayer(layer);
                    this.baseAddLayer(layer, function () { }, false);
                }
                else {
                    this.service.$messageBusService.publish('layer', 'loading', layer);
                    this.baseAddLayer(layer, function () { }, true);
                }
            };
            DatabaseSource.prototype.addLayer = function (layer, callback) {
                this.baseAddLayer(layer, callback);
            };
            /** zoom to boundaries of layer */
            DatabaseSource.prototype.fitMap = function (layer) {
                var b = csComp.Helpers.GeoExtensions.getBoundingBox(layer.data);
                this.service.$messageBusService.publish('map', 'setextent', b);
            };
            DatabaseSource.prototype.layerMenuOptions = function (layer) {
                var _this = this;
                return [
                    ['Fit map', (function ($itemScope) { return _this.fitMap(layer); })],
                    null,
                    ['Refresh', (function ($itemScope) { return _this.refreshLayer(layer); })]
                ];
            };
            DatabaseSource.prototype.baseAddLayer = function (layer, callback, isRefresh) {
                var _this = this;
                if (isRefresh === void 0) { isRefresh = false; }
                this.layer = layer;
                async.series([
                    function (cb) {
                        layer.renderType = 'geojson';
                        layer.isLoading = true;
                        var minZoom;
                        if (layer.dataSourceParameters && layer.dataSourceParameters.hasOwnProperty('minZoom')) {
                            minZoom = layer.dataSourceParameters['minZoom'];
                        }
                        else {
                            minZoom = 15;
                        }
                        var corners;
                        if (_this.service.$mapService.map.getZoom() < minZoom) {
                            _this.service.$messageBusService.notifyWithTranslation('ZOOM_LEVEL_LOW', 'ZOOM_IN_FOR_CONTOURS', csComp.Services.NotifyLocation.TopRight, csComp.Services.NotifyType.Info, 1500);
                            // initialize empty layer and return
                            _this.initLayer(layer, callback);
                            return;
                        }
                        else {
                            // When the zoomlevel is valid:
                            corners = _this.service.$mapService.map.getBounds();
                            var coords = [[
                                    [corners.getSouthWest().lng, corners.getSouthWest().lat],
                                    [corners.getNorthWest().lng, corners.getNorthWest().lat],
                                    [corners.getNorthEast().lng, corners.getNorthEast().lat],
                                    [corners.getSouthEast().lng, corners.getSouthEast().lat],
                                    [corners.getSouthWest().lng, corners.getSouthWest().lat]]];
                            var bounds = JSON.stringify({ type: 'Polygon', coordinates: coords, crs: { type: 'name', properties: { 'name': 'EPSG:4326' } } });
                            // get data from BAG
                            var bagRequestData = {
                                bounds: bounds,
                                layer: Services.ProjectLayer.serializeableData(layer)
                            };
                            $.ajax({
                                type: 'POST',
                                url: layer.url,
                                data: JSON.stringify(bagRequestData),
                                contentType: 'application/json',
                                dataType: 'json',
                                statusCode: {
                                    200: function (data) {
                                        console.log('Received bag contours');
                                        (isRefresh) ? _this.updateLayer(data.layer, callback) : _this.initLayer(data.layer, callback);
                                    },
                                    404: function (data) {
                                        console.log('Could not get bag contours');
                                        (isRefresh) ? _this.updateLayer(data.layer, callback) : _this.initLayer(layer, callback);
                                    }
                                },
                                error: function () { return _this.service.$messageBusService.publish('layer', 'error', layer); }
                            });
                        }
                    }
                ]);
            };
            DatabaseSource.prototype.initLayer = function (layer, callback) {
                var _this = this;
                var projLayer = this.service.findLayer(layer.id);
                if (projLayer) {
                    layer.count = 0;
                    projLayer.enabled = true;
                    projLayer.data = layer.data;
                }
                var count = 0;
                if (projLayer.data && projLayer.data.features && projLayer.data.features.forEach) {
                    projLayer.data.features.forEach(function (f) {
                        count += 1;
                        _this.service.initFeature(f, projLayer, false, false);
                        // this.service.calculateFeatureStyle(f);
                        // this.service.activeMapRenderer.addFeature(f);
                    });
                }
                else {
                    projLayer.data = {};
                    projLayer.data['features'] = [];
                }
                if (projLayer.typeUrl && projLayer.defaultFeatureType) {
                    var featureTypeName = projLayer.typeUrl + '#' + projLayer.defaultFeatureType;
                    var fType = this.service.getFeatureTypeById(featureTypeName);
                    this.service.evaluateLayerExpressions(projLayer, { featureTypeName: fType });
                    if (fType._propertyTypeData && fType._propertyTypeData.length > 0) {
                        fType._propertyTypeData.forEach(function (pt) {
                            csComp.Helpers.updateSection(projLayer, pt);
                        });
                    }
                }
                projLayer.isLoading = false;
                if (this.service.$rootScope.$root.$$phase !== '$apply' && this.service.$rootScope.$root.$$phase !== '$digest') {
                    this.service.$rootScope.$apply();
                }
                console.log("Initialized " + count + " features in " + layer.id);
                callback(projLayer);
            };
            DatabaseSource.prototype.updateLayer = function (layer, callback) {
                var _this = this;
                var projLayer = this.service.findLayer(layer.id);
                if (!projLayer || !projLayer.data || !projLayer.data.features) {
                    this.initLayer(layer, callback);
                    return;
                }
                if (projLayer) {
                    projLayer.enabled = true;
                }
                // Add new features
                var count = 0;
                if (layer.data && layer.data.features && layer.data.features.forEach) {
                    layer.data.features.forEach(function (f) {
                        if (!projLayer.data.features.some(function (pf) { return pf.id === f.id; })) {
                            projLayer.data.features.push(f);
                            count += 1;
                            _this.service.initFeature(f, projLayer, false, false);
                            _this.service.evaluateFeatureExpressions(f);
                            _this.service.calculateFeatureStyle(f);
                            _this.service.activeMapRenderer.addFeature(f);
                        }
                    });
                }
                projLayer.isLoading = false;
                this.service.$messageBusService.publish('layer', 'activated', layer);
                console.log("Added " + count + " features in " + layer.id);
                if (this.service.$rootScope.$root.$$phase !== '$apply' && this.service.$rootScope.$root.$$phase !== '$digest') {
                    this.service.$rootScope.$apply();
                }
                callback(projLayer);
            };
            DatabaseSource.prototype.removeLayer = function (layer) {
                var _this = this;
                var projLayer = this.service.findLayer(layer.id);
                if (projLayer)
                    projLayer.enabled = false;
                if (projLayer.data && projLayer.data.features && projLayer.data.features.forEach) {
                    projLayer.data.features.forEach(function (f) {
                        _this.service.removeFeature(f);
                    });
                }
                if (layer.data) {
                    layer.data['features'].length = 0;
                }
                //alert('remove layer');
            };
            return DatabaseSource;
        }());
        Services.DatabaseSource = DatabaseSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=DatabaseSource.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var GeoJsonSource = (function () {
            function GeoJsonSource(service, $http) {
                this.service = service;
                this.title = 'geojson';
                this.requiresLayer = false;
                this.$http = $http;
            }
            GeoJsonSource.prototype.refreshLayer = function (layer) {
                var isEnabled = layer.enabled;
                this.service.removeLayer(layer);
                this.service.addLayer(layer);
                layer.enabled = isEnabled;
            };
            GeoJsonSource.prototype.addLayer = function (layer, callback, data) {
                if (data === void 0) { data = null; }
                this.baseAddLayer(layer, callback, data);
            };
            /** zoom to boundaries of layer */
            GeoJsonSource.prototype.fitMap = function (layer) {
                var b = csComp.Helpers.GeoExtensions.getBoundingBox(layer.data);
                this.service.$messageBusService.publish('map', 'setextent', b);
            };
            /** zoom to boundaries of layer */
            GeoJsonSource.prototype.fitTimeline = function (layer) {
                if (layer.hasSensorData && layer.timestamps && layer.timestamps.length > 0) {
                    var min = layer.timestamps[0];
                    var max = layer.timestamps[layer.timestamps.length - 1];
                    this.service.$messageBusService.publish('timeline', 'updateTimerange', { start: min, end: max });
                }
            };
            GeoJsonSource.prototype.layerMenuOptions = function (layer) {
                var _this = this;
                var result = [
                    ['Fit map', (function ($itemScope) { return _this.fitMap(layer); })]];
                if (layer.hasSensorData && layer.timestamps)
                    result.push(['Fit time', (function ($itemScope) { return _this.fitTimeline(layer); })]);
                result.push(null);
                result.push(['Refresh', (function ($itemScope) { return _this.refreshLayer(layer); })]);
                return result;
            };
            GeoJsonSource.prototype.baseAddLayer = function (layer, callback, data) {
                var _this = this;
                if (data === void 0) { data = null; }
                this.layer = layer;
                async.series([
                    function (cb) {
                        layer.renderType = 'geojson';
                        // already got data (propably from drop action)
                        if (data) {
                            layer.enabled = true;
                            _this.initLayer(data, layer);
                            cb(null, null);
                        }
                        else if (!layer.url && layer.data && layer.data.type) {
                            if (!layer.count)
                                layer.count = 0;
                            layer.enabled = true;
                            layer.isLoading = false;
                            layer.isConnected = false;
                            _this.initLayer(layer.data, layer);
                            cb(null, null);
                        }
                        else {
                            // Open a layer URL
                            layer.isLoading = true;
                            // get data
                            var u = layer.url.replace('[BBOX]', layer.BBOX);
                            // check proxy
                            if (layer.useProxy)
                                u = '/api/proxy?url=' + u;
                            _this.$http.get(u)
                                .success(function (data) {
                                layer.count = 0;
                                layer.isLoading = false;
                                layer.enabled = true;
                                _this.initLayer(data, layer);
                                if (layer.hasSensorData)
                                    _this.fitTimeline(layer);
                                cb(null, null);
                            })
                                .error(function () {
                                layer.count = 0;
                                layer.isLoading = false;
                                layer.enabled = false;
                                layer.isConnected = false;
                                _this.service.$messageBusService.notify('ERROR loading ' + layer.title, '\nwhile loading: ' + u);
                                _this.service.$messageBusService.publish('layer', 'error', layer);
                                cb(null, null);
                            });
                        }
                    },
                    // Callback
                    function () {
                        callback(layer);
                    }
                ]);
            };
            GeoJsonSource.prototype.initLayer = function (data, layer) {
                var _this = this;
                // if this is a topojson layer, convert to geojson first
                if (layer.type.toLowerCase() === 'topojson') {
                    data = csComp.Helpers.GeoExtensions.convertTopoToGeoJson(data);
                }
                if (layer.id.toLowerCase() === 'accessibility' || layer.id.toLowerCase() === 'tripplanner') {
                    layer.disableMoveSelectionToFront = true;
                    this.processAccessibilityReply(data, layer, function (processedLayer) {
                        data = layer.data;
                        layer = processedLayer;
                    });
                }
                // add featuretypes to global featuretype list
                if (data.featureTypes)
                    for (var featureTypeName in data.featureTypes) {
                        if (!data.featureTypes.hasOwnProperty(featureTypeName))
                            continue;
                        var featureType = data.featureTypes[featureTypeName];
                        // give it a unique name
                        featureTypeName = layer.url + '#' + featureTypeName;
                        this.service._featureTypes[featureTypeName] = featureType;
                    }
                if (data.timestamps)
                    layer.timestamps = data.timestamps;
                // store raw result in layer
                layer.data = data;
                if (!_.isUndefined(layer.data)) {
                    if (layer.data.geometries && !layer.data.features) {
                        layer.data.features = layer.data.geometries;
                    }
                    if (!_.isUndefined(layer.data.features)) {
                        layer.data.features.forEach(function (f) {
                            _this.service.initFeature(f, layer, false, false);
                        });
                        if (data.features.length > 0) {
                            var firstFeature = data.features[0];
                            var resource = this.service.findResourceByFeature(firstFeature);
                            csComp.Helpers.addPropertyTypes(firstFeature, firstFeature.fType, resource);
                        }
                    }
                }
                layer.isTransparent = false;
                // Subscribe to zoom events
                if (layer.minZoom || layer.maxZoom) {
                    if (!layer.minZoom)
                        layer.minZoom = 0;
                    if (!layer.maxZoom)
                        layer.maxZoom = 25;
                    layer.zoomHandle = this.service.$messageBusService.subscribe('map', function (topic, level) {
                        if (!topic || !level || topic !== 'zoom' || level < 0)
                            return;
                        if ((level < layer.minZoom || level > layer.maxZoom)) {
                            if (!layer.isTransparent) {
                                layer.isTransparent = true;
                                _this.service.updateLayerFeatures(layer);
                            }
                        }
                        else {
                            if (layer.isTransparent) {
                                layer.isTransparent = false;
                                _this.service.updateLayerFeatures(layer);
                            }
                        }
                    });
                }
                if (layer.timeAware)
                    this.service.$messageBusService.publish('timeline', 'updateFeatures');
            };
            GeoJsonSource.prototype.removeLayer = function (layer) {
                layer.isTransparent = false;
                if (layer.zoomHandle)
                    this.service.$messageBusService.unsubscribe(layer.zoomHandle);
                //Reset the default zoom when deactivating a layer with the parameter 'fitToMap' set to true.
                // if (layer.fitToMap) {
                //     if (!this.service.project.viewBounds) return;
                //     this.service.$messageBusService.publish('map', 'setextent', this.service.project.viewBounds);
                // }
            };
            GeoJsonSource.prototype.processAccessibilityReply = function (data, layer, clbk) {
                if (data.hasOwnProperty('error')) {
                    console.log('Error in opentripplanner: ' + data['error'].msg);
                    clbk(layer);
                    return;
                }
                var latlng;
                var urlParameters = csComp.Helpers.parseUrlParameters(layer.url, '?', '&', '=');
                if (urlParameters.hasOwnProperty('fromPlace')) {
                    var coords = urlParameters['fromPlace'].split('%2C');
                    if (isNaN(+coords[0]) || isNaN(+coords[1]))
                        clbk(layer);
                    latlng = new L.LatLng(+coords[0], +coords[1]);
                }
                var parsedData = data;
                if (parsedData.hasOwnProperty('features')) {
                    //Add arrival times when leaving now
                    var startTime = new Date(Date.now());
                    parsedData.features.forEach(function (f) {
                        f.properties['seconds'] = f.properties['time'];
                        f.properties['time'] = f.properties['seconds'] * 1000;
                        f.properties['arriveTime'] = (new Date(startTime.getTime() + f.properties['time'])).toISOString();
                        f.properties['latlng'] = [latlng.lat, latlng.lng];
                    });
                    if (layer.hasOwnProperty('data') && layer.data.hasOwnProperty('features')) {
                        for (var index = 0; index < layer.data.features.length; index++) {
                            var f = layer.data.features[index];
                            if (f.properties.hasOwnProperty('latlng') && f.properties['latlng'][0] === latlng.lat && f.properties['latlng'][1] === latlng.lng) {
                                layer.data.features.splice(index--, 1);
                            }
                        }
                        parsedData.features.forEach(function (f) {
                            layer.data.features.push(f);
                        });
                    }
                    else {
                        layer.count = 0;
                        layer.data = parsedData;
                    }
                }
                else {
                    var fromLoc = parsedData.plan.from;
                    var toLoc = parsedData.plan.to;
                    layer.data = {};
                    layer.data.type = 'FeatureCollection';
                    layer.data.features = [];
                    parsedData.plan.itineraries.forEach(function (it) {
                        var route = new L.Polyline([]);
                        var legs = [];
                        var transfers = -1;
                        it.legs.forEach(function (leg) {
                            var polyLeg = L.Polyline.fromEncoded(leg.legGeometry.points);
                            polyLeg.getLatLngs().forEach(function (ll) {
                                route.addLatLng(ll);
                            });
                            var legDetails = {
                                mode: leg.mode,
                                start: new Date(leg.startTime).toISOString(),
                                arrive: new Date(leg.endTime).toISOString(),
                                duration: csComp.Helpers.convertPropertyInfo({ type: 'duration' }, (+leg.duration) * 1000)
                            };
                            (leg.agencyName) ? legDetails.agency = leg.agencyName : null;
                            (leg.routeShortName) ? legDetails.route = leg.routeShortName : null;
                            (leg.routeLongName) ? legDetails.routeName = leg.routeLongName : null;
                            if (leg.mode !== 'WALK' && leg.mode !== 'BICYCLE')
                                transfers = transfers + 1;
                            legs.push(legDetails);
                        });
                        var geoRoute = route.toGeoJSON();
                        layer.data.features.push(csComp.Helpers.GeoExtensions.createLineFeature(geoRoute.geometry.coordinates, {
                            fromLoc: fromLoc.name,
                            toLoc: toLoc.name,
                            duration: (+it.duration) * 1000,
                            startTime: new Date(it.startTime).toISOString(),
                            arriveTime: new Date(it.endTime).toISOString(),
                            legs: legs,
                            transfers: (transfers >= 0) ? transfers : 0
                        }));
                    });
                }
                clbk(layer);
            };
            return GeoJsonSource;
        }());
        Services.GeoJsonSource = GeoJsonSource;
        var EditableGeoJsonSource = (function (_super) {
            __extends(EditableGeoJsonSource, _super);
            function EditableGeoJsonSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = 'editablegeojson';
                // subscribe
            }
            EditableGeoJsonSource.prototype.updateFeatureByProperty = function (key, id, value, layer) {
                var _this = this;
                if (layer === void 0) { layer = null; }
                var configSettings = {};
                if (layer.id === 'newsfeed') {
                    configSettings = { titleKey: 'Name', descriptionKey: 'news_title', dateKey: 'news_date' };
                }
                ;
                try {
                    var features = layer.data.features;
                    if (features == null)
                        return;
                    var done = false;
                    features.some(function (f) {
                        if (f.hasOwnProperty(key) && f[key] === id) {
                            f.properties = value.properties;
                            f.geometry = value.geometry;
                            _this.service.updateFeature(f);
                            done = true;
                            if (_this.service.project.eventTab) {
                                _this.service.$messageBusService.publish('eventtab', 'updated', { feature: f, config: configSettings });
                            }
                            else {
                                if (layer.showFeatureNotifications)
                                    _this.service.$messageBusService.notify(layer.title, f.properties['Name'] + ' updated');
                            }
                            //  console.log('updating feature');
                            return true;
                        }
                        else {
                            return false;
                        }
                    });
                    if (!done) {
                        // console.log('adding feature');
                        if (layer && layer.data && layer.data.features) {
                            layer.data.features.push(value);
                            this.service.initFeature(value, layer, false);
                            var m = this.service.activeMapRenderer.addFeature(value);
                            if (this.service.project.eventTab) {
                                this.service.$messageBusService.publish('eventtab', 'added', { feature: value, config: configSettings });
                            }
                            else {
                                if (layer.showFeatureNotifications)
                                    this.service.$messageBusService.notify(layer.title, value.properties['Name'] + ' added');
                            }
                        }
                        else {
                            features.push(value);
                            this.service.initFeature(value, layer);
                            var m = this.service.activeMapRenderer.addFeature(value);
                            if (this.service.project.eventTab) {
                                this.service.$messageBusService.publish('eventtab', 'added', { feature: value, config: configSettings });
                            }
                            else {
                                if (layer.showFeatureNotifications)
                                    this.service.$messageBusService.notify(layer.title, value.properties['Name'] + ' added');
                            }
                        }
                    }
                }
                catch (e) {
                    console.log('error');
                }
            };
            EditableGeoJsonSource.prototype.deleteFeatureByProperty = function (key, id, value, layer) {
                try {
                    var feature = this.service.findFeature(layer, id);
                    if (feature) {
                        if (layer.showFeatureNotifications)
                            this.service.$messageBusService.notify(layer.title, feature.properties['Name'] + ' removed');
                        this.service.removeFeature(feature, false);
                    }
                }
                catch (e) {
                    console.log('error');
                }
            };
            EditableGeoJsonSource.prototype.addLayer = function (layer, callback, data) {
                if (data === void 0) { data = null; }
                layer.isEditable = true;
                this.baseAddLayer(layer, function (layer) {
                    callback(layer);
                }, data);
            };
            EditableGeoJsonSource.prototype.removeLayer = function (layer) {
                layer.isConnected = false;
                if (layer._gui['editing'])
                    this.service.stopEditingLayer(layer);
            };
            EditableGeoJsonSource.prototype.layerMenuOptions = function (layer) {
                var _this = this;
                var result = [
                    ['Fit map', (function ($itemScope) { return _this.fitMap(layer); })]];
                if (layer.hasSensorData && layer.timestamps)
                    result.push(['Fit time', (function ($itemScope) { return _this.fitTimeline(layer); })]);
                result.push(null);
                result.push(['Refresh', (function ($itemScope) { return _this.refreshLayer(layer); })]);
                return result;
            };
            /** enable edit mode for @layer and disable it for the others */
            EditableGeoJsonSource.prototype.startEditing = function (layer) {
                this.service.project.groups.forEach(function (g) {
                    var v = false;
                    g.layers.forEach(function (l) {
                        if (l === layer) {
                            v = true;
                            l._gui['editing'] = true;
                        }
                        else {
                            delete l._gui['editing'];
                        }
                    });
                    g._gui.editing = v;
                });
                this.service.editing = true;
                this.initAvailableFeatureTypesEditing(layer);
            };
            EditableGeoJsonSource.prototype.stopEditing = function (layer) {
                this.service.stopEditingLayer(layer);
            };
            /** prepare layer for editing, add featuretypes to temp. _gui object */
            EditableGeoJsonSource.prototype.initAvailableFeatureTypesEditing = function (layer) {
                var featureTypes = {};
                layer._gui['featureTypes'] = featureTypes;
                if (!layer || !layer.typeUrl || !this.service.typesResources.hasOwnProperty(layer.typeUrl))
                    return;
                for (var ft in this.service.typesResources[layer.typeUrl].featureTypes) {
                    var t = this.service.typesResources[layer.typeUrl].featureTypes[ft];
                    if (!t.style.drawingMode)
                        t.style.drawingMode = 'Point';
                    featureTypes[ft] = this.service.typesResources[layer.typeUrl].featureTypes[ft];
                    featureTypes[ft].u = csComp.Helpers.getImageUri(ft);
                    featureTypes[ft]._guid = csComp.Helpers.getGuid();
                }
            };
            return EditableGeoJsonSource;
        }(GeoJsonSource));
        Services.EditableGeoJsonSource = EditableGeoJsonSource;
        var DynamicGeoJsonSource = (function (_super) {
            __extends(DynamicGeoJsonSource, _super);
            function DynamicGeoJsonSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
            }
            DynamicGeoJsonSource.prototype.addLayer = function (layer, callback, data) {
                if (data === void 0) { data = null; }
                layer.isDynamic = true;
                _super.prototype.addLayer.call(this, layer, callback, data);
                if (layer.enabled) {
                    this.initSubscriptions(layer);
                }
            };
            DynamicGeoJsonSource.prototype.removeLayer = function (layer) {
                _super.prototype.removeLayer.call(this, layer);
                this.service.$messageBusService.serverUnsubscribe(layer.serverHandle);
            };
            DynamicGeoJsonSource.prototype.initSubscriptions = function (layer) {
                var _this = this;
                layer.serverHandle = this.service.$messageBusService.serverSubscribe(layer.id, 'layer', function (topic, msg) {
                    console.log('action:' + msg.action);
                    switch (msg.action) {
                        case 'unsubscribed':
                            _this.service.$rootScope.$apply(function () {
                                layer.isConnected = false;
                            });
                            break;
                        case 'subscribed':
                            layer.isConnected = true;
                            //console.log('sucesfully subscribed');
                            break;
                        case 'msg':
                            var d = msg.data;
                            if (d.hasOwnProperty('message')) {
                                _this.service.$messageBusService.notify(layer.title, d.message);
                            }
                            break;
                        case 'layer':
                            if (msg.data != null) {
                                try {
                                    var lu = msg.data;
                                    switch (lu.action) {
                                        case Services.LayerUpdateAction.updateLog:
                                            // find feature
                                            var fId = lu.featureId;
                                            var logs = lu.item;
                                            var ff = layer.data.features;
                                            ff.forEach(function (f) {
                                                if (f.id === fId) {
                                                    if (!f.logs)
                                                        f.logs = {};
                                                    for (var k in logs) {
                                                        if (!f.logs.hasOwnProperty(k))
                                                            f.logs[k] = [];
                                                        logs[k].forEach(function (li) { return f.logs[k].push(li); });
                                                    }
                                                    // update logs
                                                    _this.service.$rootScope.$apply(function () {
                                                        _this.service.updateLog(f);
                                                    });
                                                    return true;
                                                }
                                                return false;
                                            });
                                            break;
                                        case Services.LayerUpdateAction.updateFeature:
                                            var f = lu.item;
                                            if (layer.id === lu.layerId) {
                                                _this.service.$rootScope.$apply(function () {
                                                    _this.updateFeatureByProperty('id', f.id, f, layer);
                                                });
                                            }
                                            break;
                                        case Services.LayerUpdateAction.addUpdateFeatureBatch:
                                            var fChanges = lu.item;
                                            if (layer.id === lu.layerId && fChanges && fChanges.length > 0) {
                                                _this.service.$rootScope.$apply(function () {
                                                    fChanges.forEach(function (fc) {
                                                        switch (fc.type) {
                                                            case Services.ChangeType.Create:
                                                            case Services.ChangeType.Update:
                                                                _this.updateFeatureByProperty('id', fc.id, fc.value, layer);
                                                                break;
                                                            case Services.ChangeType.Delete:
                                                                _this.deleteFeatureByProperty('id', fc.id, fc.value, layer);
                                                                break;
                                                        }
                                                    });
                                                });
                                            }
                                            break;
                                        case Services.LayerUpdateAction.deleteFeature:
                                            var feature = _this.service.findFeature(layer, lu.featureId);
                                            if (feature) {
                                                if (layer.showFeatureNotifications)
                                                    _this.service.$messageBusService.notify(layer.title, feature.properties['Name'] + ' removed');
                                                _this.service.removeFeature(feature, false);
                                            }
                                            // lu.featureId
                                            // lu.object.forEach((f) => {
                                            //
                                            //     //this.service.removeFeature(f);
                                            // });
                                            break;
                                    }
                                }
                                catch (e) {
                                    console.warn('Error updating feature: ' + JSON.stringify(e, null, 2));
                                }
                                _this.service.$messageBusService.publish('layer', 'updated', layer);
                            }
                            break;
                    }
                });
            };
            return DynamicGeoJsonSource;
        }(EditableGeoJsonSource));
        Services.DynamicGeoJsonSource = DynamicGeoJsonSource;
        var EsriJsonSource = (function (_super) {
            __extends(EsriJsonSource, _super);
            function EsriJsonSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = 'esrijson';
                // subscribe
            }
            EsriJsonSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                layer.renderType = 'geojson';
                // Open a layer URL
                layer.isLoading = true;
                var url = (layer.useProxy) ? '/api/proxy' : layer.url;
                this.$http({
                    url: url,
                    method: 'GET',
                    params: { url: layer.url }
                }).success(function (data) {
                    if (typeof data === 'string') {
                        data = JSON.parse(data);
                    }
                    var s = new esriJsonConverter.esriJsonConverter();
                    var geojson = s.toGeoJson(data);
                    layer.data = geojson; //csComp.Helpers.GeoExtensions.createFeatureCollection(features);
                    if (layer.data.geometries && !layer.data.features) {
                        layer.data.features = layer.data.geometries;
                    }
                    if (layer.dataSourceParameters && layer.dataSourceParameters['convertFromRD']) {
                        csComp.Helpers.GeoExtensions.convertRDFeaturesToWGS84(layer.data.features);
                    }
                    layer.data.features.forEach(function (f) {
                        _this.service.initFeature(f, layer, false, false);
                    });
                    if (layer.timeAware)
                        _this.service.$messageBusService.publish('timeline', 'updateFeatures');
                }).error(function (e) {
                    console.log('EsriJsonSource called $HTTP with errors: ' + e);
                }).finally(function () {
                    layer.isLoading = false;
                    callback(layer);
                });
            };
            return EsriJsonSource;
        }(GeoJsonSource));
        Services.EsriJsonSource = EsriJsonSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=GeoJsonSource.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        /**
         * A GRID data source is a raster or grid in which the grid cells are delimited by spaces
         * and each newline indicates a new row of data.
         */
        var GridDataSource = (function (_super) {
            __extends(GridDataSource, _super);
            function GridDataSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = "grid";
            }
            GridDataSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                this.layer = layer;
                if (typeof layer.dataSourceParameters === 'undefined') {
                    throw new Error("Undefined IGridData data property in GridDataSource.");
                }
                this.gridParams = layer.dataSourceParameters;
                // Select the appropriate converter for converting points to features:
                if (this.gridParams.useContour) {
                    this.convertDataToFeatureCollection = this.convertDataToIsoLines;
                }
                else {
                    this.convertDataToFeatureCollection = this.convertDataToPolygonGrid;
                }
                // Open a layer URL
                layer.isLoading = true;
                // get data
                $.get(layer.url, function (result, status) {
                    // https://github.com/caolan/async#seriestasks-callback
                    async.series([
                        function (cb) {
                            layer.count = 0;
                            if (typeof _this.gridParams.gridType !== 'undefined' && _this.gridParams.gridType === 'esri') {
                                _this.convertEsriHeaderToGridParams(result);
                            }
                            if (layer.renderType === 'gridlayer') {
                                layer.data = _this.convertDataToGrid(result, _this.gridParams);
                                ;
                                layer.isLoading = false;
                                cb(null, null);
                                return;
                            }
                            var data = _this.convertDataToFeatureCollection(result, _this.gridParams);
                            if (data.fc.features.length > 10000) {
                                console.warn('Grid is very big! Number of features: ' + data.fc.features.length);
                            }
                            if (data.fc.features.length === 0) {
                                _this.service.$messageBusService.notify('Warning', 'Data loaded successfully, but all points are outside the specified range.', csComp.Services.NotifyLocation.TopRight, csComp.Services.NotifyType.Error);
                                layer.isLoading = false;
                                cb(null, null);
                                return;
                            }
                            // store raw result in layer
                            layer.data = data.fc;
                            //layer.description = data.desc;
                            if (layer.data.geometries && !layer.data.features) {
                                layer.data.features = layer.data.geometries;
                            }
                            var count = 0;
                            var last = layer.data.features.length - 1;
                            layer.data.features.forEach(function (f) {
                                _this.service.initFeature(f, layer, false, false);
                            });
                            layer.isLoading = false;
                            cb(null, null);
                        },
                        function () {
                            callback(layer);
                        }
                    ]);
                }).fail(function (err) {
                    layer.isLoading = false;
                    _this.service.$messageBusService.notify('ERROR loading ' + layer.title, '\nwhile loading: ' + err.statusText);
                    _this.service.$messageBusService.publish('layer', 'error');
                    console.log("Failed loading layer " + layer.title + " due to " + JSON.stringify(err) + ".");
                });
            };
            /**
             * Convert the ESRI ASCII GRID header to grid parameters.
             *
                ESRI ASCII Raster format
                The ESRI ASCII raster format can be used to transfer information to or from other cell-based or raster systems. When an existing raster is output to an ESRI ASCII format raster, the file will begin with header information that defines the properties of the raster such as the cell size, the number of rows and columns, and the coordinates of the origin of the raster. The header information is followed by cell value information specified in space-delimited row-major order, with each row seperated by a carraige return.
                In order to convert an ASCII file to a raster, the data must be in this same format. The parameters in the header part of the file must match correctly with the structure of the data values.
                The basic structure of the ESRI ASCII raster has the header information at the beginning of the file followed by the cell value data:
                    NCOLS xxx
                    NROWS xxx
                    XLLCENTER xxx | XLLCORNER xxx
                    YLLCENTER xxx | YLLCORNER xxx
                    CELLSIZE xxx
                    NODATA_VALUE xxx
                    row 1
                    row 2
                    ...
                    row n
                *
                Row 1 of the data is at the top of the raster, row 2 is just under row 1, and so on.
                Header format
                The syntax of the header information is a keyword paired with the value of that keyword. The definitions of the kewords are:
                *
                Parameter	Description	Requirements
                NCOLS	Number of cell columns.	Integer greater than 0.
                NROWS	Number of cell rows.	Integer greater than 0.
                XLLCENTER or XLLCORNER	X coordinate of the origin (by center or lower left corner of the cell).	Match with Y coordinate type.
                YLLCENTER or YLLCORNER	Y coordinate of the origin (by center or lower left corner of the cell).	Match with X coordinate type.
                CELLSIZE	Cell size.	Greater than 0.
                NODATA_VALUE	The input values to be NoData in the output raster.	Optional. Default is -9999.
                Data format
                The data component of the ESRI ASCII raster follows the header information.
                Cell values should be delimited by spaces.
                No carriage returns are necessary at the end of each row in the raster. The number of columns in the header determines when a new row begins.
                Row 1 of the data is at the top of the raster, row 2 is just under row 1, and so on.
             */
            GridDataSource.prototype.convertEsriHeaderToGridParams = function (input) {
                var _this = this;
                var regex = /(\S*)\s*([\d-.]*)/;
                var data = this.getData(input);
                if (!data)
                    return;
                var lines = data.split('\n', 6);
                var x, y;
                var isCenter = false;
                this.gridParams.skipLines = 0;
                lines.forEach(function (line) {
                    var matches = line.match(regex);
                    if (matches.length !== 3)
                        return;
                    _this.gridParams.skipLines++;
                    var value = +matches[2];
                    switch (matches[1].toLowerCase()) {
                        case 'ncols':
                            // Number of cell columns. Integer greater than 0.
                            _this.gridParams.columns = value;
                            break;
                        case 'nrows':
                            // Number of cell rows. Integer greater than 0.
                            _this.gridParams.rows = value;
                            break;
                        case 'xllcorner':
                            x = value;
                            // X coordinate of the origin (by lower left corner of the cell).
                            break;
                        case 'yllcorner':
                            y = value;
                            // Y coordinate of the origin (by lower left corner of the cell).
                            break;
                        case 'xllcenter':
                            // X coordinate of the origin (by center corner of the cell).
                            x = value;
                            isCenter = true;
                            break;
                        case 'yllcenter':
                            // Y coordinate of the origin (by center corner of the cell).
                            y = value;
                            isCenter = true;
                            break;
                        case 'cellsize':
                            // Cell size. Greater than 0.
                            _this.gridParams.deltaLon = value;
                            _this.gridParams.deltaLat = -value;
                            break;
                        case 'nodata_value':
                            // The input values to be NoData in the output raster. Optional. Default is -9999.
                            _this.gridParams.noDataValue = value;
                            break;
                    }
                });
                if (isCenter) {
                    this.gridParams.startLon = x;
                    this.gridParams.startLat = y;
                }
                else {
                    this.gridParams.startLon = x + this.gridParams.deltaLon / 2;
                    this.gridParams.startLat = y - this.gridParams.deltaLat / 2;
                }
                /* WARNING: The below RD projection is NOT correct!!! To convert an RD grid to a WGS84 grid requires a complex
                 * translation using shearing and approximating pixels. It's better to use gdal (standalone, or with QGIS).
                 *
                 * For example, execute the following in a batch file:
                 * First, convert the input data to vrt, reprojecting from RD to wgs84, and replacing the nodata value at the same time.
                 * As gdalwarp does not support AAIGrid as output, we first convert it to VRT, and use gdal_translate to translate it to an ESRI ASCII GRID file.
                 *
                 * for %%f in (*.asc) do (
                 * 		echo Processing %%f
                 * 		"c:/Program Files/QGIS Pisa/bin/gdalwarp.exe" --config GDAL_DATA "c:/OSGeo4W64/share/gdal" -srcnodata -999.0 -dstnodata -1 -t_srs EPSG:4296 -s_srs EPSG:28992 -of VRT -r average %%f %%f_intermediate.vrt
                 * 		"c:/Program Files/QGIS Pisa/bin/gdal_translate.exe" -of AAIGrid %%f_intermediate.vrt %%f.out
                 * 		del %%f_intermediate.vrt
                 * 	)
                 */
                switch (this.gridParams.projection || 'wgs84') {
                    case 'rd':
                    case 'RD':
                        var startLoc = csComp.Helpers.GeoExtensions.convertRDToWGS84(this.gridParams.startLon, this.gridParams.startLat - (this.gridParams.rows - 1) * this.gridParams.deltaLat);
                        var endLoc = csComp.Helpers.GeoExtensions.convertRDToWGS84(this.gridParams.startLon + (this.gridParams.columns - 1) * this.gridParams.deltaLon, this.gridParams.startLat);
                        this.gridParams.deltaLon = (endLoc.longitude - startLoc.longitude) / (this.gridParams.columns - 1);
                        this.gridParams.deltaLat = (endLoc.latitude - startLoc.latitude) / (this.gridParams.rows - 1);
                        this.gridParams.startLon = startLoc.longitude;
                        this.gridParams.startLat = startLoc.latitude;
                        break;
                    case 'WGS84':
                    case 'wgs84':
                        this.gridParams.startLat -= (this.gridParams.rows - 1) * this.gridParams.deltaLat;
                        break;
                    default:
                        throw new Error('Current projection is not supported!');
                }
            };
            /** Extract the grid data from the input */
            GridDataSource.prototype.getData = function (input) {
                if (typeof input === 'string') {
                    return input;
                }
                else if (input.hasOwnProperty('data') && typeof input['data'] === 'string') {
                    return input['data'];
                }
                else {
                    console.log('GridDataSource error: could not read grid data!');
                    return '';
                }
            };
            /**
             * Convert the incoming data to a matrix grid.
             * The incoming data can be in two formats: either it is a string, representing the ASCII grid data,
             * or it is an (ILayer) object, in which case the data should be in the input.data property.
             */
            GridDataSource.prototype.convertDataToGrid = function (input, gridParams) {
                var data = this.getData(input);
                if (!data)
                    return;
                var propertyName = (typeof gridParams.propertyName !== 'undefined') ? gridParams.propertyName : 'v';
                var noDataValue = (typeof gridParams.noDataValue !== 'undefined') ? gridParams.noDataValue : -9999;
                var skipLinesAfterComment = gridParams.skipLinesAfterComment, skipSpacesFromLine = gridParams.skipSpacesFromLine, skipFirstRow = gridParams.skipFirstRow || false, skipFirstColumn = gridParams.skipFirstColumn || false;
                var separatorCharacter = gridParams.separatorCharacter || ' ', splitCellsRegex = new RegExp("[^" + separatorCharacter + "]+", "g");
                var deltaLon = gridParams.deltaLon, deltaLat = gridParams.deltaLat, lat = gridParams.startLat, lon = gridParams.startLon;
                var max = (typeof gridParams.maxThreshold !== 'undefined') ? gridParams.maxThreshold : Number.MAX_VALUE, min = (typeof gridParams.minThreshold !== 'undefined') ? gridParams.minThreshold : -Number.MAX_VALUE;
                var lines = data.split('\n'), i = 0, gridData = [];
                if (gridParams.skipLines)
                    lines.splice(0, gridParams.skipLines);
                var rowsToProcess = gridParams.rows || Number.MAX_VALUE;
                lines.forEach(function (line) {
                    if (gridParams.commentCharacter)
                        if (line.substr(0, 1) === gridParams.commentCharacter) {
                            console.log(line);
                            return;
                        }
                    if (skipLinesAfterComment && skipLinesAfterComment > 0) {
                        skipLinesAfterComment--;
                        return;
                    }
                    if (skipFirstRow) {
                        skipFirstRow = false;
                        return;
                    }
                    rowsToProcess--;
                    if (rowsToProcess < 0)
                        return gridData;
                    var cells;
                    if (skipSpacesFromLine)
                        cells = line.substr(skipSpacesFromLine).match(splitCellsRegex);
                    else
                        cells = line.match(splitCellsRegex);
                    if (skipFirstColumn && cells.length > 1)
                        cells = cells.splice(1);
                    if (!cells || (!gridParams.skipFirstColumn && cells.length < gridParams.columns))
                        return;
                    gridData[i] = [];
                    cells.forEach(function (c) { return gridData[i].push(+c); });
                    //Why is the minThreshold parameter overwritten by the smallest value in the grid???
                    //max = Math.max(max, ...gridData[i]);
                    //min = Math.min(min, ...gridData[i]);
                    i++;
                });
                gridParams.maxThreshold = max;
                gridParams.minThreshold = min;
                return gridData;
            };
            /**
             * Convert data to a set of isolines.
             */
            GridDataSource.prototype.convertDataToIsoLines = function (data, gridParams) {
                var gridData = this.convertDataToGrid(data, gridParams);
                var propertyName = gridParams.propertyName || "v";
                var longitudes = [], latitudes = [];
                var lat = gridParams.startLat, lon = gridParams.startLon, deltaLat = gridParams.deltaLat, deltaLon = gridParams.deltaLon;
                var max = gridParams.maxThreshold, min = gridParams.minThreshold;
                gridData.forEach(function (row) {
                    latitudes.push(lat);
                    lat += deltaLat;
                });
                gridData[0].forEach(function (col) {
                    longitudes.push(lon);
                    lon += deltaLon;
                    if (lon > 180)
                        lon -= 360;
                });
                var features = [];
                var conrec = new csComp.Helpers.Conrec(), nrIsoLevels, isoLevels;
                if (typeof gridParams.contourLevels === 'undefined') {
                    nrIsoLevels = 10;
                }
                else {
                    var cl = gridParams.contourLevels;
                    if (typeof cl === 'number') {
                        nrIsoLevels = cl;
                    }
                    else {
                        isoLevels = cl;
                        nrIsoLevels = cl.length;
                    }
                }
                if (typeof isoLevels === 'undefined') {
                    isoLevels = [];
                    var dl = (max - min) / nrIsoLevels;
                    for (var l = min + dl / 2; l < max; l += dl)
                        isoLevels.push(Math.round(l * 10) / 10); // round to nearest decimal.
                }
                conrec.contour(gridData, 0, gridData.length - 1, 0, gridData[0].length - 1, latitudes, longitudes, nrIsoLevels, isoLevels, gridParams.noDataValue || -9999);
                var contourList = conrec.contourList;
                contourList.forEach(function (contour) {
                    var result = {};
                    result[propertyName] = contour.level;
                    var feature = {
                        type: 'Feature',
                        geometry: {
                            type: 'Polygon'
                        },
                        properties: result
                    };
                    var ring = [];
                    feature.geometry.coordinates = [ring];
                    contour.forEach(function (p) {
                        ring.push([p.y, p.x]);
                    });
                    features.push(feature);
                });
                var desc = "# Number of features above the threshold: " + features.length + ".\r\n";
                return {
                    fc: csComp.Helpers.GeoExtensions.createFeatureCollection(features),
                    desc: desc
                };
            };
            /**
             * Convert data to a grid of square GeoJSON polygons, so each drawable point is converted to a square polygon.
             */
            GridDataSource.prototype.convertDataToPolygonGrid = function (data, gridParams) {
                var propertyName = gridParams.propertyName || "v";
                var gridData = this.convertDataToGrid(data, gridParams);
                var lat = gridParams.startLat, deltaLat = gridParams.deltaLat, deltaLon = gridParams.deltaLon, noDataValue = gridParams.noDataValue;
                var minThreshold = gridParams.minThreshold || -Number.MAX_VALUE, maxThreshold = gridParams.maxThreshold || Number.MAX_VALUE;
                var features = [];
                gridData.forEach(function (row) {
                    var lon = gridParams.startLon;
                    row.forEach(function (n) {
                        var value = +n;
                        if (value !== noDataValue && minThreshold <= value && value <= maxThreshold) {
                            var result = {};
                            result[propertyName] = value;
                            var tl = [lon, lat + deltaLat], tr = [lon + deltaLon, lat + deltaLat], bl = [lon, lat], br = [lon + deltaLon, lat];
                            var pg = csComp.Helpers.GeoExtensions.createPolygonFeature([[tl, tr, br, bl, tl]], result);
                            features.push(pg);
                        }
                        lon += deltaLon;
                        if (lon > 180)
                            lon -= 360;
                    });
                    lat += deltaLat;
                });
                //
                // var propertyName = gridParams.propertyName || "v";
                // var noDataValue = gridParams.noDataValue || -9999;
                //
                // var skipLinesAfterComment = gridParams.skipLinesAfterComment,
                //     skipSpacesFromLine = gridParams.skipSpacesFromLine,
                //     skipFirstRow = gridParams.skipFirstRow || false,
                //     skipFirstColumn = gridParams.skipFirstColumn || false;
                //
                // var separatorCharacter = gridParams.separatorCharacter || ' ',
                //     splitCellsRegex = new RegExp("[^" + separatorCharacter + "]+", "g");
                //
                // var deltaLon = gridParams.deltaLon,
                //     deltaLat = gridParams.deltaLat,
                //     lat = gridParams.startLat,
                //     lon = gridParams.startLon;
                //
                // var features: csComp.Helpers.IGeoFeature[] = [];
                //
                // var lines = data.split('\n');
                // if (gridParams.skipLines) lines.splice(0, gridParams.skipLines);
                //
                // var rowsToProcess = gridParams.rows || Number.MAX_VALUE;
                // lines.forEach((line) => {
                //     if (gridParams.commentCharacter)
                //         if (line.substr(0, 1) === gridParams.commentCharacter) {
                //             console.log(line);
                //             return;
                //         }
                //
                //     if (skipLinesAfterComment && skipLinesAfterComment > 0) {
                //         skipLinesAfterComment--;
                //         return;
                //     }
                //
                //     if (skipFirstRow) {
                //         skipFirstRow = false;
                //         return;
                //     }
                //     rowsToProcess--;
                //     if (rowsToProcess < 0) return;
                //
                //     var cells: RegExpMatchArray;
                //     if (skipSpacesFromLine)
                //         cells = line.substr(skipSpacesFromLine).match(splitCellsRegex);
                //     else
                //         cells = line.match(splitCellsRegex);
                //
                //     if (skipFirstColumn && cells.length > 1) cells = cells.splice(1);
                //
                //     if (!cells || (!gridParams.skipFirstColumn && cells.length < gridParams.columns)) return;
                //
                //     lon = gridParams.startLon;
                //     var minThreshold = gridParams.minThreshold || -Number.MAX_VALUE,
                //         maxThreshold = gridParams.maxThreshold || Number.MAX_VALUE;
                //     cells.forEach((n) => {
                //         var value = +n;
                //         if (value !== noDataValue && minThreshold <= value && value <= maxThreshold) {
                //             var result: IProperty = {};
                //             result[propertyName] = value;
                //             var tl = [lon, lat + deltaLat],
                //                 tr = [lon + deltaLon, lat + deltaLat],
                //                 bl = [lon, lat],
                //                 br = [lon + deltaLon, lat];
                //
                //             var pg = csComp.Helpers.GeoExtensions.createPolygonFeature([[tl, tr, br, bl, tl]], result);
                //             features.push(pg);
                //         }
                //         lon += deltaLon;
                //         if (lon > 180) lon -= 360;
                //     });
                //     lat += deltaLat;
                // });
                var desc = "# Number of features above the threshold: " + features.length + ".\r\n";
                return {
                    fc: csComp.Helpers.GeoExtensions.createFeatureCollection(features),
                    desc: desc
                };
            }; // convertDataToGeoJSON
            return GridDataSource;
        }(csComp.Services.GeoJsonSource));
        Services.GridDataSource = GridDataSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=GridDataSource.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var HeatmapSource = (function () {
            function HeatmapSource(service) {
                this.service = service;
                this.title = 'heatmap';
                this.requiresLayer = true;
                //service: LayerService;
                this.heatmapModel = new Heatmap.HeatmapModel('ProjectHeatmap');
            }
            //public init(service: LayerService) {
            //    this.service = service;
            //}
            HeatmapSource.prototype.refreshLayer = function (layer) {
                this.generateHeatmap(layer);
            };
            HeatmapSource.prototype.layerMenuOptions = function (layer) {
                return null;
            };
            HeatmapSource.prototype.addLayer = function (layer, callback, data) {
                var _this = this;
                if (data === void 0) { data = null; }
                async.series([
                    function (cb) {
                        layer.renderType = 'heatmap';
                        layer.isLoading = true;
                        if (layer.quickRefresh && layer.quickRefresh === true) {
                            // In case the map has not moved, the heatmap cells do not need to be calculated again, only the style of the markers need to be updated.
                            _this.heatmapModel.deserialize(layer);
                            _this.heatmapModel.id = layer.id;
                            _this.heatmapModel.updateWeights();
                            if (layer.heatmapItems) {
                                var hiWeights = {};
                                _this.heatmapModel.heatmapItems.forEach(function (hi) {
                                    hiWeights[hi.toString()] = hi.weight;
                                });
                                var weightedIntensityScale = ((_this.heatmapModel.heatmapSettings.intensityScale / 3) * (_this.heatmapModel.heatmapSettings.intensityScale / 3)); // Convert intensityscale from [1,...,5] to ~[0.1, 0.5, 1, 2, 3]
                                _this.service.project.features.forEach(function (f) {
                                    if (f.properties.hasOwnProperty('intensities') && f.properties.hasOwnProperty('contributors')) {
                                        var intensities = JSON.parse(f.properties['intensities']);
                                        var totalIntensity = 0;
                                        for (var key in intensities) {
                                            if (intensities.hasOwnProperty(key)) {
                                                totalIntensity += intensities[key] * hiWeights[key] * weightedIntensityScale;
                                            }
                                        }
                                        f.properties['totalIntensity'] = totalIntensity;
                                        _this.service.calculateFeatureStyle(f);
                                        _this.service.activeMapRenderer.updateFeature(f);
                                    }
                                });
                            }
                        }
                        else {
                            // In all other occasions, (re)calculate the complete heatmap
                            _this.generateHeatmap(layer);
                            layer.enabled = true;
                            _this.enableProjectLayer(layer);
                        }
                        layer.isLoading = false;
                        cb(null, null);
                    },
                    // Callback
                    function () {
                        callback(layer);
                    }
                ]);
            };
            HeatmapSource.prototype.removeLayer = function (layer) {
                delete (this.heatmapModel);
                this.heatmapModel = new Heatmap.HeatmapModel('ProjectHeatmap');
                layer.enabled = false;
                layer.data = JSON;
                this.enableProjectLayer(layer); // Set project layer to disabled
                //this.updateLayer(layer);
            };
            /* Enables the project layer if the 'layer' parameter has the same id as a project layer */
            HeatmapSource.prototype.enableProjectLayer = function (layer) {
                if (!layer.id)
                    return;
                this.service.project.groups.forEach(function (group) {
                    group.layers.forEach(function (l) {
                        if (l.id === layer.id) {
                            l.enabled = layer.enabled;
                            if (l.enabled === false) {
                                layer.data = JSON;
                            }
                        }
                    });
                });
            };
            HeatmapSource.prototype.getRequiredLayers = function (layer) {
                var _this = this;
                var requiredLayers = [];
                if (layer.heatmapSettings && layer.heatmapSettings.referenceList) {
                    layer.heatmapSettings.referenceList.forEach(function (ref) {
                        _this.service.project.groups.forEach(function (group) {
                            group.layers.forEach(function (l) {
                                if (l.reference === ref) {
                                    requiredLayers.push(l);
                                }
                            });
                        });
                    });
                }
                return requiredLayers;
            };
            HeatmapSource.prototype.getFeatureTypes = function (layer) {
                var featureTypes = [];
                layer.heatmapItems.forEach(function (hi) {
                    featureTypes.push(hi.featureType.name);
                });
                return featureTypes;
            };
            HeatmapSource.prototype.generateHeatmap = function (layer) {
                var _this = this;
                console.log('Generating heatmap');
                var geoLayer = L.geoJson([]);
                this.heatmapModel.deserialize(layer);
                this.heatmapModel.id = layer.id;
                var currentZoom = this.service.$mapService.getMap().getZoom();
                if (currentZoom < this.heatmapModel.heatmapSettings.minZoom || currentZoom > this.heatmapModel.heatmapSettings.maxZoom) {
                    return;
                }
                else {
                    this.heatmapModel.updateWeights();
                    this.heatmapModel.calculate(this.service, this.service.$mapService, geoLayer);
                    var time = new Date().getTime();
                    layer.data = geoLayer.toGeoJSON();
                }
                if ((layer.data) && (layer.data).features) {
                    (layer.data).features.forEach(function (f) {
                        _this.service.initFeature(f, layer, false, false);
                        _this.service.activeMapRenderer.addFeature(f);
                    });
                    // Set default style for the heatmap:
                    if ((layer.data).features[0]) {
                        var calloutProp = new FeatureProps.CallOutProperty("totalIntensity", "0", "totalIntensity", true, true, true, (layer.data).features[0], false, false);
                        var propinfo = {};
                        // Tweak the group style info to keep constant min/max color values on panning and zooming.
                        propinfo.count = (layer.data).features.length;
                        propinfo.max = 1;
                        propinfo.min = -1;
                        propinfo.userMax = propinfo.max;
                        propinfo.userMin = propinfo.min;
                        propinfo.mean = 0;
                        propinfo.varience = 0.67;
                        propinfo.sd = Math.sqrt(propinfo.varience);
                        this.service.setStyle(calloutProp, false, propinfo); // Set the style
                    }
                }
                var time2 = new Date().getTime();
                console.log('Init and style features in ' + (time2 - time).toFixed(1) + ' ms');
            };
            return HeatmapSource;
        }());
        Services.HeatmapSource = HeatmapSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=HeatmapSource.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var HierarchySource = (function () {
            function HierarchySource(service, $http) {
                this.service = service;
                this.title = "hierarchy";
                this.requiresLayer = true;
                this.$http = $http;
            }
            HierarchySource.prototype.refreshLayer = function (layer) {
                this.service.removeLayer(layer);
                this.service.addLayer(layer);
            };
            HierarchySource.prototype.addLayer = function (layer, callback, data) {
                if (data === void 0) { data = null; }
                this.baseAddLayer(layer, callback);
            };
            HierarchySource.prototype.fitMap = function (layer) {
                var b = csComp.Helpers.GeoExtensions.getBoundingBox(this.layer.data);
                this.service.$messageBusService.publish("map", "setextent", b);
            };
            HierarchySource.prototype.layerMenuOptions = function (layer) {
                var _this = this;
                return [
                    ["Fit map", (function ($itemScope) { return _this.fitMap(layer); })],
                    null,
                    ['Refresh', (function ($itemScope) { return _this.refreshLayer(layer); })]
                ];
            };
            HierarchySource.prototype.getRequiredLayers = function (layer) {
                var _this = this;
                var requiredLayers = [];
                if (layer.hierarchySettings && layer.hierarchySettings.referenceList) {
                    layer.hierarchySettings.referenceList.forEach(function (ref) {
                        _this.service.project.groups.forEach(function (group) {
                            group.layers.forEach(function (l) {
                                if (l.reference == ref) {
                                    requiredLayers.push(l);
                                }
                            });
                        });
                    });
                }
                return requiredLayers;
            };
            HierarchySource.prototype.baseAddLayer = function (layer, callback) {
                var _this = this;
                this.layer = layer;
                async.series([
                    function (cb) {
                        layer.renderType = "geojson";
                        // Open a layer URL
                        layer.isLoading = true;
                        // get data
                        _this.$http.get(layer.url)
                            .success(function (data) {
                            layer.count = 0;
                            layer.isLoading = false;
                            // if this is a topojson layer, convert to geojson first
                            if (layer.type.toLowerCase() === 'topojson') {
                                data = csComp.Helpers.GeoExtensions.convertTopoToGeoJson(data);
                            }
                            // add featuretypes to global featuretype list
                            if (data.featureTypes)
                                for (var featureTypeName in data.featureTypes) {
                                    if (!data.featureTypes.hasOwnProperty(featureTypeName))
                                        continue;
                                    var featureType = data.featureTypes[featureTypeName];
                                    // give it a unique name
                                    featureTypeName = layer.id + '_' + featureTypeName;
                                    _this.service._featureTypes[featureTypeName] = featureType;
                                }
                            if (data.timestamps)
                                layer.timestamps = data.timestamps;
                            // store raw result in layer
                            layer.data = data;
                            if (layer.data.geometries && !layer.data.features) {
                                layer.data.features = layer.data.geometries;
                            }
                            layer.data.features.forEach(function (f) {
                                _this.service.initFeature(f, layer, false, false);
                            });
                            _this.service.$messageBusService.publish("timeline", "updateFeatures");
                            cb(null, null);
                        })
                            .error(function () {
                            layer.count = 0;
                            layer.isLoading = false;
                            _this.service.$messageBusService.notify('ERROR loading ' + layer.title, '\nwhile loading: ' + layer.url);
                            _this.service.$messageBusService.publish('layer', 'error', layer);
                            cb(null, null);
                        });
                    },
                    // Callback
                    function () {
                        callback(layer);
                    }
                ]);
            };
            HierarchySource.prototype.removeLayer = function (layer) {
                //alert('remove layer');
            };
            return HierarchySource;
        }());
        Services.HierarchySource = HierarchySource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=HierarchySource.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var KmlDataSource = (function (_super) {
            __extends(KmlDataSource, _super);
            function KmlDataSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = "kml";
            }
            KmlDataSource.prototype.get = function (x, y) { return x.getElementsByTagName(y); };
            KmlDataSource.prototype.attr = function (x, y) { return x.getAttribute(y); };
            KmlDataSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                this.layer = layer;
                layer.renderType = "geojson";
                // Open a layer URL
                layer.isLoading = true;
                // get data
                $.ajax(layer.url)
                    .done(function (xml) {
                    layer.count = 0;
                    layer.isLoading = false;
                    switch (layer.type.toLowerCase()) {
                        case "kml":
                            _this.convertKmlToGeoJSON(layer, xml);
                            break;
                        case "gpx":
                            _this.convertGpxToGeoJSON(layer, xml);
                            break;
                    }
                    callback(layer);
                })
                    .fail(function (error) {
                    layer.isLoading = false;
                    _this.service.$messageBusService.notify('ERROR loading ' + layer.title, error);
                    _this.service.$messageBusService.publish('layer', 'error', layer);
                    callback(layer);
                });
            };
            KmlDataSource.prototype.convertGpxToGeoJSON = function (layer, gpx) {
                var data = toGeoJSON.gpx(gpx);
                this.initLayer(data, layer);
            };
            KmlDataSource.prototype.convertKmlToGeoJSON = function (layer, kml) {
                var _this = this;
                // Convert kml to geojson
                var data = toGeoJSON.kml(kml);
                // Extract style information: first, get all styles
                var styleIndex = {}, styles = this.get(kml, 'Style'), styleMaps = this.get(kml, 'StyleMap');
                for (var k = 0; k < styles.length; k++) {
                    styleIndex['#' + this.attr(styles[k], 'id')] = styles[k];
                }
                // Next, get all stylemaps (and link the normal version to its style)
                for (var k = 0; k < styleMaps.length; k++) {
                    var styleMap = styleMaps[k];
                    var pairs = this.get(styleMap, 'Pair');
                    if (!pairs)
                        continue;
                    for (var i = 0; i < pairs.length; i++) {
                        var p = pairs[i];
                        var key = this.get(p, 'key');
                        if (!key || key.length === 0 || key[0].childNodes[0].nodeValue !== 'normal')
                            continue;
                        var styleNames = this.get(p, 'styleUrl');
                        if (styleNames && styleNames.length > 0) {
                            var styleMapName = '#' + this.attr(styleMap, 'id');
                            var styleName = styleNames[0].childNodes[0].nodeValue;
                            styleIndex[styleMapName] = styleIndex[styleName];
                        }
                        break;
                    }
                }
                // Create the style and add it to the service._featureTypes.
                data.features.forEach(function (f) {
                    if (!f.properties.hasOwnProperty('styleUrl'))
                        return;
                    var styleUrl = f.properties['styleUrl'], styleName = layer.typeUrl + styleUrl;
                    // Strip the # from the style name and copy it to the featureTypeId
                    f.properties['featureTypeId'] = styleUrl.substring(1);
                    // Remove the styleUrl and styleHash
                    delete f.properties['styleUrl'];
                    delete f.properties['styleHash'];
                    if (_this.service._featureTypes.hasOwnProperty(styleName))
                        return;
                    var style = styleIndex[styleUrl];
                    _this.service._featureTypes[styleName] = {
                        name: styleName,
                        showAllProperties: false,
                        style: {
                            fillColor: _this.getFillColor(style),
                            strokeColor: _this.getLineColor(style),
                            strokeWidth: _this.getLineWidth(style),
                            stroke: true,
                            iconUri: _this.getIcon(layer, style)
                        }
                    };
                    //console.log(toGeoJSON.xml2str(styleIndex[f.properties['featureTypeId']]));
                });
                this.initLayer(data, layer);
            };
            KmlDataSource.prototype.getIcon = function (layer, style) {
                try {
                    var url = style.getElementsByTagName('href')[0].childNodes[0].nodeValue;
                    return (url.match(/^http/i))
                        ? url
                        : layer.url.substr(0, layer.url.lastIndexOf('/') + 1) + url;
                }
                catch (error) {
                    return '';
                }
            };
            KmlDataSource.prototype.getLineColor = function (style) {
                try {
                    return '#' + style
                        .getElementsByTagName('LineStyle')[0]
                        .getElementsByTagName('color')[0]
                        .childNodes[0].nodeValue;
                }
                catch (error) {
                    return '#000000';
                }
            };
            KmlDataSource.prototype.getLineWidth = function (style) {
                try {
                    return +style
                        .getElementsByTagName('LineStyle')[0]
                        .getElementsByTagName('width')[0]
                        .childNodes[0].nodeValue;
                }
                catch (error) {
                    return 1;
                }
            };
            KmlDataSource.prototype.getFillColor = function (style) {
                try {
                    return '#' + style
                        .getElementsByTagName('PolyStyle')[0]
                        .getElementsByTagName('color')[0]
                        .childNodes[0].nodeValue;
                }
                catch (error) {
                    return '#ff0000';
                }
            };
            return KmlDataSource;
        }(csComp.Services.GeoJsonSource));
        Services.KmlDataSource = KmlDataSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=KmlDataSource.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var MapboxVectorTileSource = (function (_super) {
            __extends(MapboxVectorTileSource, _super);
            function MapboxVectorTileSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = 'mapboxvectortile';
                this.requiresLayer = false;
                this.tileCount = -1;
                /** Store obtained results in the cache, */
                this.cache = {};
                /** The urls that are cached (in order to keep the cache from only growing). */
                this.cachedUrls = [];
            }
            MapboxVectorTileSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                layer.renderType = 'mvtlayer';
                // Open a layer URL
                layer.isLoading = true;
                layer.data = {};
                layer.data.features = [];
                var zoom = this.service.$mapService.map.getZoom();
                var slippyTiles = csComp.Helpers.GeoExtensions.slippyMapTiles(zoom, this.service.$mapService.map.getBounds());
                this.tileCount = slippyTiles.width * slippyTiles.height;
                for (var x = slippyTiles.left; x <= slippyTiles.right; x++) {
                    for (var y = slippyTiles.top; y <= slippyTiles.bottom; y++) {
                        var url = layer.url.replace('{z}/{x}/{y}', zoom + "/" + x + "/" + y);
                        if (this.cache.hasOwnProperty(url)) {
                            this.addFeatures(layer, this.cache[url], true);
                            this.checkIfFinished(layer, callback);
                            continue;
                        }
                        this.$http.get(url)
                            .then(function (result) {
                            var data;
                            if (result.data.hasOwnProperty('objects')) {
                                if (!result.data.objects.hasOwnProperty('vectile')) {
                                    // Multiple groups are returned: set the group name as featureTypeId
                                    for (var group in result.data.objects) {
                                        result.data.objects[group].geometries.forEach(function (f) {
                                            f.properties.featureTypeId = group;
                                        });
                                    }
                                }
                                data = csComp.Helpers.GeoExtensions.convertTopoToGeoJson(result.data);
                            }
                            else {
                                data = result.data;
                            }
                            _this.addToCache(result.config.url, data);
                            _this.addFeatures(layer, data);
                            _this.checkIfFinished(layer, callback);
                        }, function (e) {
                            console.log('VectorTileSource error: ' + e);
                            _this.checkIfFinished(layer, callback);
                        });
                    }
                }
            };
            /**
             * Add a received object to the cache, and, if full, delete an old entry.
             */
            MapboxVectorTileSource.prototype.addToCache = function (url, data) {
                this.cache[url] = data;
                this.cachedUrls.push(url);
                if (this.cachedUrls.length < Services.VectorTileSource.CACHE_SIZE)
                    return;
                var oldUrl = this.cachedUrls.pop();
                delete this.cache[oldUrl];
            };
            MapboxVectorTileSource.prototype.checkIfFinished = function (layer, callback) {
                this.tileCount--;
                if (this.tileCount <= 0) {
                    layer.isLoading = false;
                    callback(layer);
                }
            };
            MapboxVectorTileSource.prototype.addFeatures = function (layer, data, fromCache) {
                if (fromCache === void 0) { fromCache = false; }
                // if (data.hasOwnProperty('features')) {
                //     var geojson = <IGeoJsonFile>data;
                //     geojson.features.forEach(f => {
                //         if (fromCache) f._isInitialized = false;
                //         layer.data.features.push(f);
                //         this.service.initFeature(f, layer, false, false);
                //     });
                // } else {
                //     var col: IGeoJsonCollection = <IGeoJsonCollection>data;
                //     for (var key in col) {
                //         if (!col.hasOwnProperty(key)) continue;
                //         col[key].features.forEach(f => {
                //             if (fromCache) f._isInitialized = false;
                //             f.properties['featureTypeId'] = key;
                //             layer.data.features.push(f);
                //             this.service.initFeature(f, layer, false, false);
                //         });
                //     }
                // }
            };
            MapboxVectorTileSource.prototype.removeLayer = function (layer) {
                var projLayer = this.service.findLayer(layer.id);
                if (projLayer)
                    projLayer.enabled = false;
                layer.data.features = {};
                //alert('remove layer');
            };
            MapboxVectorTileSource.CACHE_SIZE = 99;
            return MapboxVectorTileSource;
        }(Services.GeoJsonSource));
        Services.MapboxVectorTileSource = MapboxVectorTileSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=MapboxVectorTileSource.js.map
/* Terminator.js -- Overlay day/night region on a Leaflet map
 * Source: https://github.com/joergdietrich/Leaflet.Terminator/blob/master/L.Terminator.js
 * See also: http://joergdietrich.github.io/Leaflet.Terminator/
 http://www.lizard-tail.com/isana/lab/astro_calc/terminator.html,
 http://stackoverflow.com/questions/7100718/calculating-an-overlay-of-day-night-for-google-maps,
 https://github.com/rossengeorgiev/nite-overlay,
 http://mathematica.stackexchange.com/questions/3326/composition-how-to-make-a-day-and-night-world-map
*/
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
L.Terminator = L.Polygon.extend({
    options: {
        color: '#00',
        opacity: 0.5,
        fillColor: '#00',
        fillOpacity: 0.5,
        resolution: 2,
        showNight: true
    },
    initialize: function (options) {
        this.version = '0.1.0';
        this._R2D = 180 / Math.PI;
        this._D2R = Math.PI / 180;
        L.Util.setOptions(this, options);
        var latLng = this._compute(this.options.showNight, this.options.time || null);
        this.setLatLngs(latLng);
    },
    setTime: function (date) {
        this.options.time = date;
        var latLng = this._compute(this.options.showNight, date || null);
        this.setLatLngs(latLng);
    },
    _sunEclipticPosition: function (julianDay) {
        /* Compute the position of the Sun in ecliptic coordinates at
           julianDay.  Following
           http://en.wikipedia.org/wiki/Position_of_the_Sun */
        // Days since start of J2000.0
        var n = julianDay - 2451545.0;
        // mean longitude of the Sun
        var L = 280.460 + 0.9856474 * n;
        L %= 360;
        // mean anomaly of the Sun
        var g = 357.528 + 0.9856003 * n;
        g %= 360;
        // ecliptic longitude of Sun
        var lambda = L + 1.915 * Math.sin(g * this._D2R) +
            0.02 * Math.sin(2 * g * this._D2R);
        // distance from Sun in AU
        var R = 1.00014 - 0.01671 * Math.cos(g * this._D2R) -
            0.0014 * Math.cos(2 * g * this._D2R);
        return { "lambda": lambda, "R": R };
    },
    _eclipticObliquity: function (julianDay) {
        // Following the short term expression in
        // http://en.wikipedia.org/wiki/Axial_tilt#Obliquity_of_the_ecliptic_.28Earth.27s_axial_tilt.29
        var n = julianDay - 2451545.0;
        // Julian centuries since J2000.0
        var T = n / 36525;
        var epsilon = 23.43929111 -
            T * (46.836769 / 3600
                - T * (0.0001831 / 3600
                    + T * (0.00200340 / 3600
                        - T * (0.576e-6 / 3600
                            - T * 4.34e-8 / 3600))));
        return epsilon;
    },
    _sunEquatorialPosition: function (sunEclLng, eclObliq) {
        /* Compute the Sun's equatorial position from its ecliptic
         * position. Inputs are expected in degrees. Outputs are in
         * degrees as well. */
        var alpha = Math.atan(Math.cos(eclObliq * this._D2R)
            * Math.tan(sunEclLng * this._D2R)) * this._R2D;
        var delta = Math.asin(Math.sin(eclObliq * this._D2R)
            * Math.sin(sunEclLng * this._D2R)) * this._R2D;
        var lQuadrant = Math.floor(sunEclLng / 90) * 90;
        var raQuadrant = Math.floor(alpha / 90) * 90;
        alpha = alpha + (lQuadrant - raQuadrant);
        return { "alpha": alpha, "delta": delta };
    },
    _hourAngle: function (lng, sunPos, gst) {
        /* Compute the hour angle of the sun for a longitude on
         * Earth. Return the hour angle in degrees. */
        var lst = gst + lng / 15;
        return lst * 15 - sunPos.alpha;
    },
    _latitude: function (ha, sunPos) {
        /* For a given hour angle and sun position, compute the
         * latitude of the terminator in degrees. */
        var lat = Math.atan(-Math.cos(ha * this._D2R) /
            Math.tan(sunPos.delta * this._D2R)) * this._R2D;
        return lat;
    },
    _compute: function (showNight, time) {
        if (time == null)
            var today = new Date();
        else
            var today = new Date(time);
        var julianDay = today.getJulian();
        var gst = today.getGMST();
        var latLng = [];
        var ha, lat;
        var sunEclPos = this._sunEclipticPosition(julianDay);
        var eclObliq = this._eclipticObliquity(julianDay);
        var sunEqPos = this._sunEquatorialPosition(sunEclPos.lambda, eclObliq);
        for (var i = 0; i <= 720 * this.options.resolution; i++) {
            var lng = -360 + i / this.options.resolution;
            ha = this._hourAngle(lng, sunEqPos, gst);
            lat = this._latitude(ha, sunEqPos);
            latLng[i + 1] = [lat, lng];
        }
        if (showNight) {
            if (sunEqPos.delta < 0) {
                latLng[0] = [90, -360];
                latLng[latLng.length] = [90, 360];
            }
            else {
                latLng[0] = [-90, -360];
                latLng[latLng.length] = [-90, 360];
            }
        }
        else {
            if (sunEqPos.delta < 0) {
                latLng[0] = [-90, -360];
                latLng[latLng.length] = [-90, 360];
            }
            else {
                latLng[0] = [90, -360];
                latLng[latLng.length] = [90, 360];
            }
        }
        return latLng;
    }
});
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var NightDayDataSource = (function (_super) {
            __extends(NightDayDataSource, _super);
            function NightDayDataSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = "Day Night regions on the Earth";
            }
            NightDayDataSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                this.layer = layer;
                layer.isLoading = true;
                layer.count = 0;
                var defaultValue = 0;
                // Check if an url to a file containing the intensity value is specified. If so, set it as defaultValue.
                if (layer.url) {
                    this.$http.get(layer.url)
                        .success(function (data) {
                        defaultValue = parseFloat(data.toString());
                        _this.continueInit(defaultValue, layer, callback);
                    })
                        .error(function () {
                        console.log('Error reading day/night intensity file');
                        _this.continueInit(defaultValue, layer, callback);
                    });
                }
                else {
                    this.continueInit(defaultValue, layer, callback);
                }
            };
            NightDayDataSource.prototype.continueInit = function (defaultValue, layer, callback) {
                var _this = this;
                var showNight = true;
                var nightName = 'Night';
                var dayName = 'Day';
                if (typeof layer.dataSourceParameters !== 'undefined') {
                    var gridParams = layer.dataSourceParameters;
                    if (typeof gridParams.showNight !== 'undefined')
                        showNight = gridParams.showNight;
                    if (typeof gridParams.nightName !== 'undefined')
                        nightName = gridParams.nightName;
                    if (typeof gridParams.dayName !== 'undefined')
                        dayName = gridParams.dayName;
                    if (typeof gridParams.value !== 'undefined')
                        defaultValue = gridParams.value;
                }
                var terminator = new L.Terminator({ "showNight": showNight });
                var geojson = terminator.toGeoJSON();
                if (showNight) {
                    geojson.properties["Name"] = nightName;
                    geojson.properties["night_intensity"] = defaultValue;
                }
                else {
                    geojson.properties["Name"] = dayName;
                    geojson.properties["day_intensity"] = defaultValue;
                }
                var features = [];
                features.push({
                    type: "Feature",
                    geometry: geojson.geometry,
                    properties: geojson.properties
                });
                layer.data = csComp.Helpers.GeoExtensions.createFeatureCollection(features);
                if (layer.data.geometries && !layer.data.features) {
                    layer.data.features = layer.data.geometries;
                }
                layer.data.features.forEach(function (f) {
                    _this.service.initFeature(f, layer, false, false);
                });
                layer.isLoading = false;
                callback(layer);
            };
            return NightDayDataSource;
        }(csComp.Services.GeoJsonSource));
        Services.NightDayDataSource = NightDayDataSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=NightDayDataSource.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var RssDataSource = (function (_super) {
            __extends(RssDataSource, _super);
            function RssDataSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = "RSS datasource";
            }
            RssDataSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                this.layer = layer;
                layer.type = 'geojson';
                // Open a layer URL
                layer.isLoading = true;
                layer.count = 0;
                this.$http({
                    url: '/api/rss',
                    method: "GET",
                    params: { url: layer.url }
                }).success(function (data) {
                    layer.data = data; //csComp.Helpers.GeoExtensions.createFeatureCollection(features);
                    if (layer.data.geometries && !layer.data.features) {
                        layer.data.features = layer.data.geometries;
                    }
                    layer.data.features.forEach(function (f) {
                        _this.service.initFeature(f, layer, false, false);
                    });
                    _this.service.$messageBusService.publish("timeline", "updateFeatures");
                    layer.isLoading = false;
                    callback(layer);
                })
                    .error(function () {
                    console.log('RssDataSource called $HTTP with errors...');
                });
            };
            return RssDataSource;
        }(csComp.Services.GeoJsonSource));
        Services.RssDataSource = RssDataSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=RssDataSource.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var TileLayerSource = (function () {
            function TileLayerSource(service) {
                this.service = service;
                this.title = 'tilelayer';
                //service : LayerService;
                this.requiresLayer = false;
                this.prevDateTimes = {};
            }
            TileLayerSource.prototype.refreshLayer = function (layer) {
                //console.log('refreshing');
                if (layer.mapLayer.getLayers().length > 0) {
                    var l = layer.mapLayer.getLayers()[0];
                    //console.log('layer ID: ' + layer.id);
                    var u = layer.url;
                    if (layer.timeDependent) {
                        // convert epoch to time string parameter
                        var ft = this.service.project.timeLine.focus;
                        if (layer.timeResolution) {
                            var tr = layer.timeResolution;
                            ft = Math.floor(ft / tr) * tr;
                        }
                        ;
                        var d = new Date(0);
                        d.setUTCSeconds(ft / 1000);
                        //d.setFullYear(2011); // so the current year becomes 2011. For easier testing.
                        // this is for the Env4U project
                        var sDate = d.yyyymmdd();
                        var hrs = d.getHours();
                        var mins = d.getMinutes();
                        var secs = d.getSeconds();
                        var sDateTime = sDate + csComp.Utils.twoDigitStr(hrs) +
                            csComp.Utils.twoDigitStr(mins) + csComp.Utils.twoDigitStr(secs);
                        //console.log('DateTime: ' + sDateTime);
                        if (sDateTime === this.prevDateTimes[layer.id]) {
                            //console.log('Same time stamp. No refresh');
                            return;
                        }
                        this.prevDateTimes[layer.id] = sDateTime;
                        u += '&time=' + sDateTime;
                    }
                    else if (layer.disableCache) {
                        // check if we need to create a unique url to force a refresh
                        layer.cacheKey = new Date().getTime().toString();
                        u += '&cache=' + layer.cacheKey;
                    }
                    l.setUrl(u);
                }
            };
            TileLayerSource.prototype.layerMenuOptions = function (layer) {
                var _this = this;
                return [
                    ['Refresh', (function ($itemScope) { return _this.refreshLayer(layer); })]
                ];
            };
            TileLayerSource.prototype.addLayer = function (layer, callback, data) {
                if (data === void 0) { data = null; }
                layer.renderType = 'tilelayer';
                callback(layer);
                //this.$rootScope.$apply();
            };
            TileLayerSource.prototype.removeLayer = function (layer) {
            };
            return TileLayerSource;
        }());
        Services.TileLayerSource = TileLayerSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=TileLayerSource.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var VectorTileSource = (function (_super) {
            __extends(VectorTileSource, _super);
            function VectorTileSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = 'vectortile';
                this.requiresLayer = false;
                this.tileCount = -1;
                /** Store obtained results in the cache, */
                this.cache = {};
                /** The urls that are cached (in order to keep the cache from only growing). */
                this.cachedUrls = [];
            }
            VectorTileSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                layer.renderType = 'geojson';
                // Open a layer URL
                layer.isLoading = true;
                layer.data = {};
                layer.data.features = [];
                var zoom = this.service.$mapService.map.getZoom();
                var slippyTiles = csComp.Helpers.GeoExtensions.slippyMapTiles(zoom, this.service.$mapService.map.getBounds());
                this.tileCount = slippyTiles.width * slippyTiles.height;
                for (var x = slippyTiles.left; x <= slippyTiles.right; x++) {
                    for (var y = slippyTiles.top; y <= slippyTiles.bottom; y++) {
                        var url = layer.url.replace('{z}/{x}/{y}', zoom + "/" + x + "/" + y);
                        if (this.cache.hasOwnProperty(url)) {
                            this.addFeatures(layer, this.cache[url], true);
                            this.checkIfFinished(layer, callback);
                            continue;
                        }
                        this.$http.get(url)
                            .then(function (result) {
                            var data;
                            if (result.data.hasOwnProperty('objects')) {
                                if (!result.data.objects.hasOwnProperty('vectile')) {
                                    // Multiple groups are returned: set the group name as featureTypeId
                                    for (var group in result.data.objects) {
                                        result.data.objects[group].geometries.forEach(function (f) {
                                            f.properties.featureTypeId = group;
                                        });
                                    }
                                }
                                data = csComp.Helpers.GeoExtensions.convertTopoToGeoJson(result.data);
                            }
                            else {
                                data = result.data;
                            }
                            _this.addToCache(result.config.url, data);
                            _this.addFeatures(layer, data);
                            _this.checkIfFinished(layer, callback);
                        }, function (e) {
                            console.log('VectorTileSource error: ' + e);
                            _this.checkIfFinished(layer, callback);
                        });
                    }
                }
            };
            /**
             * Add a received object to the cache, and, if full, delete an old entry.
             */
            VectorTileSource.prototype.addToCache = function (url, data) {
                this.cache[url] = data;
                this.cachedUrls.push(url);
                if (this.cachedUrls.length < VectorTileSource.CACHE_SIZE)
                    return;
                var oldUrl = this.cachedUrls.pop();
                delete this.cache[oldUrl];
            };
            VectorTileSource.prototype.checkIfFinished = function (layer, callback) {
                this.tileCount--;
                if (this.tileCount <= 0) {
                    layer.isLoading = false;
                    callback(layer);
                }
            };
            VectorTileSource.prototype.addFeatures = function (layer, data, fromCache) {
                var _this = this;
                if (fromCache === void 0) { fromCache = false; }
                if (data.hasOwnProperty('features')) {
                    var geojson = data;
                    geojson.features.forEach(function (f) {
                        if (fromCache)
                            f._isInitialized = false;
                        layer.data.features.push(f);
                        _this.service.initFeature(f, layer, false, false);
                    });
                }
                else {
                    var col = data;
                    for (var key in col) {
                        if (!col.hasOwnProperty(key))
                            continue;
                        col[key].features.forEach(function (f) {
                            if (fromCache)
                                f._isInitialized = false;
                            f.properties['featureTypeId'] = key;
                            layer.data.features.push(f);
                            _this.service.initFeature(f, layer, false, false);
                        });
                    }
                }
            };
            VectorTileSource.prototype.removeLayer = function (layer) {
                var projLayer = this.service.findLayer(layer.id);
                if (projLayer)
                    projLayer.enabled = false;
                layer.data.features = {};
                //alert('remove layer');
            };
            VectorTileSource.CACHE_SIZE = 99;
            return VectorTileSource;
        }(Services.GeoJsonSource));
        Services.VectorTileSource = VectorTileSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=VectorTileSource.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var WmsSource = (function () {
            //service : LayerService;
            function WmsSource(service) {
                this.service = service;
                this.title = "wms";
                this.requiresLayer = false;
            }
            WmsSource.prototype.refreshLayer = function (layer) {
            };
            WmsSource.prototype.layerMenuOptions = function (layer) {
                return null;
            };
            WmsSource.prototype.addLayer = function (layer, callback, data) {
                if (data === void 0) { data = null; }
                var wms = L.tileLayer.wms(layer.url, {
                    layers: layer.wmsLayers,
                    opacity: layer.opacity / 100,
                    format: 'image/png',
                    transparent: true,
                    attribution: layer.description
                });
                layer.renderType = "wms";
                callback(layer);
                //this.$rootScope.$apply();
            };
            WmsSource.prototype.removeLayer = function (layer) {
            };
            return WmsSource;
        }());
        Services.WmsSource = WmsSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=WmsSource.js.map
/*
 Generic  Canvas Overlay for leaflet,
 Stanislav Sumbera, April , 2014

 - added userDrawFunc that is called when Canvas need to be redrawn
 - added few useful params for userDrawFunc callback
  - fixed resize map bug
  inspired & portions taken from  :   https://github.com/Leaflet/Leaflet.heat

*/
var L;
(function (L) {
    var CanvasOverlay = L.Class.extend({
        initialize: function (userDrawFunc, layer, options) {
            this._layer = layer,
                this._userDrawFunc = userDrawFunc;
            this._layerAdd = this;
            L.Util.setOptions(this, options);
        },
        call: function (layer) {
            this.onAdd(layer._mapToAdd);
        },
        fire: function (action) {
            if (action && action === 'remove') {
            }
        },
        drawing: function (userDrawFunc) {
            this._userDrawFunc = userDrawFunc;
            return this;
        },
        params: function (options) {
            L.Util.setOptions(this, options);
            return this;
        },
        canvas: function () {
            return this._canvas;
        },
        redraw: function () {
            if (!this._frame) {
                this._frame = L.Util.requestAnimFrame(this._redraw, this);
            }
            return this;
        },
        onAdd: function (map) {
            var _this = this;
            this._map = map;
            this._canvas = L.DomUtil.create('canvas', 'leaflet-overlay-layer');
            var size = this._map.getSize();
            this._canvas.width = size.x;
            this._canvas.height = size.y;
            this._context = this._canvas.getContext("2d");
            this._popup = null;
            this.onMouseMoveDelay = _.throttle(function (evt) {
                var pos = _this._getCanvasPos();
                var rgb = _this._context.getImageData(evt.x - pos.left, evt.y - pos.top, 1, 1).data;
                // only show tooltip when a colored cell is located at the mouse cursor position
                if ((rgb[0] + rgb[1] + rgb[2]) > 0) {
                    var latLng = _this._map.containerPointToLatLng(new L.Point(evt.x - pos.left, evt.y - pos.top));
                    var i = Math.floor((latLng.lat - _this.options.topLeftLat) / _this.options.deltaLat);
                    var j = Math.floor((latLng.lng - _this.options.topLeftLon) / _this.options.deltaLon);
                    var value = '';
                    if (0 <= i && i < _this.options.data.length &&
                        0 <= j && j < _this.options.data[0].length) {
                        value = String.format("{0:0.00}", _this.options.data[i][j]);
                    }
                    (_this._layer.dataSourceParameters.legendStringFormat) ? value = String.format(_this._layer.dataSourceParameters.legendStringFormat, value) : null;
                    var content = '<table><td>' + value + '</td></tr>' + '</table>';
                    if (_this._popup && _this._map._popup && _this._map._popup._isOpen) {
                        _this._popup.setLatLng(_this._map.containerPointToLatLng(new L.Point(evt.x, evt.y))).setContent(content);
                    }
                    else {
                        _this._popup = L.popup({
                            offset: new L.Point(-25, -15),
                            closeOnClick: true,
                            autoPan: false,
                            className: 'featureTooltip'
                        }).setLatLng(_this._map.containerPointToLatLng(new L.Point(evt.x, evt.y))).setContent(content).openOn(_this._map);
                    }
                }
                else {
                    _this._map.closePopup(_this._popup);
                    _this._popup = null;
                }
                //console.log('mousemoved ' + evt.x + ', ' + evt.y + ',  color: R' + rgb[0] + ' G' + rgb[1] + ' B' + rgb[2]);
            }, 500);
            map.getPanes().overlayPane.addEventListener('mousemove', this.onMouseMoveDelay);
            var animated = this._map.options.zoomAnimation && L.Browser.any3d;
            L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));
            if (!map._panes.overlayPane.firstChild) {
                map._panes.overlayPane.appendChild(this._canvas);
            }
            else {
                map._panes.overlayPane.insertBefore(this._canvas, map._panes.overlayPane.firstChild);
            }
            map.on('moveend', this._reset, this);
            map.on('resize', this._resize, this);
            if (map.options.zoomAnimation && L.Browser.any3d) {
                map.on('zoomanim', this._animateZoom, this);
            }
            this._reset();
        },
        onRemove: function (map) {
            map.getPanes().overlayPane.removeChild(this._canvas);
            map.off('moveend', this._reset, this);
            map.off('resize', this._resize, this);
            map.getPanes().overlayPane.removeEventListener('mousemove', this.onMouseMoveDelay);
            map.closePopup(this._popup);
            this._popup = null;
            if (map.options.zoomAnimation) {
                map.off('zoomanim', this._animateZoom, this);
            }
            this._canvas = null;
        },
        addTo: function (map) {
            map.addLayer(this);
            return this;
        },
        _getCanvasPos: function () {
            var obj = this._canvas;
            var top = 0;
            var left = 0;
            while (obj && obj.tagName != "BODY") {
                top += obj.offsetTop;
                left += obj.offsetLeft;
                obj = obj.offsetParent;
            }
            return {
                top: top,
                left: left
            };
        },
        _resize: function (resizeEvent) {
            this._canvas.width = resizeEvent.newSize.x;
            this._canvas.height = resizeEvent.newSize.y;
        },
        _reset: function () {
            var topLeft = this._map.containerPointToLayerPoint([0, 0]);
            L.DomUtil.setPosition(this._canvas, topLeft);
            this._redraw();
        },
        _redraw: function () {
            var size = this._map.getSize();
            var bounds = this._map.getBounds();
            var zoomScale = (size.x * 180) / (20037508.34 * (bounds.getEast() - bounds.getWest())); // resolution = 1/zoomScale
            var zoom = this._map.getZoom();
            // console.time('process');
            if (this._userDrawFunc) {
                this._userDrawFunc(this, this._layer, {
                    canvas: this._canvas,
                    bounds: bounds,
                    size: size,
                    zoomScale: zoomScale,
                    zoom: zoom,
                    options: this.options
                });
            }
            // console.timeEnd('process');
            this._frame = null;
        },
        _animateZoom: function (e) {
            var scale = this._map.getZoomScale(e.zoom), offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());
            if (L.DomUtil.getTranslateString) {
                this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';
            }
            else {
                this._canvas.style[L.DomUtil.TRANSFORM] = 'scale(' + scale + ')';
            }
        }
    });
    function canvasOverlay(userDrawFunc, layer, options) {
        return new CanvasOverlay(userDrawFunc, layer, options);
    }
    L.canvasOverlay = canvasOverlay;
    ;
})(L || (L = {}));
//# sourceMappingURL=canvasOverlay.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var GeojsonRenderer = (function () {
            function GeojsonRenderer() {
            }
            GeojsonRenderer.render = function (service, layer, mapRenderer) {
                layer.mapLayer = new L.LayerGroup();
                service.map.map.addLayer(layer.mapLayer);
                if (!layer.data || !layer.data.features)
                    return;
                layer.data.features.forEach(function (f) {
                    var marker = mapRenderer.addFeature(f);
                    if (marker)
                        layer.group.markers[f.id] = marker;
                });
            };
            GeojsonRenderer.remove = function (service, layer) {
                var g = layer.group;
                //m = layer.group.vectors;
                if (g.clustering) {
                    var m = g._cluster;
                    service.project.features.forEach(function (feature) {
                        if (feature.layerId === layer.id) {
                            try {
                                m.removeLayer(layer.group.markers[feature.id]);
                                delete layer.group.markers[feature.id];
                            }
                            catch (error) { }
                        }
                    });
                }
                else {
                    service.project.features.forEach(function (feature) {
                        if (feature.layerId !== layer.id)
                            return;
                        if (layer.group.markers.hasOwnProperty(feature.id)) {
                            delete layer.group.markers[feature.id];
                        }
                        else if (feature.geometry && feature.geometry.type === 'Overlay') {
                            service.map.map.removeLayer(feature._gui['imageOverlay']);
                        }
                    });
                    if (service.map.map && layer.mapLayer) {
                        try {
                            service.map.map.removeLayer(layer.mapLayer);
                        }
                        catch (error) { }
                    }
                }
            };
            return GeojsonRenderer;
        }());
        Services.GeojsonRenderer = GeojsonRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=geojsonRenderer.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var GridLayerRenderer = (function () {
            function GridLayerRenderer() {
            }
            GridLayerRenderer.render = function (service, layer) {
                var gridParams = layer.dataSourceParameters;
                var legend = [];
                var levels;
                if (typeof gridParams.contourLevels === 'number') {
                    levels = [];
                    var nrLevels = (gridParams.contourLevels);
                    var dl = (gridParams.maxThreshold - gridParams.minThreshold) / nrLevels;
                    for (var l = gridParams.minThreshold + dl / 2; l < gridParams.maxThreshold; l += dl)
                        levels.push(Math.round(l * 10) / 10); // round to nearest decimal.
                }
                else {
                    levels = gridParams.contourLevels;
                }
                // Create a new groupstyle. If no legend is provided, this style can be used to change the colors used to draw the grid.
                // If a legend is provided, that will be used as activelegend.
                var gs = new Services.GroupStyle(service.$translate);
                gs.id = csComp.Helpers.getGuid();
                gs.title = (gridParams.legendDescription) ? gridParams.legendDescription : layer.title;
                gs.meta = null;
                gs.visualAspect = 'fillColor';
                gs.availableAspects = ['fillColor'];
                gs.info = { min: 0, max: 0, count: 0, mean: 0, varience: 0, sd: 0 };
                gs.fixedColorRange = true;
                gs.enabled = true;
                gs.group = layer.group;
                if (!gridParams.legend) {
                    gs.property = 'gridlayer';
                    gs.canSelectColor = true;
                    gs.colors = [(gridParams.minColor) ? gridParams.minColor : '#00fbff', (gridParams.maxColor) ? gridParams.maxColor : '#0400ff'];
                    gs.activeLegend = {
                        legendKind: 'interpolated',
                        description: gs.title,
                        visualAspect: 'fillColor',
                        legendEntries: []
                    };
                }
                else {
                    gs.property = '';
                    gs.canSelectColor = false;
                    gs.colors = ['#ffffff', '#000000'];
                    gs.activeLegend = gridParams.legend;
                    gs.activeLegend.legendEntries.forEach(function (le) {
                        legend.push({ val: le.value, color: le.color });
                    });
                }
                service.saveStyle(layer.group, gs);
                var overlay = L.canvasOverlay(GridLayerRenderer.drawFunction, layer, {
                    data: layer.data,
                    noDataValue: gridParams.noDataValue,
                    topLeftLat: gridParams.startLat,
                    topLeftLon: gridParams.startLon,
                    deltaLat: gridParams.deltaLat,
                    deltaLon: gridParams.deltaLon,
                    min: gridParams.minThreshold,
                    max: gridParams.maxThreshold,
                    minColor: gs.colors[0],
                    maxColor: gs.colors[1],
                    areColorsUpdated: false,
                    levels: levels,
                    legend: legend,
                    opacity: (layer.opacity) ? (+layer.opacity) / 100 : 0.3
                });
                layer.mapLayer = new L.LayerGroup();
                service.map.map.addLayer(layer.mapLayer);
                layer.mapLayer.addLayer(overlay);
            };
            GridLayerRenderer.drawFunction = function (overlay, layer, settings) {
                var map = this._map;
                var opt = settings.options, data = opt.data;
                if (!data)
                    return;
                var row = data.length, col = data[0].length, size = settings.size, legend = opt.legend;
                // update the legend when new from- and to-colors are chosen.
                // the complete color range of the legend will be calculated using the hue value of the from and to colors.
                if (legend.length === 0 || opt.areColorsUpdated) {
                    legend = [];
                    if (opt.minColor[0] !== '#')
                        opt.minColor = ColorExt.Utils.colorNameToHex(opt.minColor);
                    if (opt.maxColor[0] !== '#')
                        opt.maxColor = ColorExt.Utils.colorNameToHex(opt.maxColor);
                    var fromHue = ColorExt.Utils.rgbToHue(opt.minColor);
                    var toHue = ColorExt.Utils.rgbToHue(opt.maxColor);
                    for (var i_1 = 0; i_1 < opt.levels.length; i_1++) {
                        var level = opt.levels[i_1];
                        legend.push({ val: level, color: ColorExt.Utils.toColor(level, opt.levels[0], opt.levels[opt.levels.length - 1], fromHue, toHue) });
                    }
                    if (layer.group.styles && layer.group.styles.length > 0) {
                        layer.group.styles[0].activeLegend = {
                            legendKind: 'interpolated',
                            description: layer.group.styles[0].title,
                            visualAspect: 'fillColor',
                            legendEntries: []
                        };
                        legend.forEach(function (i) {
                            var legEntry = { label: String.format(layer.dataSourceParameters['legendStringFormat'] || '{0:00}', i.val), value: i.val, color: i.color };
                            layer.group.styles[0].activeLegend.legendEntries.push(legEntry);
                        });
                    }
                    overlay.options.legend = opt.legend = legend;
                    opt.areColorsUpdated = false;
                }
                var min = opt.min || Number.MIN_VALUE, max = opt.max || Number.MAX_VALUE;
                var topLeft = map.latLngToContainerPoint(new L.LatLng(opt.topLeftLat, opt.topLeftLon)), botRight = map.latLngToContainerPoint(new L.LatLng(opt.topLeftLat + row * opt.deltaLat, opt.topLeftLon + col * opt.deltaLon));
                var startX = topLeft.x, startY = topLeft.y, deltaX = (botRight.x - topLeft.x) / col, botOfFirstRow = map.latLngToContainerPoint(new L.LatLng(opt.topLeftLat + opt.deltaLat, opt.topLeftLon)), deltaY = botOfFirstRow.y - topLeft.y;
                var ctx = settings.canvas.getContext('2d');
                ctx.clearRect(0, 0, size.x, size.y);
                // Check the boundaries
                if (startX > size.x || startY > size.y || botRight.x < 0 || botRight.y < 0) {
                    //console.log('Outside boundary');
                    return;
                }
                var sJ = 0, eI = row, eJ = col;
                if (startX < -deltaX) {
                    sJ = -Math.ceil(startX / deltaX);
                    startX += sJ * deltaX;
                }
                if (botRight.x > size.x) {
                    eJ -= Math.floor((botRight.x - size.x) / deltaX);
                }
                if (botRight.y > size.y && deltaY > 0) {
                    eI -= Math.floor((botRight.y - size.y) / deltaY);
                }
                var noDataValue = opt.noDataValue;
                ctx.globalAlpha = opt.opacity || 0.3;
                //console.time('process');
                var y = startY;
                var lat = opt.topLeftLat; // + sI * opt.deltaLat;
                for (var i = 0; i < eI; i++) {
                    lat += opt.deltaLat;
                    var botY = map.latLngToContainerPoint(new L.LatLng(lat, opt.topLeftLon)).y;
                    deltaY = botY - y;
                    if (y <= -deltaY || deltaY === 0) {
                        y = botY;
                        continue;
                    }
                    var x = startX;
                    for (var j = sJ; j < eJ; j++) {
                        var cell = data[i][j];
                        if (cell === noDataValue || cell < min || cell > max) {
                            x += deltaX;
                            continue;
                        }
                        var closest = legend.reduce(function (prev, curr) {
                            return (Math.abs(curr.val - cell) < Math.abs(prev.val - cell) ? curr : prev);
                        });
                        ctx.fillStyle = closest.color;
                        ctx.fillRect(x, y, deltaX, deltaY);
                        x += deltaX;
                    }
                    y = botY;
                }
                //console.timeEnd('process');
            };
            return GridLayerRenderer;
        }());
        Services.GridLayerRenderer = GridLayerRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=gridLayerRenderer.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var HeatmapRenderer = (function () {
            function HeatmapRenderer() {
            }
            HeatmapRenderer.render = function (service, layer, mapRenderer) {
                if (layer.quickRefresh && layer.quickRefresh == true)
                    return; //When only updating style of current heatmap, do not add a new layer.
                var time = new Date().getTime();
                // create leaflet layers
                layer.isLoading = true;
                if (layer.group.clustering) {
                    var markers = L.geoJson(layer.data, {
                        pointToLayer: function (feature, latlng) { return mapRenderer.createFeature(feature); },
                        onEachFeature: function (feature, lay) {
                            //We do not need to init the feature here: already done in style.
                            //this.initFeature(feature, layer);
                            layer.group.markers[feature.id] = lay;
                            lay.on({
                                mouseover: function (a) { return mapRenderer.showFeatureTooltip(a, layer.group); },
                                mouseout: function (s) { return mapRenderer.hideFeatureTooltip(s); }
                            });
                        }
                    });
                    layer.group._cluster.addLayer(markers);
                }
                else {
                    layer.mapLayer = new L.LayerGroup();
                    service.map.map.addLayer(layer.mapLayer);
                    if (layer.data && layer.data.features) {
                        var v = L.geoJson(layer.data, {
                            onEachFeature: function (feature, lay) {
                                //We do not need to init the feature here: already done in style.
                                //this.initFeature(feature, layer);
                                layer.group.markers[feature.id] = lay;
                                lay.on({
                                    mouseover: function (a) { return mapRenderer.showFeatureTooltip(a, layer.group); },
                                    mouseout: function (s) { return mapRenderer.hideFeatureTooltip(s); },
                                    mousemove: function (d) { return mapRenderer.updateFeatureTooltip(d); },
                                    click: function (e) {
                                        mapRenderer.selectFeature(feature);
                                    }
                                });
                            },
                            style: function (f, m) {
                                layer.group.markers[f.id] = m;
                                return f.effectiveStyle;
                            },
                            pointToLayer: function (feature, latlng) { return mapRenderer.createFeature(feature); }
                        });
                    }
                    else {
                        var v = L.geoJson([]);
                    }
                    service.project.features.forEach(function (f) {
                        if (f.layerId !== layer.id)
                            return;
                        var ft = service.getFeatureType(f);
                        f.properties['Name'] = f.properties[ft.style.nameLabel];
                    });
                    layer.mapLayer.addLayer(v);
                    layer.isLoading = false;
                    var time2 = new Date().getTime();
                }
            };
            return HeatmapRenderer;
        }());
        Services.HeatmapRenderer = HeatmapRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=heatmapRenderer.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var MVTLayerRenderer = (function () {
            function MVTLayerRenderer() {
            }
            MVTLayerRenderer.render = function (service, layer) {
                var layers = layer.url.split('|');
                var layerUrl = layers[0];
                var mvtSource = new L.TileLayer.MVTSource({
                    url: "bagbuurt/{z}/{x}/{y}.json",
                    debug: true,
                    clickableLayers: [],
                    getIDForLayerFeature: function (feature) {
                        return feature.properties.id;
                    },
                    style: function (feature) {
                        var style = {};
                        var type = feature.type;
                        switch (type) {
                            case 1:
                                style.color = 'rgba(49,79,79,1)';
                                style.radius = 5;
                                style.selected = {
                                    color: 'rgba(255,255,0,0.5)',
                                    radius: 6
                                };
                                break;
                            case 2:
                                style.color = 'rgba(161,217,155,0.8)';
                                style.size = 3;
                                style.selected = {
                                    color: 'rgba(255,25,0,0.5)',
                                    size: 4
                                };
                                break;
                            case 3:
                                style.color = fillColor;
                                style.outline = {
                                    color: strokeColor,
                                    size: 1
                                };
                                style.selected = {
                                    color: 'rgba(255,140,0,0.3)',
                                    outline: {
                                        color: 'rgba(255,140,0,1)',
                                        size: 2
                                    }
                                };
                                break;
                        }
                        return style;
                    }
                });
                //Globals that we can change later.
                var fillColor = 'rgba(149,139,255,0.4)';
                var strokeColor = 'rgb(20,20,20)';
                //Add layer
                layer.mapLayer = new L.LayerGroup();
                mvtSource.setOpacity(layer.opacity / 100);
                service.map.map.addLayer(layer.mapLayer);
                layer.mapLayer.addLayer(mvtSource);
                mvtSource.on('loading', function (event) {
                    layer.isLoading = true;
                    service.$rootScope.$apply();
                    if (service.$rootScope.$$phase !== '$apply' && service.$rootScope.$$phase !== '$digest') {
                        service.$rootScope.$apply();
                    }
                });
                mvtSource.on('load', function (event) {
                    layer.isLoading = false;
                    if (service.$rootScope.$$phase !== '$apply' && service.$rootScope.$$phase !== '$digest') {
                        service.$rootScope.$apply();
                    }
                });
                layer.isLoading = true;
            };
            return MVTLayerRenderer;
        }());
        Services.MVTLayerRenderer = MVTLayerRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=mvtLayerRenderer.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var TileLayerRenderer = (function () {
            function TileLayerRenderer() {
            }
            TileLayerRenderer.render = function (service, layer) {
                var layers = layer.url.split('|');
                var layerUrl = layers[0];
                if (layer.timeDependent) {
                    // convert epoch to time string parameter
                    var ft = service.project.timeLine.focus;
                    if (layer.timeResolution) {
                        var tr = layer.timeResolution;
                        ft = Math.floor(ft / tr) * tr;
                    }
                    ;
                    var d = new Date(0);
                    d.setUTCSeconds(ft / 1000);
                    var sDate = d.yyyymmdd();
                    var hrs = d.getHours();
                    var mins = d.getMinutes();
                    var secs = d.getSeconds();
                    var sTime = csComp.Utils.twoDigitStr(hrs) +
                        csComp.Utils.twoDigitStr(mins) + csComp.Utils.twoDigitStr(secs);
                    layerUrl += '&time=' + sDate + sTime;
                }
                else if (layer.disableCache) {
                    // check if we need to create a unique url to force a refresh
                    layer.cacheKey = new Date().getTime().toString();
                    layerUrl += '&cache=' + layer.cacheKey;
                }
                var tileLayer = L.tileLayer(layerUrl, { attribution: layer.description });
                layer.mapLayer = new L.LayerGroup();
                tileLayer.setOpacity(layer.opacity / 100);
                service.map.map.addLayer(layer.mapLayer);
                if (layers.length > 1) {
                    TileLayerRenderer.addUtfGrid(service, layer, layers[1]);
                }
                layer.mapLayer.addLayer(tileLayer);
                tileLayer.on('loading', function (event) {
                    layer.isLoading = true;
                    service.$rootScope.$apply();
                    if (service.$rootScope.$$phase !== '$apply' && service.$rootScope.$$phase !== '$digest') {
                        service.$rootScope.$apply();
                    }
                });
                tileLayer.on('load', function (event) {
                    layer.isLoading = false;
                    if (service.$rootScope.$$phase !== '$apply' && service.$rootScope.$$phase !== '$digest') {
                        service.$rootScope.$apply();
                    }
                });
                layer.isLoading = true;
            };
            /**
             * Add a UTF Grid Layer to the tilelayer.
             */
            TileLayerRenderer.addUtfGrid = function (service, layer, utfGridLayerUrl) {
                var utfGrid = new L.UtfGrid(utfGridLayerUrl, {
                    resolution: 4,
                    useJsonP: false
                });
                utfGrid.on('click', function (e) {
                    //click events are fired with e.data==null if an area with no hit is clicked
                    if (e.data) {
                        var feature = new Services.Feature();
                        feature.properties = e.data;
                        feature.layer = layer;
                        feature.featureTypeName = layer.typeUrl + "#" + layer.defaultFeatureType;
                        feature.fType = service.getFeatureType(feature);
                        if (!feature.properties.hasOwnProperty('Name'))
                            csComp.Helpers.setFeatureName(feature, this.propertyTypeData);
                        service.$messageBusService.publish('feature', 'onFeatureSelect', feature);
                        console.log('Clicked: ' + JSON.stringify(e.data, null, 2));
                    }
                    else {
                        console.log('click: nothing');
                    }
                });
                // utfGrid.on('mouseover', function (e) {
                //     console.log('hover: ' + JSON.stringify(e.data, null, 2));
                // });
                service.map.map.addLayer(utfGrid);
            };
            return TileLayerRenderer;
        }());
        Services.TileLayerRenderer = TileLayerRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=tileLayerRenderer.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var VectorTileRenderer = (function () {
            function VectorTileRenderer() {
            }
            VectorTileRenderer.render = function (service, layer) {
                var gridParams = layer.dataSourceParameters;
                var overlay = L.canvasOverlay(VectorTileRenderer.drawFunction, layer, {
                    features: layer.data.features,
                    opacity: (layer.opacity) ? (+layer.opacity) / 100 : 0.3
                });
                layer.mapLayer = new L.LayerGroup();
                service.map.map.addLayer(layer.mapLayer);
                layer.mapLayer.addLayer(overlay);
            };
            VectorTileRenderer.drawFunction = function (overlay, layer, settings) {
                var map = this._map;
                var opt = settings.options;
                var features = opt.features;
                if (!features)
                    return;
                var extent = 4096;
                var pad = 0;
                var ctx = settings.canvas.getContext('2d');
                ctx.clearRect(0, 0, settings.canvas.width, settings.canvas.height);
                ctx.strokeStyle = 'red';
                ctx.fillStyle = 'rgba(255,255,0,0.1)';
                for (var i = 0; i < features.length; i++) {
                    var feature = features[i], type = feature.type;
                    ctx.beginPath();
                    for (var j = 0; j < feature.geometry.length; j++) {
                        var geom = feature.geometry[j];
                        if (type === 1) {
                            ctx.arc(geom[0], geom[1], 2, 0, 2 * Math.PI, false);
                            continue;
                        }
                        for (var k = 0; k < geom.length; k++) {
                            var p = geom[k];
                            var x = p[0] / extent * 256;
                            var y = p[1] / extent * 256;
                            if (k) {
                                ctx.lineTo(x + pad, y + pad);
                            }
                            else {
                                ctx.moveTo(x + pad, y + pad);
                            }
                        }
                    }
                    if (type === 3 || type === 1)
                        ctx.fill('evenodd');
                    ctx.stroke();
                }
            };
            return VectorTileRenderer;
        }());
        Services.VectorTileRenderer = VectorTileRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=vectorTileRenderer.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var WmsRenderer = (function () {
            function WmsRenderer() {
            }
            WmsRenderer.render = function (service, layer) {
                var wms = L.tileLayer.wms(layer.url, {
                    layers: layer.wmsLayers,
                    opacity: layer.opacity / 100,
                    format: 'image/png',
                    transparent: true,
                    attribution: layer.description,
                    tiled: true
                });
                layer.mapLayer = new L.LayerGroup();
                service.map.map.addLayer(layer.mapLayer);
                layer.mapLayer.addLayer(wms);
                wms.on('loading', function (event) {
                    layer.isLoading = true;
                    service.$rootScope.$apply();
                    if (service.$rootScope.$$phase != '$apply' && service.$rootScope.$$phase != '$digest') {
                        service.$rootScope.$apply();
                    }
                });
                wms.on('load', function (event) {
                    layer.isLoading = false;
                    if (service.$rootScope.$$phase != '$apply' && service.$rootScope.$$phase != '$digest') {
                        service.$rootScope.$apply();
                    }
                });
                layer.isLoading = true;
            };
            return WmsRenderer;
        }());
        Services.WmsRenderer = WmsRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=wmsRenderer.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var CesiumRenderer = (function () {
            function CesiumRenderer() {
                this.title = 'cesium';
                this.features = {};
            }
            CesiumRenderer.prototype.init = function (service) {
                this.service = service;
            };
            CesiumRenderer.prototype.enable = function (baseLayer) {
                var _this = this;
                csComp.Utils.loadJsCssfile('js/Cesium.js', csComp.FileType.Js, function (e) {
                    var imageProvider;
                    if (baseLayer) {
                        imageProvider = _this.createImageLayerProvider(baseLayer);
                    }
                    _this.viewer = new Cesium.Viewer('map', {
                        selectionIndicator: false,
                        infoBox: false,
                        scene3DOnly: true,
                        sceneModePicker: false,
                        fullscreenButton: false,
                        homeButton: false,
                        baseLayerPicker: false,
                        animation: false,
                        timeline: false,
                        geocoder: false,
                        navigationHelpButton: false,
                        imageryProvider: imageProvider
                    });
                    _this.setTerrainProvider(baseLayer);
                    _this.camera = _this.viewer.camera;
                    _this.scene = _this.viewer.scene;
                    _this.scene.globe.enableLighting = true;
                    // Only depth test when we are dealing with our own terrain (https://cesiumjs.org/Cesium/Build/Documentation/Globe.html)
                    _this.scene.globe.depthTestAgainstTerrain = typeof baseLayer.cesium_tileUrl !== 'undefined';
                    setTimeout(function () {
                        for (var i = 0; i < _this.service.project.features.length; ++i)
                            _this.addFeature(_this.service.project.features[i]);
                    }, 0);
                    // onclick events
                    _this.setUpMouseHandlers();
                    _this.fitBounds(_this.service.$mapService.maxBounds);
                });
            };
            CesiumRenderer.prototype.getLatLon = function (x, y) {
                return { lat: 53, lon: 5 };
            };
            CesiumRenderer.prototype.refreshLayer = function () { return; };
            CesiumRenderer.prototype.getExtent = function () {
                var r = {};
                return r;
            };
            CesiumRenderer.prototype.getZoom = function () {
                // we dont get nearby relations for now
                return 0;
            };
            CesiumRenderer.prototype.fitBounds = function (bounds) {
                var ellipsoid = Cesium.Ellipsoid.WGS84;
                if (bounds) {
                    var west = Cesium.Math.toRadians(bounds.southWest[1]);
                    var south = Cesium.Math.toRadians(bounds.southWest[0]);
                    var east = Cesium.Math.toRadians(bounds.northEast[1]);
                    var north = Cesium.Math.toRadians(bounds.northEast[0]);
                    var extent = new Cesium.Rectangle(west, south, east, north);
                    this.camera.setView({ destination: extent });
                }
            };
            CesiumRenderer.prototype.setUpMouseHandlers = function () {
                var _this = this;
                this.handler = new Cesium.ScreenSpaceEventHandler(this.scene.canvas);
                this.handler.setInputAction(function (click) {
                    var pickedObject = _this.scene.pick(click.position);
                    if (Cesium.defined(pickedObject) && pickedObject.id !== undefined && pickedObject.id.feature !== undefined) {
                        _this.service.selectFeature(pickedObject.id.feature);
                    }
                }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
                this.handler.setInputAction(function (movement) {
                    var pickedObject = _this.scene.pick(movement.endPosition);
                    if (Cesium.defined(pickedObject) && pickedObject.id !== undefined && pickedObject.id.feature !== undefined) {
                        _this.showFeatureTooltip(pickedObject.id.feature, movement.endPosition);
                    }
                    else {
                        $('.cesiumPopup').fadeOut('fast').remove();
                    }
                }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            };
            CesiumRenderer.prototype.disable = function () {
                this.handler.destroy();
                this.viewer.destroy();
            };
            CesiumRenderer.prototype.changeBaseLayer = function (layer) {
                if (!layer.cesium_url) {
                    alert('This layer is not cesium compatible');
                }
                else {
                    this.scene.imageryLayers.removeAll(); // optional
                    var mapProvider = this.createImageLayerProvider(layer);
                    this.viewer.imageryLayers.addImageryProvider(mapProvider);
                }
            };
            /** Specify the terrain provider to use, if any. */
            CesiumRenderer.prototype.setTerrainProvider = function (baseLayer) {
                if (baseLayer.cesium_tileUrl) {
                    this.viewer.terrainProvider = new Cesium.CesiumTerrainProvider({
                        url: baseLayer.cesium_tileUrl,
                        requestWaterMask: false,
                        requestVertexNormals: true
                    });
                }
            };
            /** Create the background image type provider. */
            CesiumRenderer.prototype.createImageLayerProvider = function (layer) {
                var mapProvider;
                switch (layer.cesium_maptype.toUpperCase()) {
                    case 'ARCGIS':
                        mapProvider = new Cesium.ArcGisMapServerImageryProvider({
                            url: layer.cesium_url,
                            minimumLevel: layer.minZoom,
                            maximumLevel: layer.maxNativeZoom || layer.maxZoom
                        });
                        break;
                    case 'OPENSTREETMAP':
                        mapProvider = new Cesium.createOpenStreetMapImageryProvider({
                            url: layer.cesium_url,
                            minimumLevel: layer.minZoom,
                            maximumLevel: layer.maxNativeZoom || layer.maxZoom
                        });
                        break;
                    case 'WEBMAPTILE':
                        mapProvider = new Cesium.WebMapTileServiceImageryProvider({
                            url: layer.cesium_url,
                            minimumLevel: layer.minZoom,
                            maximumLevel: layer.maxNativeZoom || layer.maxZoom
                        });
                        break;
                    case 'TILEMAP':
                        mapProvider = new Cesium.TileMapServiceImageryProvider({
                            url: layer.cesium_url,
                            minimumLevel: layer.minZoom,
                            maximumLevel: layer.maxNativeZoom || layer.maxZoom
                        });
                        break;
                    default:
                        alert('unknown maptype: ' + layer.cesium_maptype);
                        break;
                }
                return mapProvider;
            };
            CesiumRenderer.prototype.showFeatureTooltip = function (feature, endPosition) {
                if (this.popupShownFor !== undefined && feature.id === this.popupShownFor.id)
                    return;
                $('.cesiumPopup').fadeOut('fast').remove();
                this.popupShownFor = feature;
                var layer = feature.layer;
                var group = layer.group;
                // var feature = <Feature>layer.feature;
                // add title
                var title = feature.properties['Name'];
                var rowLength = (title) ? title.length : 1;
                var content = '<td colspan=\'3\'>' + title + '</td></tr>';
                // add filter values
                if (group.filters != null && group.filters.length > 0) {
                    group.filters.forEach(function (f) {
                        if (!feature.properties.hasOwnProperty(f.property))
                            return;
                        var value = feature.properties[f.property];
                        if (value) {
                            var valueLength = value.toString().length;
                            if (f.meta != null) {
                                value = csComp.Helpers.convertPropertyInfo(f.meta, value);
                                if (f.meta.type !== 'bbcode')
                                    valueLength = value.toString().length;
                            }
                            rowLength = Math.max(rowLength, valueLength + f.title.length);
                            content += '<tr><td><div class="fa fa-filter makeNarrow"></td><td>' + f.title + '</td><td>' + value + '</td></tr>';
                        }
                    });
                }
                // add style values, only in case they haven't been added already as filter
                if (group.styles != null && group.styles.length > 0) {
                    group.styles.forEach(function (s) {
                        if (group.filters != null && group.filters.filter(function (f) { return f.property === s.property; }).length === 0 && feature.properties.hasOwnProperty(s.property)) {
                            var value = feature.properties[s.property];
                            var valueLength = value.toString().length;
                            if (s.meta != null) {
                                value = csComp.Helpers.convertPropertyInfo(s.meta, value);
                                if (s.meta.type !== 'bbcode')
                                    valueLength = value.toString().length;
                            }
                            var tl = s.title ? s.title.length : 10;
                            rowLength = Math.max(rowLength, valueLength + tl);
                            content += '<tr><td><div class="fa fa-paint-brush makeNarrow"></td><td>' + s.title + '</td><td>' + value + '</td></tr>';
                        }
                    });
                }
                var widthInPixels = Math.max(Math.min(rowLength * 7 + 15, 250), 130);
                content = '<table style="width:' + widthInPixels + 'px;">' + content + '</table>';
                // cesium does not have a popup class like leaflet does, so we create our own div with absolute position
                this.popup = $('<div class="cesiumPopup featureTooltip"></div>')
                    .html(content)
                    .css({ position: 'absolute', top: endPosition.y - 30, left: endPosition.x - widthInPixels / 2 - 30, width: widthInPixels })
                    .hide().fadeIn('fast');
                $('body').append(this.popup);
            };
            CesiumRenderer.prototype.addLayer = function (layer) {
                var _this = this;
                // console.log(layer);
                var dfd = jQuery.Deferred();
                switch (layer.renderType) {
                    case 'geojson':
                        setTimeout(function () {
                            // console.time('render features');
                            layer.data.features.forEach(function (f) {
                                _this.addFeature(f);
                            });
                            // this.createLayer(layer);
                            // console.timeEnd('render features');
                            dfd.resolve();
                        }, 0);
                        break;
                    case 'wms':
                        var wms_layer = this.viewer.imageryLayers.addImageryProvider(new Cesium.WebMapServiceImageryProvider({
                            url: layer.url,
                            layers: layer.wmsLayers,
                            parameters: {
                                format: 'image/png',
                                transparent: true
                            }
                        }));
                        wms_layer.id = layer.id;
                        wms_layer.alpha = layer.opacity / 100;
                        dfd.resolve();
                        break;
                    default:
                        alert('unknown layertype: ' + layer.type);
                        dfd.resolve();
                        break;
                }
                return dfd.promise();
            };
            // /** Create the layer using geometry instances. */
            // public createLayer(layer: ProjectLayer) {
            //     var featureHeight: number,
            //         heightAboveSea: number,
            //         effStyle: IFeatureTypeStyle;
            //     /** Hold all geometry instances */
            //     var instances = [];
            //     layer.data.features.forEach((feature: IFeature) => {
            //         switch (feature.geometry.type.toUpperCase()) {
            //             case 'POLYGON':
            //                 featureHeight  = this.getFeatureHeight(feature);
            //                 heightAboveSea = this.getHeightAboveSeaLevel(feature);
            //                 effStyle       = feature.effectiveStyle;
            //                 var instance = new Cesium.GeometryInstance({
            //                     id: feature.id,
            //                     attributes: {
            //                         color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromRandom({alpha : 0.5}))
            //                         //Cesium.Color.fromCssColorString(effStyle.fillColor).withAlpha(effStyle.fillOpacity)
            //                         // "value": {
            //                         //     "0": 133,
            //                         //     "1": 31,
            //                         //     "2": 165,
            //                         //     "3": 128
            //                         // }
            //                     },
            //                     geometry : new Cesium.PolygonGeometry(heightAboveSea
            //                     ? {
            //                         polygonHierarchy: this.createPolygon(feature.geometry.coordinates).hierarchy._value,
            //                         vertexFormat: Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT,
            //                         heightAboveSea: false,
            //                         extrudedHeight: heightAboveSea + featureHeight,
            //                         height: heightAboveSea
            //                     }
            //                     : {
            //                         polygonHierarchy: this.createPolygon(feature.geometry.coordinates).hierarchy._value,
            //                         vertexFormat: Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT,
            //                         heightAboveSea: true,
            //                         extrudedHeight: featureHeight
            //                     })
            //                 });
            //                 instances.push(instance);
            //                 break;
            //             default:
            //                 console.log('Skipping feature: ' + feature);
            //                 break;
            //         }
            //     });
            //     this.viewer.scene.primitives.add(new Cesium.Primitive({
            //         geometryInstances: instances,
            //         appearance: new Cesium.PerInstanceColorAppearance()
            //         // appearance: new Cesium.EllipsoidSurfaceAppearance({
            //         //     material : Cesium.Material.fromType('Dot')
            //         // })
            //     }));
            // }
            CesiumRenderer.prototype.removeLayer = function (layer) {
                var _this = this;
                var dfd = jQuery.Deferred();
                switch (layer.type.toUpperCase()) {
                    case 'GEOJSON':
                    case 'EDITABLEGEOJSON':
                    case 'DYNAMICGEOJSON':
                    case 'TOPOJSON':
                        setTimeout(function () {
                            if (!layer.data || !layer.data.features)
                                return dfd.resolve();
                            layer.data.features.forEach(function (f) {
                                _this.removeFeature(f);
                            });
                            dfd.resolve();
                        }, 0);
                        break;
                    case 'WMS':
                        this.viewer.imageryLayers._layers.forEach(function (ilayer) {
                            if (ilayer.id === layer.id)
                                _this.viewer.imageryLayers.remove(ilayer);
                        });
                        dfd.resolve();
                        break;
                    default:
                        alert('unknown layertype: ' + layer.type);
                        dfd.resolve();
                        break;
                }
                return dfd.promise();
            };
            CesiumRenderer.prototype.updateMapFilter = function (group) {
                var _this = this;
                var dfd = jQuery.Deferred();
                setTimeout(function () {
                    _this.viewer.entities.values.forEach(function (entity) {
                        var included;
                        if (group.filterResult)
                            included = group.filterResult.filter(function (f) { return f.id === entity.feature.id; }).length > 0;
                        if (included) {
                            entity.show = true;
                        }
                        else {
                            entity.show = false;
                        }
                    });
                    dfd.resolve();
                }, 0);
                return dfd.promise();
            };
            CesiumRenderer.prototype.addGroup = function (group) {
                console.log('addGroup called');
            };
            CesiumRenderer.prototype.removeGroup = function (group) {
                console.log('removeGroup called');
            };
            CesiumRenderer.prototype.removeFeature = function (feature) {
                var _this = this;
                //console.log('removeFeature called');
                var toRemove = [];
                this.viewer.entities.values.forEach(function (entity) {
                    if (entity.feature.id === feature.id) {
                        toRemove.push(entity);
                    }
                });
                toRemove.forEach(function (entity) {
                    _this.viewer.entities.remove(entity);
                });
            };
            CesiumRenderer.prototype.removeFeatures = function (features) {
                var _this = this;
                var dfd = jQuery.Deferred();
                setTimeout(function () {
                    var toRemove = [];
                    _this.viewer.entities.values.forEach(function (entity) {
                        features.forEach(function (feature) {
                            if (entity.feature.id === feature.id) {
                                entity.show(false);
                            }
                        });
                    });
                    toRemove.forEach(function (entity) {
                        _this.viewer.entities.remove(entity);
                    });
                    dfd.resolve();
                }, 0);
                return dfd.promise();
            };
            CesiumRenderer.prototype.updateFeature = function (feature) {
                var _this = this;
                this.viewer.entities.values.forEach(function (entity) {
                    if (entity.feature.id === feature.id)
                        _this.updateEntity(entity, feature);
                });
            };
            /**
             * The feature height is either set in a property as defined in the style (heightProperty), or in a style. Otherwise, it is 0.
             * In either case, the effective style is calculated in LayerService.calculateFeatureStyle.
             */
            CesiumRenderer.prototype.getFeatureHeight = function (feature) {
                return feature.effectiveStyle.height || 0;
            };
            CesiumRenderer.prototype.getHeightAboveSeaLevel = function (feature) {
                return feature.effectiveStyle.heightAboveSeaProperty && feature.properties.hasOwnProperty(feature.effectiveStyle.heightAboveSeaProperty)
                    ? feature.properties[feature.effectiveStyle.heightAboveSeaProperty]
                    : undefined;
            };
            CesiumRenderer.prototype.updateEntity = function (entity, feature) {
                var effStyle = feature.effectiveStyle;
                if (feature.fType.style.iconUri !== undefined && entity.billboard !== undefined) {
                    entity.billboard.width = effStyle.iconWidth;
                    entity.billboard.height = effStyle.iconHeight;
                }
                var fillColor = Cesium.Color.fromCssColorString(effStyle.fillColor);
                switch (feature.geometry.type.toUpperCase()) {
                    case 'POINT':
                    case 'MULTIPOINT':
                        var position = Cesium.Cartesian3.fromDegrees(feature.geometry.coordinates[0], feature.geometry.coordinates[1], feature.geometry.coordinates[2]);
                        entity.position = position;
                        if (entity.point) {
                            entity.point.position = position;
                            entity.point.color = fillColor;
                            entity.point.outlineColor = Cesium.Color.fromCssColorString(effStyle.strokeColor);
                            entity.point.outlineWidth = effStyle.strokeWidth;
                        }
                        break;
                    case 'POLYGON':
                    case 'MULTIPOLYGON':
                        entity.polygon.material = fillColor;
                        entity.polygon.outlineColor = Cesium.Color.fromCssColorString(effStyle.strokeColor);
                        // does not do anything on windows webGL: http://stackoverflow.com/questions/25394677/how-do-you-change-the-width-on-an-ellipseoutlinegeometry-in-cesium-map/25405483#25405483
                        entity.polygon.outlineWidth = effStyle.strokeWidth;
                        var featureHeight = this.getFeatureHeight(feature);
                        var heightAboveSea = this.getHeightAboveSeaLevel(feature);
                        if (heightAboveSea) {
                            entity.polygon.perPositionHeight = false;
                            entity.polygon.extrudedHeight = heightAboveSea + featureHeight;
                            entity.polygon.height = heightAboveSea;
                        }
                        else {
                            entity.polygon.perPositionHeight = true;
                            entity.polygon.extrudedHeight = featureHeight;
                        }
                        break;
                    case 'LINESTRING':
                    case 'MULTILINESTRING':
                        entity.polyline.material = fillColor;
                        entity.polyline.width = effStyle.strokeWidth;
                        break;
                    default:
                        alert('unknown geometry type: ' + feature.geometry.type);
                        break;
                }
            };
            CesiumRenderer.prototype.addFeature = function (feature) {
                var entity = this.createFeature(feature);
            };
            CesiumRenderer.prototype.selectFeature = function (feature) {
                // TODO
                console.log('CesiumRenderer warning: selectFeature is not implemented!');
            };
            CesiumRenderer.prototype.createFeature = function (feature) {
                var featureHeight, heightAboveSea;
                var entity = this.viewer.entities.getOrCreateEntity(feature.id);
                // link the feature to the entity for CommonSense.selectFeature
                entity.feature = feature;
                //if (feature.properties['Name'] !== undefined)
                entity.name = feature.properties['Name'];
                var pixelSize = 5;
                var style = feature.fType.style;
                var effStyle = feature.effectiveStyle;
                var fillColor = Cesium.Color.fromCssColorString(effStyle.fillColor).withAlpha(effStyle.fillOpacity);
                switch (feature.geometry.type.toUpperCase()) {
                    case 'POINT':
                        if (typeof style.iconUri !== 'undefined' && !effStyle.modelUri) {
                            // a billboard is an icon for a feature
                            entity.billboard = {
                                image: style.iconUri,
                                width: effStyle.iconWidth,
                                height: effStyle.iconHeight
                            };
                            // we draw this point very large because it serves as a background for the billboards
                            pixelSize = 35;
                        }
                        else {
                            entity.point = {
                                pixelSize: pixelSize,
                                color: fillColor,
                                outlineColor: Cesium.Color.fromCssColorString(effStyle.strokeColor),
                                outlineWidth: effStyle.strokeWidth
                            };
                        }
                        // if there is no icon, a PointGraphics object is used as a fallback mechanism
                        var position = Cesium.Cartesian3.fromDegrees(feature.geometry.coordinates[0], feature.geometry.coordinates[1], feature.geometry.coordinates[2] || this.getHeightAboveSeaLevel(feature));
                        entity.position = position;
                        //entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(position, effStyle.rotate, 0, 0);
                        break;
                    case 'MULTIPOINT':
                        for (var i = 0; i < feature.geometry.coordinates.length; i++) {
                            var entity_multi = new Cesium.Entity();
                            entity_multi.feature = feature;
                            entity_multi.point = {
                                pixelSize: pixelSize,
                                position: Cesium.Cartesian3.fromDegrees(feature.geometry.coordinates[i][0], feature.geometry.coordinates[i][1], feature.geometry.coordinates[i][2] || this.getHeightAboveSeaLevel(feature)),
                                color: fillColor,
                                outlineColor: Cesium.Color.fromCssColorString(effStyle.strokeColor),
                                outlineWidth: effStyle.strokeWidth
                            };
                            this.viewer.entities.add(entity_multi);
                        }
                        this.viewer.entities.remove(entity);
                        break;
                    case 'POLYGON':
                        featureHeight = this.getFeatureHeight(feature);
                        heightAboveSea = this.getHeightAboveSeaLevel(feature);
                        entity.polygon = new Cesium.PolygonGraphics({
                            hierarchy: this.createPolygon(feature.geometry.coordinates).hierarchy,
                            material: fillColor,
                            outline: style.stroke,
                            outlineColor: Cesium.Color.fromCssColorString(effStyle.strokeColor),
                            // does not do anything on windows webGL: http://stackoverflow.com/questions/25394677/how-do-you-change-the-width-on-an-ellipseoutlinegeometry-in-cesium-map/25405483#25405483
                            outlineWidth: effStyle.strokeWidth
                        });
                        if (heightAboveSea) {
                            entity.polygon.perPositionHeight = false;
                            entity.polygon.extrudedHeight = heightAboveSea + featureHeight;
                            entity.polygon.height = heightAboveSea;
                        }
                        else {
                            entity.polygon.perPositionHeight = true;
                            entity.polygon.extrudedHeight = featureHeight;
                        }
                        break;
                    case 'MULTIPOLYGON':
                        featureHeight = this.getFeatureHeight(feature);
                        heightAboveSea = this.getHeightAboveSeaLevel(feature);
                        var polygons = this.createMultiPolygon(feature.geometry.coordinates);
                        for (var i = 0; i < polygons.length; ++i) {
                            var entity_multi = new Cesium.Entity();
                            entity_multi.feature = feature;
                            var polygon = new Cesium.PolygonGraphics({
                                hierarchy: polygons[i].hierarchy,
                                material: fillColor,
                                outline: style.stroke,
                                outlineColor: Cesium.Color.fromCssColorString(effStyle.strokeColor),
                                outlineWidth: effStyle.strokeWidth
                            });
                            if (heightAboveSea) {
                                polygon.perPositionHeight = false;
                                polygon.extrudedHeight = heightAboveSea + featureHeight;
                                polygon.height = heightAboveSea;
                            }
                            else {
                                polygon.perPositionHeight = true;
                                polygon.extrudedHeight = featureHeight;
                            }
                            entity_multi.polygon = polygon;
                            this.viewer.entities.add(entity_multi);
                        }
                        this.viewer.entities.remove(entity);
                        break;
                    case 'LINESTRING':
                        entity.polyline = new Cesium.PolylineGraphics({
                            positions: this.coordinatesArrayToCartesianArray(feature.geometry.coordinates),
                            material: fillColor,
                            width: effStyle.strokeWidth
                        });
                        break;
                    case 'MULTILINESTRING':
                        for (var i = 0; i < feature.geometry.coordinates.length; i++) {
                            var entity_multi = new Cesium.Entity();
                            entity_multi.feature = feature;
                            entity.polyline = new Cesium.PolylineGraphics({
                                positions: this.coordinatesArrayToCartesianArray(feature.geometry.coordinates[i]),
                                material: fillColor,
                                width: effStyle.strokeWidth
                            });
                            this.viewer.entities.add(entity_multi);
                        }
                        this.viewer.entities.remove(entity);
                        break;
                    default:
                        alert('unknown geometry type: ' + feature.geometry.type);
                        break;
                }
                // add a 3D model if we have one
                if (effStyle.modelUri) {
                    entity.model = new Cesium.ModelGraphics({
                        uri: "/models/" + effStyle.modelUri,
                        scale: effStyle.modelScale || 1,
                        minimumPixelSize: effStyle.modelMinimumPixelSize || 32
                    });
                    // Hide icon and point when we have a 3D model
                    if (entity.billboard !== undefined)
                        entity.billboard.show = false;
                    if (entity.point !== undefined)
                        entity.point.show = false;
                }
                //account for rotation
                if (effStyle.rotate) {
                    var headingQuaternion = Cesium
                        .Transforms
                        .headingPitchRollQuaternion(Cesium.Cartesian3.fromDegrees(feature.geometry.coordinates[0], feature.geometry.coordinates[1], feature.geometry.coordinates[2]), Cesium.Math.toRadians(effStyle.rotate), 0, 0);
                    entity.orientation = headingQuaternion;
                }
                return entity;
            };
            CesiumRenderer.prototype.createPolygon = function (coordinates) {
                if (coordinates.length === 0 || coordinates[0].length === 0)
                    return;
                var polygon = new Cesium.PolygonGraphics();
                var holes = [];
                for (var i = 1, len = coordinates.length; i < len; i++)
                    holes.push(new Cesium.PolygonHierarchy(this.coordinatesArrayToCartesianArray(coordinates[i])));
                var positions = this.coordinatesArrayToCartesianArray(coordinates[0]);
                polygon.hierarchy = new Cesium.PolygonHierarchy(positions, holes);
                return polygon;
            };
            CesiumRenderer.prototype.createMultiPolygon = function (coordinates) {
                var polygons = [];
                for (var i = 0; i < coordinates.length; i++) {
                    polygons.push(this.createPolygon(coordinates[i]));
                }
                return polygons;
            };
            CesiumRenderer.prototype.coordinatesArrayToCartesianArray = function (coordinates) {
                var positions = new Array(coordinates.length);
                for (var i = 0; i < coordinates.length; i++)
                    positions[i] = this.defaultCrsFunction(coordinates[i]);
                return positions;
            };
            CesiumRenderer.prototype.defaultCrsFunction = function (coordinates) {
                return Cesium.Cartesian3.fromDegrees(coordinates[0], coordinates[1], coordinates[2]);
            };
            return CesiumRenderer;
        }());
        Services.CesiumRenderer = CesiumRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=cesiumRenderer.js.map
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var LeafletRenderer = (function () {
            function LeafletRenderer() {
                this.title = 'leaflet';
                this.cntrlIsPressed = false;
            }
            LeafletRenderer.prototype.init = function (service) {
                var _this = this;
                this.service = service;
                this.$messageBusService = service.$messageBusService;
                $(document).keydown(function (e) {
                    _this.cntrlIsPressed = e.ctrlKey;
                });
                $(document).keyup(function () {
                    _this.cntrlIsPressed = false;
                });
            };
            LeafletRenderer.prototype.enable = function () {
                var _this = this;
                if ($('map').length !== 1)
                    return;
                if (this.map) {
                    this.enableMap();
                    return;
                }
                var mapOptions = {
                    zoomControl: false,
                    maxZoom: 22,
                    attributionControl: true
                };
                this.map = this.service.$mapService.map = L.map('map', mapOptions);
                this.map.on('moveend', function (t, event) { return _this.updateBoundingBox(); });
                this.map.on('zoomend', function (t, event) {
                    var z = (_this.service.$mapService.map).getZoom();
                    _this.$messageBusService.publish('map', 'zoom', z);
                });
                this.map.once('load', function () { return _this.updateBoundingBox(); });
            };
            LeafletRenderer.prototype.disable = function () {
                this.disableMap();
                // this.map.remove();
                // this.map = this.service.$mapService.map = null;
                // $('#map').empty();
            };
            LeafletRenderer.prototype.enableMap = function () {
                this.map.dragging.enable();
                this.map.touchZoom.enable();
                this.map.doubleClickZoom.enable();
                this.map.scrollWheelZoom.enable();
                this.map.boxZoom.enable();
                this.map.keyboard.enable();
                if (this.map.tap)
                    this.map.tap.enable();
                document.getElementById('map').style.cursor = 'grab';
            };
            LeafletRenderer.prototype.disableMap = function () {
                this.map.dragging.disable();
                this.map.touchZoom.disable();
                this.map.doubleClickZoom.disable();
                this.map.scrollWheelZoom.disable();
                this.map.boxZoom.disable();
                this.map.keyboard.disable();
                if (this.map.tap)
                    this.map.tap.disable();
                document.getElementById('map').style.cursor = 'default';
            };
            LeafletRenderer.prototype.updateBoundingBox = function () {
                var b = (this.map).getBounds();
                this.$messageBusService.publish('mapbbox', 'update', b.toBBoxString());
                var boundingBox = { southWest: [b.getSouth(), b.getWest()], northEast: [b.getNorth(), b.getEast()] };
                this.service.$mapService.maxBounds = boundingBox;
            };
            LeafletRenderer.prototype.getLatLon = function (x, y) {
                var position = this.map.containerPointToLatLng(new L.Point(x, y));
                return { lat: position.lat, lon: position.lng };
            };
            LeafletRenderer.prototype.getExtent = function () {
                var r = {};
                if (this.map) {
                    var b = this.map.getBounds();
                    var sw = b.getSouthWest();
                    var ne = b.getNorthEast();
                    r.southWest = [sw.lat, sw.lng];
                    r.northEast = [ne.lat, ne.lng];
                }
                return r;
            };
            LeafletRenderer.prototype.fitBounds = function (bounds) {
                var southWest = L.latLng(bounds.southWest[0], bounds.southWest[1]);
                var northEast = L.latLng(bounds.northEast[0], bounds.northEast[1]);
                var lb = L.latLngBounds(southWest, northEast);
                try {
                    this.service.$mapService.map.fitBounds(lb);
                }
                catch (e) { }
            };
            LeafletRenderer.prototype.getZoom = function () {
                return this.service.$mapService.map.getZoom();
            };
            LeafletRenderer.prototype.refreshLayer = function () {
                return;
            };
            LeafletRenderer.prototype.addGroup = function (group) {
                var _this = this;
                if (group.clustering) {
                    group._cluster = new L.MarkerClusterGroup({
                        disableClusteringAtZoom: group.clusterLevel || 0
                    });
                    //maxClusterRadius: (zoom) => { if (zoom > 18) { return 2; } else { return group.maxClusterRadius || 80 } },
                    group._cluster.on('clustermouseover', function (a) {
                        if (a.layer._childClusters.length === 0) {
                            var childs = a.layer.getAllChildMarkers();
                            if (childs[0] && childs[0].hasOwnProperty('feature')) {
                                var f = childs[0].feature;
                                var actions = _this.service.getActions(f, Services.ActionType.Hover);
                                actions.forEach(function (fa) {
                                    if (fa.title.toLowerCase() === 'show') {
                                        fa.callback(f, _this.service);
                                    }
                                });
                            }
                        }
                    });
                    group._cluster.on('clustermouseout', function (a) {
                        if (a.layer._childClusters.length === 0) {
                            var childs = a.layer.getAllChildMarkers();
                            if (childs[0] && childs[0].hasOwnProperty('feature')) {
                                var f = childs[0].feature;
                                var actions = _this.service.getActions(f, Services.ActionType.Hover);
                                actions.forEach(function (fa) {
                                    if (fa.title.toLowerCase() === 'hide') {
                                        fa.callback(f, _this.service);
                                    }
                                });
                            }
                        }
                    });
                    this.map.addLayer(group._cluster);
                }
                else {
                    group._vectors = new L.LayerGroup();
                    this.map.addLayer(group._vectors);
                }
            };
            LeafletRenderer.prototype.removeLayer = function (layer) {
                switch (layer.renderType) {
                    case 'geojson':
                        Services.GeojsonRenderer.remove(this.service, layer);
                        break;
                    default:
                        if (this.service.map.map && layer.mapLayer)
                            this.service.map.map.removeLayer(layer.mapLayer);
                        break;
                }
            };
            LeafletRenderer.prototype.changeBaseLayer = function (layerObj, force) {
                if (force === void 0) { force = false; }
                if (!force && layerObj === this.service.$mapService.activeBaseLayer)
                    return;
                if (this.baseLayer && this.map.hasLayer(this.baseLayer))
                    this.map.removeLayer(this.baseLayer);
                this.baseLayer = this.createBaseLayer(layerObj);
                this.map.addLayer(this.baseLayer, true);
                this.baseLayer.bringToBack();
                this.map.setZoom(this.service.map.map.getZoom());
                this.map.fire('baselayerchange', { layer: this.baseLayer });
            };
            LeafletRenderer.prototype.createBaseLayer = function (layerObj) {
                var options = { noWrap: true };
                options['subtitle'] = layerObj.subtitle;
                options['preview'] = layerObj.preview;
                if (layerObj.subdomains)
                    options['subdomains'] = layerObj.subdomains;
                if (layerObj.minZoom)
                    options.minZoom = layerObj.minZoom;
                if (layerObj.maxZoom)
                    options.maxZoom = layerObj.maxZoom;
                if (layerObj.maxNativeZoom)
                    options.maxNativeZoom = layerObj.maxNativeZoom;
                if (layerObj.errorTileUrl)
                    options.errorTileUrl = layerObj.errorTileUrl;
                if (layerObj.attribution)
                    options.attribution = layerObj.attribution;
                if (layerObj.id)
                    options['id'] = layerObj.id;
                var layers = layerObj.url.split('|');
                var layer = L.tileLayer(layers[0], options);
                if (layers.length > 1) {
                    var projectLayer = new Services.ProjectLayer();
                    projectLayer.url = layers[1];
                    csComp.Services.TileLayerRenderer.addUtfGrid(this.service, projectLayer, layers[1]);
                }
                return layer;
            };
            LeafletRenderer.prototype.getLeafletStyle = function (style) {
                var s = {
                    fillColor: style.fillColor,
                    weight: style.strokeWidth,
                    opacity: style.strokeOpacity,
                    fillOpacity: style.fillOpacity
                };
                s['color'] = (typeof style.stroke !== 'undefined' && style.stroke === false)
                    ? style.fillColor
                    : style.strokeColor;
                return s;
            };
            LeafletRenderer.prototype.addLayer = function (layer) {
                switch (layer.renderType) {
                    case 'geojson':
                        Services.GeojsonRenderer.render(this.service, layer, this);
                        break;
                    case 'tilelayer':
                        Services.TileLayerRenderer.render(this.service, layer);
                        break;
                    case 'wms':
                        Services.WmsRenderer.render(this.service, layer);
                        break;
                    case 'gridlayer':
                        Services.GridLayerRenderer.render(this.service, layer);
                        break;
                    case 'heatmap':
                        Services.HeatmapRenderer.render(this.service, layer, this);
                        break;
                }
            };
            /***
             * Update map markers in cluster after changing filter
             */
            LeafletRenderer.prototype.updateMapFilter = function (group) {
                var _this = this;
                $.each(group.markers, function (key, marker) {
                    var included = marker.feature._gui.included;
                    // if (group.filterResult) included = group.filterResult.filter((f: IFeature) => f.id === key).length > 0;
                    if (group.clustering) {
                        var incluster = group._cluster.hasLayer(marker);
                        if (!included && incluster)
                            group._cluster.removeLayer(marker);
                        if (included && !incluster)
                            group._cluster.addLayer(marker);
                    }
                    else {
                        //var onmap = group.vectors.hasLayer(marker);
                        var onmap = _this.service.map.map.hasLayer(marker);
                        if (!included && onmap)
                            _this.service.map.map.removeLayer(marker);
                        if (included && !onmap)
                            _this.service.map.map.addLayer(marker);
                    }
                });
            };
            LeafletRenderer.prototype.removeGroup = function (group) { };
            LeafletRenderer.prototype.removeFeature = function (feature) {
                var layer = feature.layer;
                switch (layer.renderType) {
                    case 'geojson':
                        var g = layer.group;
                        if (g.clustering) {
                            var m = g._cluster;
                            try {
                                m.removeLayer(layer.group.markers[feature.id]);
                                delete layer.group.markers[feature.id];
                            }
                            catch (error) { }
                        }
                        else {
                            if (layer.group.markers.hasOwnProperty(feature.id)) {
                                layer.mapLayer.removeLayer(layer.group.markers[feature.id]);
                                layer.group._vectors.removeLayer(layer.group.markers[feature.id]);
                                delete layer.group.markers[feature.id];
                            }
                        }
                        break;
                }
                // var marker = <L.Marker>feature.layer.group.markers[feature.id];
                // if (marker != null) {
                //     feature.layer.mapLayer.removeLayer(marker);
                //     delete feature.layer.group.markers[feature.id];
                // }
            };
            LeafletRenderer.prototype.updateFeature = function (feature) {
                if (feature.layer.group == null)
                    return;
                var marker = feature.layer.group.markers[feature.id];
                if (marker == null)
                    return;
                if (feature.geometry.type === 'Point') {
                    marker.setIcon(this.getPointIcon(feature));
                    marker.setLatLng(new L.LatLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]));
                }
                else {
                    marker.setStyle(this.getLeafletStyle(feature.effectiveStyle));
                    if (feature.isSelected && feature.layer && !feature.layer.disableMoveSelectionToFront && feature.layer.group) {
                        if ((feature.layer.group.clustering && feature.layer.group._cluster && feature.layer.group._cluster.hasLayer(marker))
                            || feature.layer.group.markers.hasOwnProperty(marker.feature.id)) {
                            marker.bringToFront();
                        }
                    }
                }
                if (feature.layer.isEditable && marker.dragging) {
                    if (this.canDrag(feature)) {
                        marker.dragging.enable();
                    }
                    else {
                        marker.dragging.disable();
                    }
                    ;
                }
            };
            LeafletRenderer.prototype.selectFeature = function (feature) {
                if (feature._gui.hasOwnProperty('dragged')) {
                    delete feature._gui['dragged'];
                }
                else {
                    this.service.selectFeature(feature, this.cntrlIsPressed);
                }
            };
            LeafletRenderer.prototype.addFeature = function (feature) {
                var _this = this;
                if (feature.geometry != null) {
                    var m = this.createFeature(feature);
                    if (m) {
                        var l = feature.layer;
                        l.group.markers[feature.id] = m;
                        m.on({
                            mouseover: function (a) { return _this.showFeatureTooltip(a, l.group); },
                            mouseout: function (s) { return _this.hideFeatureTooltip(s); },
                            mousemove: function (d) { return _this.updateFeatureTooltip(d); },
                            click: function (e) {
                                _this.selectFeature(feature);
                            }
                        });
                        m.feature = feature;
                        if (l.group.clustering && l.group._cluster) {
                            l.group._cluster.addLayer(m);
                        }
                        else {
                            if (l.mapLayer) {
                                l.mapLayer.addLayer(m);
                            }
                        }
                        return m;
                    }
                }
                return null;
            };
            LeafletRenderer.prototype.canDrag = function (feature) {
                return feature._gui.hasOwnProperty('editMode') && feature._gui['editMode'] === true;
            };
            /**
             * add a feature
             */
            LeafletRenderer.prototype.createFeature = function (feature) {
                var _this = this;
                //this.service.initFeature(feature,layer);
                //var style = type.style;
                var marker;
                switch (feature.geometry.type) {
                    case 'Point':
                        if (!feature.geometry.coordinates.length || isNaN(feature.geometry.coordinates[0]) || isNaN(feature.geometry.coordinates[1]))
                            return;
                        var icon = this.getPointIcon(feature);
                        marker = new L.Marker(new L.LatLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]), {
                            icon: icon, draggable: this.canDrag(feature)
                        });
                        marker.on('contextmenu', function (e) {
                            _this.service._activeContextMenu = _this.service.getActions(feature, Services.ActionType.Context);
                            //e.stopPropagation();
                            var button = $('#map-contextmenu-button');
                            var menu = $('#map-contextmenu');
                            button.dropdown('toggle');
                            var mapSize = _this.map.getSize();
                            if (e.originalEvent.x < (mapSize.x / 2)) {
                                menu.css('left', e.originalEvent.x + 5);
                            }
                            else {
                                menu.css('left', e.originalEvent.x - 5 - menu.width());
                            }
                            if (e.originalEvent.y < (mapSize.y / 2)) {
                                menu.css('top', e.originalEvent.y - 35);
                            }
                            else {
                                menu.css('top', e.originalEvent.y - 70 - menu.height());
                            }
                            if (_this.service.$rootScope.$$phase !== '$apply' && _this.service.$rootScope.$$phase !== '$digest') {
                                _this.service.$rootScope.$apply();
                            }
                        });
                        marker.on('dragstart', function (event) {
                            feature._gui['dragged'] = true;
                        });
                        marker.on('dragend', function (event) {
                            var marker = event.target;
                            var position = marker.getLatLng();
                            feature.geometry.coordinates = [position.lng, position.lat];
                            //marker.setLatLng(new L.LatLng(), { draggable: 'false' });
                            //map.panTo(new L.LatLng(position.lat, position.lng))
                        });
                        break;
                    case 'Overlay':
                        if (!feature.properties.hasOwnProperty('imageUrl'))
                            break;
                        var imageBounds = feature.geometry.coordinates, imageUrl = feature.properties['imageUrl'], opacity = feature.properties.hasOwnProperty('opacity') ? feature.properties['opacity'] : feature.fType.style.opacity, attribution = feature.properties.hasOwnProperty('attribution') ? feature.properties['attribution'] : '';
                        var imageOverlay = L.imageOverlay(imageUrl, imageBounds, { opacity: opacity, attribution: attribution });
                        feature._gui['imageOverlay'] = imageOverlay;
                        imageOverlay.addTo(this.map);
                        break;
                    default:
                        try {
                            marker = L.GeoJSON.geometryToLayer(feature);
                            marker.setStyle(this.getLeafletStyle(feature.effectiveStyle));
                            marker.on('contextmenu', function (e) {
                                _this.service._activeContextMenu = _this.service.getActions(feature, Services.ActionType.Context);
                                //e.stopPropagation();
                                var button = $('#map-contextmenu-button');
                                var menu = $('#map-contextmenu');
                                button.dropdown('toggle');
                                var mapSize = _this.map.getSize();
                                if (e.originalEvent.x < (mapSize.x / 2)) {
                                    menu.css('left', e.originalEvent.x + 5);
                                }
                                else {
                                    menu.css('left', e.originalEvent.x - 5 - menu.width());
                                }
                                if (e.originalEvent.y < (mapSize.y / 2)) {
                                    menu.css('top', e.originalEvent.y - 35);
                                }
                                else {
                                    menu.css('top', e.originalEvent.y - 70 - menu.height());
                                }
                                if (_this.service.$rootScope.$$phase !== '$apply' && _this.service.$rootScope.$$phase !== '$digest') {
                                    _this.service.$rootScope.$apply();
                                }
                            });
                        }
                        catch (e) {
                            console.log('Error creating leaflet feature');
                            console.log(feature);
                        }
                        //marker = L.multiPolygon(latlng, polyoptions);
                        break;
                }
                if (marker) {
                    marker.feature = feature;
                    feature.layer.group.markers[feature.id] = marker;
                }
                return marker;
            };
            /**
             * create icon based of feature style
             */
            LeafletRenderer.prototype.getPointIcon = function (feature) {
                var icon;
                if (feature.htmlStyle != null) {
                    icon = new L.DivIcon({
                        className: '',
                        iconSize: new L.Point(feature.effectiveStyle.iconWidth, feature.effectiveStyle.iconHeight),
                        html: feature.htmlStyle
                    });
                }
                else {
                    var iconHtml = csComp.Helpers.createIconHtml(feature);
                    icon = new L.DivIcon({
                        className: '',
                        iconSize: new L.Point(iconHtml['iconPlusBorderWidth'], iconHtml['iconPlusBorderHeight']),
                        html: iconHtml['html']
                    });
                }
                return icon;
            };
            /**
             * Add a new entry to the tooltip.
             * @param  {string} content: existing HTML content
             * @param  {IFeature} feature: selected feature
             * @param  {string} property: selected property
             * @param  {IPropertyType} meta: meta info added to the group or style filter
             * @param  {string} title: title of the entry
             * @param  {boolean} isFilter: is true, if we need to add a filter icon, otherwise a style icon will be applied
             */
            LeafletRenderer.prototype.addEntryToTooltip = function (content, feature, property, meta, title, isFilter) {
                if (!title || title.length === 0)
                    return {
                        length: 0, content: content
                    };
                var value = feature.properties[property];
                if (typeof value === 'undefined' || value === null)
                    return { length: 0, content: content };
                var valueLength = value.toString().length;
                if (meta) {
                    value = csComp.Helpers.convertPropertyInfo(meta, value);
                    if (meta.type !== 'bbcode')
                        valueLength = value.toString().length;
                }
                else {
                    if (feature.fType._propertyTypeData) {
                        feature.fType._propertyTypeData.some(function (pt) {
                            if (pt.label !== property)
                                return false;
                            meta = pt;
                            value = csComp.Helpers.convertPropertyInfo(pt, value);
                            return true;
                        });
                    }
                }
                return {
                    length: valueLength + title.length,
                    content: content + ("<tr><td><div class=\"fa " + (isFilter ? 'fa-filter' : 'fa-paint-brush') + "\"></td><td>" + title + "</td><td>" + value + "</td></tr>")
                };
            };
            LeafletRenderer.prototype.generateTooltipContent = function (e, group) {
                var _this = this;
                var layer = e.target;
                var feature = layer.feature;
                // add title
                var title = csComp.Helpers.getFeatureTitle(feature);
                var rowLength = (title) ? title.length : 1;
                var content = '<td colspan=\'3\'>' + title + '</td></tr>';
                // add filter values
                if (group.filters != null && group.filters.length > 0) {
                    group.filters.forEach(function (f) {
                        if (!feature.properties.hasOwnProperty(f.property))
                            return;
                        var entry = _this.addEntryToTooltip(content, feature, f.property, f.meta, f.title, true);
                        content = entry.content;
                        rowLength = Math.max(rowLength, entry.length);
                    });
                }
                // add style values, only in case they haven't been added already as filter
                if (group.styles != null && group.styles.length > 0) {
                    group.styles.forEach(function (s) {
                        if (group.filters != null && group.filters.filter(function (f) {
                            return f.property === s.property;
                        }).length === 0 && feature.properties.hasOwnProperty(s.property)) {
                            var entry = _this.addEntryToTooltip(content, feature, s.property, s.meta, s.title, false);
                            content = entry.content;
                            var tl = s.title ? s.title.length : 10;
                            rowLength = Math.max(rowLength, entry.length + tl);
                        }
                    });
                }
                var widthInPixels = Math.max(Math.min(rowLength * 7 + 15, 250), 130);
                return {
                    content: '<table style=\'width:' + widthInPixels + 'px;\'>' + content + '</table>',
                    widthInPixels: widthInPixels
                };
            };
            /**
             * Show tooltip with name, styles & filters.
             */
            LeafletRenderer.prototype.showFeatureTooltip = function (e, group) {
                var _this = this;
                var layer = e.target;
                var feature = layer.feature;
                var tooltip = this.generateTooltipContent(e, group);
                // var layer = e.target;
                // var feature = <Feature>layer.feature;
                // // add title
                // var title = feature.properties['Name'];
                // var rowLength = (title) ? title.length : 1;
                // var content = '<td colspan=\'3\'>' + title + '</td></tr>';
                // // add filter values
                // if (group.filters != null && group.filters.length > 0) {
                //     group.filters.forEach((f: GroupFilter) => {
                //         if (!feature.properties.hasOwnProperty(f.property)) return;
                //         var value = feature.properties[f.property];
                //         if (value) {
                //             var valueLength = value.toString().length;
                //             if (f.meta) {
                //                 value = Helpers.convertPropertyInfo(f.meta, value);
                //                 if (f.meta.type !== 'bbcode') valueLength = value.toString().length;
                //             } else {
                //                 if (feature.fType._propertyTypeData) {
                //                     feature.fType._propertyTypeData.some(pt => {
                //                         if (pt.label !== f.property) return false;
                //                         f.meta = pt;
                //                         value = Helpers.convertPropertyInfo(pt, value);
                //                         return true;
                //                     });
                //                 }
                //             }
                //             rowLength = Math.max(rowLength, valueLength + f.title.length);
                //             content += '<tr><td><div class=\'smallFilterIcon\'></td><td>' + f.title + '</td><td>' + value + '</td></tr>';
                //         }
                //     });
                // }
                // // add style values, only in case they haven't been added already as filter
                // if (group.styles != null && group.styles.length > 0) {
                //     group.styles.forEach((s: GroupStyle) => {
                //         if (group.filters != null && group.filters.filter((f: GroupFilter) => {
                //             return f.property === s.property;
                //         }).length === 0 && feature.properties.hasOwnProperty(s.property)) {
                //             var value = feature.properties[s.property];
                //             var valueLength = value.toString().length;
                //             if (s.meta != null) {
                //                 value = Helpers.convertPropertyInfo(s.meta, value);
                //                 if (s.meta.type !== 'bbcode') valueLength = value.toString().length;
                //             }
                //             var tl = s.title ? s.title.length : 10;
                //             rowLength = Math.max(rowLength, valueLength + tl);
                //             content += '<tr><td><div class=\'smallStyleIcon\'></td><td>' + s.title + '</td><td>' + value + '</td></tr>';
                //         }
                //     });
                // }
                // var widthInPixels = Math.max(Math.min(rowLength * 7 + 15, 250), 130);
                // content = '<table style=\'width:' + widthInPixels + 'px;\'>' + content + '</table>';
                this.popup = L.popup({
                    offset: new L.Point(-tooltip.widthInPixels / 2 - 40, -5),
                    closeOnClick: true,
                    autoPan: false,
                    className: 'featureTooltip'
                }).setLatLng(e.latlng).setContent(tooltip.content).openOn(this.service.map.map);
                //In case a contour is available, show it.
                var hoverActions = this.service.getActions(feature, Services.ActionType.Hover);
                hoverActions.forEach(function (ha) {
                    if (ha.title.toLowerCase() === 'show') {
                        ha.callback(feature, _this.service);
                    }
                });
            };
            LeafletRenderer.prototype.hideFeatureTooltip = function (e) {
                var _this = this;
                if (this.popup && this.service.map.map) {
                    this.service.map.map.closePopup(this.popup);
                    //this.map.map.closePopup(this.popup);
                    this.popup = null;
                }
                //In case a contour is being shown, hide it.
                var layer = e.target;
                var feature = layer.feature;
                if (feature) {
                    var hoverActions = this.service.getActions(feature, Services.ActionType.Hover);
                    hoverActions.forEach(function (ha) {
                        if (ha.title.toLowerCase() === 'hide') {
                            ha.callback(feature, _this.service);
                        }
                    });
                }
            };
            LeafletRenderer.prototype.updateFeatureTooltip = function (e) {
                if (this.popup != null && e.latlng != null)
                    this.popup.setLatLng(e.latlng);
            };
            return LeafletRenderer;
        }());
        Services.LeafletRenderer = LeafletRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
//# sourceMappingURL=leafletRenderer.js.map